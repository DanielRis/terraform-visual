webpackHotUpdate("static/development/pages/_app.js",{

/***/ "./node_modules/amplitude-js/amplitude.umd.js":
/*!****************************************************!*\
  !*** ./node_modules/amplitude-js/amplitude.umd.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  var Constants = {\n    DEFAULT_INSTANCE: '$default_instance',\n    API_VERSION: 2,\n    MAX_STRING_LENGTH: 4096,\n    MAX_PROPERTY_KEYS: 1000,\n    IDENTIFY_EVENT: '$identify',\n    GROUP_IDENTIFY_EVENT: '$groupidentify',\n    // localStorageKeys\n    LAST_EVENT_ID: 'amplitude_lastEventId',\n    LAST_EVENT_TIME: 'amplitude_lastEventTime',\n    LAST_IDENTIFY_ID: 'amplitude_lastIdentifyId',\n    LAST_SEQUENCE_NUMBER: 'amplitude_lastSequenceNumber',\n    SESSION_ID: 'amplitude_sessionId',\n    // Used in cookie as well\n    DEVICE_ID: 'amplitude_deviceId',\n    OPT_OUT: 'amplitude_optOut',\n    USER_ID: 'amplitude_userId',\n    COOKIE_TEST: 'amplitude_cookie_test',\n    COOKIE_PREFIX: \"amp\",\n    // revenue keys\n    REVENUE_EVENT: 'revenue_amount',\n    REVENUE_PRODUCT_ID: '$productId',\n    REVENUE_QUANTITY: '$quantity',\n    REVENUE_PRICE: '$price',\n    REVENUE_REVENUE_TYPE: '$revenueType',\n    AMP_DEVICE_ID_PARAM: 'amp_device_id',\n    // url param\n    REFERRER: 'referrer',\n    // UTM Params\n    UTM_SOURCE: 'utm_source',\n    UTM_MEDIUM: 'utm_medium',\n    UTM_CAMPAIGN: 'utm_campaign',\n    UTM_TERM: 'utm_term',\n    UTM_CONTENT: 'utm_content'\n  };\n\n  /* jshint bitwise: false */\n\n  /*\n   * UTF-8 encoder/decoder\n   * http://www.webtoolkit.info/\n   */\n  var UTF8 = {\n    encode: function encode(s) {\n      var utftext = '';\n\n      for (var n = 0; n < s.length; n++) {\n        var c = s.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        } else if (c > 127 && c < 2048) {\n          utftext += String.fromCharCode(c >> 6 | 192);\n          utftext += String.fromCharCode(c & 63 | 128);\n        } else {\n          utftext += String.fromCharCode(c >> 12 | 224);\n          utftext += String.fromCharCode(c >> 6 & 63 | 128);\n          utftext += String.fromCharCode(c & 63 | 128);\n        }\n      }\n\n      return utftext;\n    },\n    decode: function decode(utftext) {\n      var s = '';\n      var i = 0;\n      var c = 0,\n          c1 = 0,\n          c2 = 0;\n\n      while (i < utftext.length) {\n        c = utftext.charCodeAt(i);\n\n        if (c < 128) {\n          s += String.fromCharCode(c);\n          i++;\n        } else if (c > 191 && c < 224) {\n          c1 = utftext.charCodeAt(i + 1);\n          s += String.fromCharCode((c & 31) << 6 | c1 & 63);\n          i += 2;\n        } else {\n          c1 = utftext.charCodeAt(i + 1);\n          c2 = utftext.charCodeAt(i + 2);\n          s += String.fromCharCode((c & 15) << 12 | (c1 & 63) << 6 | c2 & 63);\n          i += 3;\n        }\n      }\n\n      return s;\n    }\n  };\n\n  /* jshint bitwise: false */\n  /*\n   * Base64 encoder/decoder\n   * http://www.webtoolkit.info/\n   */\n\n  var Base64 = {\n    _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    encode: function encode(input) {\n      try {\n        if (window.btoa && window.atob) {\n          return window.btoa(unescape(encodeURIComponent(input)));\n        }\n      } catch (e) {//log(e);\n      }\n\n      return Base64._encode(input);\n    },\n    _encode: function _encode(input) {\n      var output = '';\n      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n      var i = 0;\n      input = UTF8.encode(input);\n\n      while (i < input.length) {\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output + Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) + Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);\n      }\n\n      return output;\n    },\n    decode: function decode(input) {\n      try {\n        if (window.btoa && window.atob) {\n          return decodeURIComponent(escape(window.atob(input)));\n        }\n      } catch (e) {//log(e);\n      }\n\n      return Base64._decode(input);\n    },\n    _decode: function _decode(input) {\n      var output = '';\n      var chr1, chr2, chr3;\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n      while (i < input.length) {\n        enc1 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc2 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc3 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc4 = Base64._keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 !== 64) {\n          output = output + String.fromCharCode(chr2);\n        }\n\n        if (enc4 !== 64) {\n          output = output + String.fromCharCode(chr3);\n        }\n      }\n\n      output = UTF8.decode(output);\n      return output;\n    }\n  };\n\n  /**\n   * toString ref.\n   * @private\n   */\n  var toString = Object.prototype.toString;\n  /**\n   * Return the type of `val`.\n   * @private\n   * @param {Mixed} val\n   * @return {String}\n   * @api public\n   */\n\n  function type (val) {\n    switch (toString.call(val)) {\n      case '[object Date]':\n        return 'date';\n\n      case '[object RegExp]':\n        return 'regexp';\n\n      case '[object Arguments]':\n        return 'arguments';\n\n      case '[object Array]':\n        return 'array';\n\n      case '[object Error]':\n        return 'error';\n    }\n\n    if (val === null) {\n      return 'null';\n    }\n\n    if (val === undefined) {\n      return 'undefined';\n    }\n\n    if (val !== val) {\n      return 'nan';\n    }\n\n    if (val && val.nodeType === 1) {\n      return 'element';\n    }\n\n    if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n\n    val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);\n    return _typeof(val);\n  }\n\n  var logLevels = {\n    DISABLE: 0,\n    ERROR: 1,\n    WARN: 2,\n    INFO: 3\n  };\n  var logLevel = logLevels.WARN;\n\n  var setLogLevel = function setLogLevel(logLevelName) {\n    if (logLevels.hasOwnProperty(logLevelName)) {\n      logLevel = logLevels[logLevelName];\n    }\n  };\n\n  var getLogLevel = function getLogLevel() {\n    return logLevel;\n  };\n\n  var log = {\n    error: function error(s) {\n      if (logLevel >= logLevels.ERROR) {\n        _log(s);\n      }\n    },\n    warn: function warn(s) {\n      if (logLevel >= logLevels.WARN) {\n        _log(s);\n      }\n    },\n    info: function info(s) {\n      if (logLevel >= logLevels.INFO) {\n        _log(s);\n      }\n    }\n  };\n\n  var _log = function _log(s) {\n    try {\n      console.log('[Amplitude] ' + s);\n    } catch (e) {// console logging not available\n    }\n  };\n\n  var isEmptyString = function isEmptyString(str) {\n    return !str || str.length === 0;\n  };\n\n  var sessionStorageEnabled = function sessionStorageEnabled() {\n    try {\n      if (window.sessionStorage) {\n        return true;\n      }\n    } catch (e) {} // sessionStorage disabled\n\n\n    return false;\n  }; // truncate string values in event and user properties so that request size does not get too large\n\n\n  var truncate = function truncate(value) {\n    if (type(value) === 'array') {\n      for (var i = 0; i < value.length; i++) {\n        value[i] = truncate(value[i]);\n      }\n    } else if (type(value) === 'object') {\n      for (var key in value) {\n        if (value.hasOwnProperty(key)) {\n          value[key] = truncate(value[key]);\n        }\n      }\n    } else {\n      value = _truncateValue(value);\n    }\n\n    return value;\n  };\n\n  var _truncateValue = function _truncateValue(value) {\n    if (type(value) === 'string') {\n      return value.length > Constants.MAX_STRING_LENGTH ? value.substring(0, Constants.MAX_STRING_LENGTH) : value;\n    }\n\n    return value;\n  };\n\n  var validateInput = function validateInput(input, name, expectedType) {\n    if (type(input) !== expectedType) {\n      log.error('Invalid ' + name + ' input type. Expected ' + expectedType + ' but received ' + type(input));\n      return false;\n    }\n\n    return true;\n  }; // do some basic sanitization and type checking, also catch property dicts with more than 1000 key/value pairs\n\n\n  var validateProperties = function validateProperties(properties) {\n    var propsType = type(properties);\n\n    if (propsType !== 'object') {\n      log.error('Error: invalid properties format. Expecting Javascript object, received ' + propsType + ', ignoring');\n      return {};\n    }\n\n    if (Object.keys(properties).length > Constants.MAX_PROPERTY_KEYS) {\n      log.error('Error: too many properties (more than 1000), ignoring');\n      return {};\n    }\n\n    var copy = {}; // create a copy with all of the valid properties\n\n    for (var property in properties) {\n      if (!properties.hasOwnProperty(property)) {\n        continue;\n      } // validate key\n\n\n      var key = property;\n      var keyType = type(key);\n\n      if (keyType !== 'string') {\n        key = String(key);\n        log.warn('WARNING: Non-string property key, received type ' + keyType + ', coercing to string \"' + key + '\"');\n      } // validate value\n\n\n      var value = validatePropertyValue(key, properties[property]);\n\n      if (value === null) {\n        continue;\n      }\n\n      copy[key] = value;\n    }\n\n    return copy;\n  };\n\n  var invalidValueTypes = ['nan', 'function', 'arguments', 'regexp', 'element'];\n\n  var validatePropertyValue = function validatePropertyValue(key, value) {\n    var valueType = type(value);\n\n    if (invalidValueTypes.indexOf(valueType) !== -1) {\n      log.warn('WARNING: Property key \"' + key + '\" with invalid value type ' + valueType + ', ignoring');\n      value = null;\n    } else if (valueType === 'undefined') {\n      value = null;\n    } else if (valueType === 'error') {\n      value = String(value);\n      log.warn('WARNING: Property key \"' + key + '\" with value type error, coercing to ' + value);\n    } else if (valueType === 'array') {\n      // check for nested arrays or objects\n      var arrayCopy = [];\n\n      for (var i = 0; i < value.length; i++) {\n        var element = value[i];\n        var elemType = type(element);\n\n        if (elemType === 'array') {\n          log.warn('WARNING: Cannot have ' + elemType + ' nested in an array property value, skipping');\n          continue;\n        } else if (elemType === 'object') {\n          arrayCopy.push(validateProperties(element));\n        } else {\n          arrayCopy.push(validatePropertyValue(key, element));\n        }\n      }\n\n      value = arrayCopy;\n    } else if (valueType === 'object') {\n      value = validateProperties(value);\n    }\n\n    return value;\n  };\n\n  var validateGroups = function validateGroups(groups) {\n    var groupsType = type(groups);\n\n    if (groupsType !== 'object') {\n      log.error('Error: invalid groups format. Expecting Javascript object, received ' + groupsType + ', ignoring');\n      return {};\n    }\n\n    var copy = {}; // create a copy with all of the valid properties\n\n    for (var group in groups) {\n      if (!groups.hasOwnProperty(group)) {\n        continue;\n      } // validate key\n\n\n      var key = group;\n      var keyType = type(key);\n\n      if (keyType !== 'string') {\n        key = String(key);\n        log.warn('WARNING: Non-string groupType, received type ' + keyType + ', coercing to string \"' + key + '\"');\n      } // validate value\n\n\n      var value = validateGroupName(key, groups[group]);\n\n      if (value === null) {\n        continue;\n      }\n\n      copy[key] = value;\n    }\n\n    return copy;\n  };\n\n  var validateGroupName = function validateGroupName(key, groupName) {\n    var groupNameType = type(groupName);\n\n    if (groupNameType === 'string') {\n      return groupName;\n    }\n\n    if (groupNameType === 'date' || groupNameType === 'number' || groupNameType === 'boolean') {\n      groupName = String(groupName);\n      log.warn('WARNING: Non-string groupName, received type ' + groupNameType + ', coercing to string \"' + groupName + '\"');\n      return groupName;\n    }\n\n    if (groupNameType === 'array') {\n      // check for nested arrays or objects\n      var arrayCopy = [];\n\n      for (var i = 0; i < groupName.length; i++) {\n        var element = groupName[i];\n        var elemType = type(element);\n\n        if (elemType === 'array' || elemType === 'object') {\n          log.warn('WARNING: Skipping nested ' + elemType + ' in array groupName');\n          continue;\n        } else if (elemType === 'string') {\n          arrayCopy.push(element);\n        } else if (elemType === 'date' || elemType === 'number' || elemType === 'boolean') {\n          element = String(element);\n          log.warn('WARNING: Non-string groupName, received type ' + elemType + ', coercing to string \"' + element + '\"');\n          arrayCopy.push(element);\n        }\n      }\n\n      return arrayCopy;\n    }\n\n    log.warn('WARNING: Non-string groupName, received type ' + groupNameType + '. Please use strings or array of strings for groupName');\n  }; // parses the value of a url param (for example ?gclid=1234&...)\n\n\n  var getQueryParam = function getQueryParam(name, query) {\n    name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\");\n    var regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\");\n    var results = regex.exec(query);\n    return results === null ? undefined : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n  };\n\n  var utils = {\n    setLogLevel: setLogLevel,\n    getLogLevel: getLogLevel,\n    logLevels: logLevels,\n    log: log,\n    isEmptyString: isEmptyString,\n    getQueryParam: getQueryParam,\n    sessionStorageEnabled: sessionStorageEnabled,\n    truncate: truncate,\n    validateGroups: validateGroups,\n    validateInput: validateInput,\n    validateProperties: validateProperties\n  };\n\n  var getLocation = function getLocation() {\n    return window.location;\n  };\n\n  var get = function get(name) {\n    try {\n      var ca = document.cookie.split(';');\n      var value = null;\n\n      for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1, c.length);\n        }\n\n        if (c.indexOf(name) === 0) {\n          value = c.substring(name.length, c.length);\n          break;\n        }\n      }\n\n      return value;\n    } catch (e) {\n      return null;\n    }\n  };\n\n  var get2 = function get2(name) {\n    try {\n      var ca = document.cookie.split(';');\n      var value = null;\n\n      for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1, c.length);\n        }\n\n        if (c.indexOf(name) === 0) {\n          value = c.substring(name.length, c.length);\n          break;\n        }\n      }\n\n      return value;\n    } catch (e) {\n      return {\n        error: \"error \".concat(e.msg)\n      };\n    }\n  };\n\n  var set = function set(name, value, opts) {\n    var expires = value !== null ? opts.expirationDays : -1;\n\n    if (expires) {\n      var date = new Date();\n      date.setTime(date.getTime() + expires * 24 * 60 * 60 * 1000);\n      expires = date;\n    }\n\n    var str = name + '=' + value;\n\n    if (expires) {\n      str += '; expires=' + expires.toUTCString();\n    }\n\n    str += '; path=/';\n\n    if (opts.domain) {\n      str += '; domain=' + opts.domain;\n    }\n\n    if (opts.secure) {\n      str += '; Secure';\n    }\n\n    if (opts.sameSite) {\n      str += '; SameSite=' + opts.sameSite;\n    }\n\n    document.cookie = str;\n  }; // test that cookies are enabled - navigator.cookiesEnabled yields false positives in IE, need to test directly\n\n\n  var areCookiesEnabled = function areCookiesEnabled() {\n    var uid = String(new Date());\n\n    try {\n      set(Constants.COOKIE_TEST, uid, {});\n\n      var _areCookiesEnabled = get(Constants.COOKIE_TEST + '=') === uid;\n\n      set(Constants.COOKIE_TEST, null, {});\n      return _areCookiesEnabled;\n    } catch (e) {}\n\n    return false;\n  };\n\n  var baseCookie = {\n    set: set,\n    get: get,\n    get2: get2,\n    areCookiesEnabled: areCookiesEnabled\n  };\n\n  var getHost = function getHost(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.hostname || location.hostname;\n  };\n\n  var topDomain = function topDomain(url) {\n    var host = getHost(url);\n    var parts = host.split('.');\n    var levels = [];\n\n    for (var i = parts.length - 2; i >= 0; --i) {\n      levels.push(parts.slice(i).join('.'));\n    }\n\n    for (var _i = 0; _i < levels.length; ++_i) {\n      var cname = '__tld_test__';\n      var domain = levels[_i];\n      var opts = {\n        domain: '.' + domain\n      };\n      baseCookie.set(cname, 1, opts);\n\n      if (baseCookie.get(cname)) {\n        baseCookie.set(cname, null, opts);\n        return domain;\n      }\n    }\n\n    return '';\n  };\n\n  /*\n   * Cookie data\n   */\n  var _options = {\n    expirationDays: undefined,\n    domain: undefined\n  };\n\n  var reset = function reset() {\n    _options = {\n      expirationDays: undefined,\n      domain: undefined\n    };\n  };\n\n  var options = function options(opts) {\n    if (arguments.length === 0) {\n      return _options;\n    }\n\n    opts = opts || {};\n    _options.expirationDays = opts.expirationDays;\n    _options.secure = opts.secure;\n    _options.sameSite = opts.sameSite;\n    var domain = !utils.isEmptyString(opts.domain) ? opts.domain : '.' + topDomain(getLocation().href);\n    var token = Math.random();\n    _options.domain = domain;\n    set$1('amplitude_test', token);\n    var stored = get$1('amplitude_test');\n\n    if (!stored || stored !== token) {\n      domain = null;\n    }\n\n    remove('amplitude_test');\n    _options.domain = domain;\n    return _options;\n  };\n\n  var _domainSpecific = function _domainSpecific(name) {\n    // differentiate between cookies on different domains\n    var suffix = '';\n\n    if (_options.domain) {\n      suffix = _options.domain.charAt(0) === '.' ? _options.domain.substring(1) : _options.domain;\n    }\n\n    return name + suffix;\n  };\n\n  var get$1 = function get(name) {\n    var nameEq = _domainSpecific(name) + '=';\n    var value = baseCookie.get(nameEq);\n\n    try {\n      if (value) {\n        return JSON.parse(Base64.decode(value));\n      }\n    } catch (e) {\n      return null;\n    }\n\n    return null;\n  };\n\n  var set$1 = function set(name, value) {\n    try {\n      baseCookie.set(_domainSpecific(name), Base64.encode(JSON.stringify(value)), _options);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var setRaw = function setRaw(name, value) {\n    try {\n      baseCookie.set(_domainSpecific(name), value, _options);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var getRaw = function getRaw(name) {\n    var nameEq = _domainSpecific(name) + '=';\n    return baseCookie.get(nameEq);\n  };\n\n  var remove = function remove(name) {\n    try {\n      baseCookie.set(_domainSpecific(name), null, _options);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var Cookie = {\n    reset: reset,\n    options: options,\n    get: get$1,\n    set: set$1,\n    remove: remove,\n    setRaw: setRaw,\n    getRaw: getRaw\n  };\n\n  /* jshint -W020, unused: false, noempty: false, boss: true */\n\n  /*\n   * Implement localStorage to support Firefox 2-3 and IE 5-7\n   */\n  var localStorage; // jshint ignore:line\n\n  {\n    // test that Window.localStorage is available and works\n    var windowLocalStorageAvailable = function windowLocalStorageAvailable() {\n      var uid = new Date();\n      var result;\n\n      try {\n        window.localStorage.setItem(uid, uid);\n        result = window.localStorage.getItem(uid) === String(uid);\n        window.localStorage.removeItem(uid);\n        return result;\n      } catch (e) {// localStorage not available\n      }\n\n      return false;\n    };\n\n    if (windowLocalStorageAvailable()) {\n      localStorage = window.localStorage;\n    } else if (window.globalStorage) {\n      // Firefox 2-3 use globalStorage\n      // See https://developer.mozilla.org/en/dom/storage#globalStorage\n      try {\n        localStorage = window.globalStorage[window.location.hostname];\n      } catch (e) {// Something bad happened...\n      }\n    } else if (typeof document !== 'undefined') {\n      // IE 5-7 use userData\n      // See http://msdn.microsoft.com/en-us/library/ms531424(v=vs.85).aspx\n      var div = document.createElement('div'),\n          attrKey = 'localStorage';\n      div.style.display = 'none';\n      document.getElementsByTagName('head')[0].appendChild(div);\n\n      if (div.addBehavior) {\n        div.addBehavior('#default#userdata');\n        localStorage = {\n          length: 0,\n          setItem: function setItem(k, v) {\n            div.load(attrKey);\n\n            if (!div.getAttribute(k)) {\n              this.length++;\n            }\n\n            div.setAttribute(k, v);\n            div.save(attrKey);\n          },\n          getItem: function getItem(k) {\n            div.load(attrKey);\n            return div.getAttribute(k);\n          },\n          removeItem: function removeItem(k) {\n            div.load(attrKey);\n\n            if (div.getAttribute(k)) {\n              this.length--;\n            }\n\n            div.removeAttribute(k);\n            div.save(attrKey);\n          },\n          clear: function clear() {\n            div.load(attrKey);\n            var i = 0;\n            var attr;\n\n            while (attr = div.XMLDocument.documentElement.attributes[i++]) {\n              div.removeAttribute(attr.name);\n            }\n\n            div.save(attrKey);\n            this.length = 0;\n          },\n          key: function key(k) {\n            div.load(attrKey);\n            return div.XMLDocument.documentElement.attributes[k];\n          }\n        };\n        div.load(attrKey);\n        localStorage.length = div.XMLDocument.documentElement.attributes.length;\n      }\n    }\n\n    if (!localStorage) {\n      localStorage = {\n        length: 0,\n        setItem: function setItem(k, v) {},\n        getItem: function getItem(k) {},\n        removeItem: function removeItem(k) {},\n        clear: function clear() {},\n        key: function key(k) {}\n      };\n    }\n  }\n\n  var localStorage$1 = localStorage;\n\n  /* jshint -W020, unused: false, noempty: false, boss: true */\n\n  var cookieStorage = function cookieStorage() {\n    this.storage = null;\n  }; // test that cookies are enabled - navigator.cookiesEnabled yields false positives in IE, need to test directly\n\n\n  cookieStorage.prototype._cookiesEnabled = function () {\n    var uid = String(new Date());\n    var result;\n\n    try {\n      Cookie.set(Constants.COOKIE_TEST, uid);\n      result = Cookie.get(Constants.COOKIE_TEST) === uid;\n      Cookie.remove(Constants.COOKIE_TEST);\n      return result;\n    } catch (e) {// cookies are not enabled\n    }\n\n    return false;\n  };\n\n  cookieStorage.prototype.getStorage = function () {\n    if (this.storage !== null) {\n      return this.storage;\n    }\n\n    if (this._cookiesEnabled()) {\n      this.storage = Cookie;\n    } else {\n      // if cookies disabled, fallback to localstorage\n      // note: localstorage does not persist across subdomains\n      var keyPrefix = 'amp_cookiestore_';\n      this.storage = {\n        _options: {\n          expirationDays: undefined,\n          domain: undefined,\n          secure: false\n        },\n        reset: function reset() {\n          this._options = {\n            expirationDays: undefined,\n            domain: undefined,\n            secure: false\n          };\n        },\n        options: function options(opts) {\n          if (arguments.length === 0) {\n            return this._options;\n          }\n\n          opts = opts || {};\n          this._options.expirationDays = opts.expirationDays || this._options.expirationDays; // localStorage is specific to subdomains\n\n          this._options.domain = opts.domain || this._options.domain || window && window.location && window.location.hostname;\n          return this._options.secure = opts.secure || false;\n        },\n        get: function get(name) {\n          try {\n            return JSON.parse(localStorage$1.getItem(keyPrefix + name));\n          } catch (e) {}\n\n          return null;\n        },\n        set: function set(name, value) {\n          try {\n            localStorage$1.setItem(keyPrefix + name, JSON.stringify(value));\n            return true;\n          } catch (e) {}\n\n          return false;\n        },\n        remove: function remove(name) {\n          try {\n            localStorage$1.removeItem(keyPrefix + name);\n          } catch (e) {\n            return false;\n          }\n        }\n      };\n    }\n\n    return this.storage;\n  };\n\n  var MetadataStorage =\n  /*#__PURE__*/\n  function () {\n    function MetadataStorage(_ref) {\n      var storageKey = _ref.storageKey,\n          disableCookies = _ref.disableCookies,\n          domain = _ref.domain,\n          secure = _ref.secure,\n          sameSite = _ref.sameSite,\n          expirationDays = _ref.expirationDays;\n\n      _classCallCheck(this, MetadataStorage);\n\n      this.blankCookie = false;\n      this.storageKey = storageKey;\n      this.disableCookieStorage = !baseCookie.areCookiesEnabled() || disableCookies;\n      this.domain = domain;\n      this.secure = secure;\n      this.sameSite = sameSite;\n      this.expirationDays = expirationDays;\n      this.cookieDomain = '';\n\n      {\n        var writableTopDomain = topDomain(getLocation().href);\n        this.cookieDomain = domain || (writableTopDomain ? '.' + writableTopDomain : null);\n      }\n    }\n\n    _createClass(MetadataStorage, [{\n      key: \"getCookieStorageKey\",\n      value: function getCookieStorageKey() {\n        if (!this.domain) {\n          return this.storageKey;\n        }\n\n        var suffix = this.domain.charAt(0) === '.' ? this.domain.substring(1) : this.domain;\n        return \"\".concat(this.storageKey).concat(suffix ? \"_\".concat(suffix) : '');\n      }\n    }, {\n      key: \"save\",\n      value: function save(_ref2) {\n        var deviceId = _ref2.deviceId,\n            userId = _ref2.userId,\n            optOut = _ref2.optOut,\n            sessionId = _ref2.sessionId,\n            lastEventTime = _ref2.lastEventTime,\n            eventId = _ref2.eventId,\n            identifyId = _ref2.identifyId,\n            sequenceNumber = _ref2.sequenceNumber;\n        // do not change the order of these items\n        var value = [deviceId, Base64.encode(userId || ''), optOut ? '1' : '', sessionId ? sessionId.toString(32) : '0', lastEventTime ? lastEventTime.toString(32) : '0', eventId ? eventId.toString(32) : '0', identifyId ? identifyId.toString(32) : '0', sequenceNumber ? sequenceNumber.toString(32) : '0'].join('.');\n\n        if (this.disableCookieStorage) {\n          localStorage$1.setItem(this.storageKey, value);\n        } else {\n          baseCookie.set(this.getCookieStorageKey(), value, {\n            domain: this.cookieDomain,\n            secure: this.secure,\n            sameSite: this.sameSite,\n            expirationDays: this.expirationDays\n          });\n        }\n\n        return \"\".concat(this.getCookieStorageKey(), \" \").concat(value);\n      }\n    }, {\n      key: \"load\",\n      value: function load() {\n        var str;\n\n        if (!this.disableCookieStorage) {\n          str = baseCookie.get2(this.getCookieStorageKey() + '=');\n\n          if (!str) {\n            this.blankCookie = true;\n          }\n\n          if (str && _typeof(str) === 'object') {\n            this.cookieError = str.error;\n            str = '';\n          }\n        }\n\n        if (!str) {\n          str = localStorage$1.getItem(this.storageKey);\n        }\n\n        if (!str) {\n          return null;\n        }\n\n        var values = str.split('.');\n        var userId = null;\n\n        if (values[1]) {\n          try {\n            userId = Base64.decode(values[1]);\n          } catch (e) {\n            userId = null;\n          }\n        }\n\n        return {\n          deviceId: values[0],\n          userId: userId,\n          optOut: values[2] === '1',\n          sessionId: parseInt(values[3], 32),\n          lastEventTime: parseInt(values[4], 32),\n          eventId: parseInt(values[5], 32),\n          identifyId: parseInt(values[6], 32),\n          sequenceNumber: parseInt(values[7], 32)\n        };\n      }\n    }]);\n\n    return MetadataStorage;\n  }();\n\n  var getUtmData = function getUtmData(rawCookie, query) {\n    // Translate the utmz cookie format into url query string format.\n    var cookie = rawCookie ? '?' + rawCookie.split('.').slice(-1)[0].replace(/\\|/g, '&') : '';\n\n    var fetchParam = function fetchParam(queryName, query, cookieName, cookie) {\n      return utils.getQueryParam(queryName, query) || utils.getQueryParam(cookieName, cookie);\n    };\n\n    var utmSource = fetchParam(Constants.UTM_SOURCE, query, 'utmcsr', cookie);\n    var utmMedium = fetchParam(Constants.UTM_MEDIUM, query, 'utmcmd', cookie);\n    var utmCampaign = fetchParam(Constants.UTM_CAMPAIGN, query, 'utmccn', cookie);\n    var utmTerm = fetchParam(Constants.UTM_TERM, query, 'utmctr', cookie);\n    var utmContent = fetchParam(Constants.UTM_CONTENT, query, 'utmcct', cookie);\n    var utmData = {};\n\n    var addIfNotNull = function addIfNotNull(key, value) {\n      if (!utils.isEmptyString(value)) {\n        utmData[key] = value;\n      }\n    };\n\n    addIfNotNull(Constants.UTM_SOURCE, utmSource);\n    addIfNotNull(Constants.UTM_MEDIUM, utmMedium);\n    addIfNotNull(Constants.UTM_CAMPAIGN, utmCampaign);\n    addIfNotNull(Constants.UTM_TERM, utmTerm);\n    addIfNotNull(Constants.UTM_CONTENT, utmContent);\n    return utmData;\n  };\n\n  /*\n   * Wrapper for a user properties JSON object that supports operations.\n   * Note: if a user property is used in multiple operations on the same Identify object,\n   * only the first operation will be saved, and the rest will be ignored.\n   */\n\n  var AMP_OP_ADD = '$add';\n  var AMP_OP_APPEND = '$append';\n  var AMP_OP_CLEAR_ALL = '$clearAll';\n  var AMP_OP_PREPEND = '$prepend';\n  var AMP_OP_SET = '$set';\n  var AMP_OP_SET_ONCE = '$setOnce';\n  var AMP_OP_UNSET = '$unset';\n  /**\n   * Identify API - instance constructor. Identify objects are a wrapper for user property operations.\n   * Each method adds a user property operation to the Identify object, and returns the same Identify object,\n   * allowing you to chain multiple method calls together.\n   * Note: if the same user property is used in multiple operations on a single Identify object,\n   * only the first operation on that property will be saved, and the rest will be ignored.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n   * for more information on the Identify API and user property operations.\n   * @constructor Identify\n   * @public\n   * @example var identify = new amplitude.Identify();\n   */\n\n  var Identify = function Identify() {\n    this.userPropertiesOperations = {};\n    this.properties = []; // keep track of keys that have been added\n  };\n  /**\n   * Increment a user property by a given value (can also be negative to decrement).\n   * If the user property does not have a value set yet, it will be initialized to 0 before being incremented.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string} value - The amount by which to increment the user property. Allows numbers as strings (ex: '123').\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().add('karma', 1).add('friends', 1);\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.add = function (property, value) {\n    if (type(value) === 'number' || type(value) === 'string') {\n      this._addOperation(AMP_OP_ADD, property, value);\n    } else {\n      utils.log.error('Unsupported type for value: ' + type(value) + ', expecting number or string');\n    }\n\n    return this;\n  };\n  /**\n   * Append a value or values to a user property.\n   * If the user property does not have a value set yet,\n   * it will be initialized to an empty list before the new values are appended.\n   * If the user property has an existing value and it is not a list,\n   * the existing value will be converted into a list with the new values appended.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to append.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().append('ab-tests', 'new-user-tests');\n   * identify.append('some_list', [1, 2, 3, 4, 'values']);\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.append = function (property, value) {\n    this._addOperation(AMP_OP_APPEND, property, value);\n\n    return this;\n  };\n  /**\n   * Clear all user properties for the current user.\n   * SDK user should instead call amplitude.clearUserProperties() instead of using this.\n   * $clearAll needs to be sent on its own Identify object. If there are already other operations, then don't add $clearAll.\n   * If $clearAll already in an Identify object, don't allow other operations to be added.\n   * @private\n   */\n\n\n  Identify.prototype.clearAll = function () {\n    if (Object.keys(this.userPropertiesOperations).length > 0) {\n      if (!this.userPropertiesOperations.hasOwnProperty(AMP_OP_CLEAR_ALL)) {\n        utils.log.error('Need to send $clearAll on its own Identify object without any other operations, skipping $clearAll');\n      }\n\n      return this;\n    }\n\n    this.userPropertiesOperations[AMP_OP_CLEAR_ALL] = '-';\n    return this;\n  };\n  /**\n   * Prepend a value or values to a user property.\n   * Prepend means inserting the value or values at the front of a list.\n   * If the user property does not have a value set yet,\n   * it will be initialized to an empty list before the new values are prepended.\n   * If the user property has an existing value and it is not a list,\n   * the existing value will be converted into a list with the new values prepended.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to prepend.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().prepend('ab-tests', 'new-user-tests');\n   * identify.prepend('some_list', [1, 2, 3, 4, 'values']);\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.prepend = function (property, value) {\n    this._addOperation(AMP_OP_PREPEND, property, value);\n\n    return this;\n  };\n  /**\n   * Sets the value of a given user property. If a value already exists, it will be overwriten with the new value.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|boolean|object} value - A value or values to set.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().set('user_type', 'beta');\n   * identify.set('name', {'first': 'John', 'last': 'Doe'}); // dict is flattened and becomes name.first: John, name.last: Doe\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.set = function (property, value) {\n    this._addOperation(AMP_OP_SET, property, value);\n\n    return this;\n  };\n  /**\n   * Sets the value of a given user property only once. Subsequent setOnce operations on that user property will be ignored;\n   * however, that user property can still be modified through any of the other operations.\n   * Useful for capturing properties such as 'initial_signup_date', 'initial_referrer', etc.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|boolean|object} value - A value or values to set once.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().setOnce('sign_up_date', '2016-04-01');\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.setOnce = function (property, value) {\n    this._addOperation(AMP_OP_SET_ONCE, property, value);\n\n    return this;\n  };\n  /**\n   * Unset and remove a user property. This user property will no longer show up in a user's profile.\n   * @public\n   * @param {string} property - The user property key.\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().unset('user_type').unset('age');\n   * amplitude.identify(identify); // send the Identify call\n   */\n\n\n  Identify.prototype.unset = function (property) {\n    this._addOperation(AMP_OP_UNSET, property, '-');\n\n    return this;\n  };\n  /**\n   * Helper function that adds operation to the Identify's object\n   * Handle's filtering of duplicate user property keys, and filtering for clearAll.\n   * @private\n   */\n\n\n  Identify.prototype._addOperation = function (operation, property, value) {\n    // check that the identify doesn't already contain a clearAll\n    if (this.userPropertiesOperations.hasOwnProperty(AMP_OP_CLEAR_ALL)) {\n      utils.log.error('This identify already contains a $clearAll operation, skipping operation ' + operation);\n      return;\n    } // check that property wasn't already used in this Identify\n\n\n    if (this.properties.indexOf(property) !== -1) {\n      utils.log.error('User property \"' + property + '\" already used in this identify, skipping operation ' + operation);\n      return;\n    }\n\n    if (!this.userPropertiesOperations.hasOwnProperty(operation)) {\n      this.userPropertiesOperations[operation] = {};\n    }\n\n    this.userPropertiesOperations[operation][property] = value;\n    this.properties.push(property);\n  };\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var md5 = createCommonjsModule(function (module) {\n  (function ($) {\n\n    /*\n    * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n    * to work around bugs in some JS interpreters.\n    */\n    function safeAdd (x, y) {\n      var lsw = (x & 0xffff) + (y & 0xffff);\n      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n      return (msw << 16) | (lsw & 0xffff)\n    }\n\n    /*\n    * Bitwise rotate a 32-bit number to the left.\n    */\n    function bitRotateLeft (num, cnt) {\n      return (num << cnt) | (num >>> (32 - cnt))\n    }\n\n    /*\n    * These functions implement the four basic operations the algorithm uses.\n    */\n    function md5cmn (q, a, b, x, s, t) {\n      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n    }\n    function md5ff (a, b, c, d, x, s, t) {\n      return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n    }\n    function md5gg (a, b, c, d, x, s, t) {\n      return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n    }\n    function md5hh (a, b, c, d, x, s, t) {\n      return md5cmn(b ^ c ^ d, a, b, x, s, t)\n    }\n    function md5ii (a, b, c, d, x, s, t) {\n      return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n    }\n\n    /*\n    * Calculate the MD5 of an array of little-endian words, and a bit length.\n    */\n    function binlMD5 (x, len) {\n      /* append padding */\n      x[len >> 5] |= 0x80 << (len % 32);\n      x[((len + 64) >>> 9 << 4) + 14] = len;\n\n      var i;\n      var olda;\n      var oldb;\n      var oldc;\n      var oldd;\n      var a = 1732584193;\n      var b = -271733879;\n      var c = -1732584194;\n      var d = 271733878;\n\n      for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n      }\n      return [a, b, c, d]\n    }\n\n    /*\n    * Convert an array of little-endian words to a string\n    */\n    function binl2rstr (input) {\n      var i;\n      var output = '';\n      var length32 = input.length * 32;\n      for (i = 0; i < length32; i += 8) {\n        output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff);\n      }\n      return output\n    }\n\n    /*\n    * Convert a raw string to an array of little-endian words\n    * Characters >255 have their high-byte silently ignored.\n    */\n    function rstr2binl (input) {\n      var i;\n      var output = [];\n      output[(input.length >> 2) - 1] = undefined;\n      for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n      }\n      var length8 = input.length * 8;\n      for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32);\n      }\n      return output\n    }\n\n    /*\n    * Calculate the MD5 of a raw string\n    */\n    function rstrMD5 (s) {\n      return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n    }\n\n    /*\n    * Calculate the HMAC-MD5, of a key and some data (raw strings)\n    */\n    function rstrHMACMD5 (key, data) {\n      var i;\n      var bkey = rstr2binl(key);\n      var ipad = [];\n      var opad = [];\n      var hash;\n      ipad[15] = opad[15] = undefined;\n      if (bkey.length > 16) {\n        bkey = binlMD5(bkey, key.length * 8);\n      }\n      for (i = 0; i < 16; i += 1) {\n        ipad[i] = bkey[i] ^ 0x36363636;\n        opad[i] = bkey[i] ^ 0x5c5c5c5c;\n      }\n      hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\n      return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n    }\n\n    /*\n    * Convert a raw string to a hex string\n    */\n    function rstr2hex (input) {\n      var hexTab = '0123456789abcdef';\n      var output = '';\n      var x;\n      var i;\n      for (i = 0; i < input.length; i += 1) {\n        x = input.charCodeAt(i);\n        output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);\n      }\n      return output\n    }\n\n    /*\n    * Encode a string as utf-8\n    */\n    function str2rstrUTF8 (input) {\n      return unescape(encodeURIComponent(input))\n    }\n\n    /*\n    * Take string arguments and return either raw or hex encoded strings\n    */\n    function rawMD5 (s) {\n      return rstrMD5(str2rstrUTF8(s))\n    }\n    function hexMD5 (s) {\n      return rstr2hex(rawMD5(s))\n    }\n    function rawHMACMD5 (k, d) {\n      return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n    }\n    function hexHMACMD5 (k, d) {\n      return rstr2hex(rawHMACMD5(k, d))\n    }\n\n    function md5 (string, key, raw) {\n      if (!key) {\n        if (!raw) {\n          return hexMD5(string)\n        }\n        return rawMD5(string)\n      }\n      if (!raw) {\n        return hexHMACMD5(key, string)\n      }\n      return rawHMACMD5(key, string)\n    }\n\n    if (module.exports) {\n      module.exports = md5;\n    } else {\n      $.md5 = md5;\n    }\n  })(commonjsGlobal);\n  });\n\n  var strictUriEncode = function (str) {\n  \treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n  \t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  \t});\n  };\n\n  /*\n  object-assign\n  (c) Sindre Sorhus\n  @license MIT\n  */\n  /* eslint-disable no-unused-vars */\n  var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n  function toObject(val) {\n  \tif (val === null || val === undefined) {\n  \t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n  \t}\n\n  \treturn Object(val);\n  }\n\n  function shouldUseNative() {\n  \ttry {\n  \t\tif (!Object.assign) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\t// Detect buggy property enumeration order in older V8 versions.\n\n  \t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n  \t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n  \t\ttest1[5] = 'de';\n  \t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n  \t\tvar test2 = {};\n  \t\tfor (var i = 0; i < 10; i++) {\n  \t\t\ttest2['_' + String.fromCharCode(i)] = i;\n  \t\t}\n  \t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n  \t\t\treturn test2[n];\n  \t\t});\n  \t\tif (order2.join('') !== '0123456789') {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n  \t\tvar test3 = {};\n  \t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n  \t\t\ttest3[letter] = letter;\n  \t\t});\n  \t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n  \t\t\t\t'abcdefghijklmnopqrst') {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\treturn true;\n  \t} catch (err) {\n  \t\t// We don't expect any of the above to throw, but better to be safe.\n  \t\treturn false;\n  \t}\n  }\n\n  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n  \tvar from;\n  \tvar to = toObject(target);\n  \tvar symbols;\n\n  \tfor (var s = 1; s < arguments.length; s++) {\n  \t\tfrom = Object(arguments[s]);\n\n  \t\tfor (var key in from) {\n  \t\t\tif (hasOwnProperty.call(from, key)) {\n  \t\t\t\tto[key] = from[key];\n  \t\t\t}\n  \t\t}\n\n  \t\tif (getOwnPropertySymbols) {\n  \t\t\tsymbols = getOwnPropertySymbols(from);\n  \t\t\tfor (var i = 0; i < symbols.length; i++) {\n  \t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n  \t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn to;\n  };\n\n  var token = '%[a-f0-9]{2}';\n  var singleMatcher = new RegExp(token, 'gi');\n  var multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\n  function decodeComponents(components, split) {\n  \ttry {\n  \t\t// Try to decode the entire string first\n  \t\treturn decodeURIComponent(components.join(''));\n  \t} catch (err) {\n  \t\t// Do nothing\n  \t}\n\n  \tif (components.length === 1) {\n  \t\treturn components;\n  \t}\n\n  \tsplit = split || 1;\n\n  \t// Split the array in 2 parts\n  \tvar left = components.slice(0, split);\n  \tvar right = components.slice(split);\n\n  \treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n  }\n\n  function decode(input) {\n  \ttry {\n  \t\treturn decodeURIComponent(input);\n  \t} catch (err) {\n  \t\tvar tokens = input.match(singleMatcher);\n\n  \t\tfor (var i = 1; i < tokens.length; i++) {\n  \t\t\tinput = decodeComponents(tokens, i).join('');\n\n  \t\t\ttokens = input.match(singleMatcher);\n  \t\t}\n\n  \t\treturn input;\n  \t}\n  }\n\n  function customDecodeURIComponent(input) {\n  \t// Keep track of all the replacements and prefill the map with the `BOM`\n  \tvar replaceMap = {\n  \t\t'%FE%FF': '\\uFFFD\\uFFFD',\n  \t\t'%FF%FE': '\\uFFFD\\uFFFD'\n  \t};\n\n  \tvar match = multiMatcher.exec(input);\n  \twhile (match) {\n  \t\ttry {\n  \t\t\t// Decode as big chunks as possible\n  \t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n  \t\t} catch (err) {\n  \t\t\tvar result = decode(match[0]);\n\n  \t\t\tif (result !== match[0]) {\n  \t\t\t\treplaceMap[match[0]] = result;\n  \t\t\t}\n  \t\t}\n\n  \t\tmatch = multiMatcher.exec(input);\n  \t}\n\n  \t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n  \treplaceMap['%C2'] = '\\uFFFD';\n\n  \tvar entries = Object.keys(replaceMap);\n\n  \tfor (var i = 0; i < entries.length; i++) {\n  \t\t// Replace all decoded components\n  \t\tvar key = entries[i];\n  \t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  \t}\n\n  \treturn input;\n  }\n\n  var decodeUriComponent = function (encodedURI) {\n  \tif (typeof encodedURI !== 'string') {\n  \t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  \t}\n\n  \ttry {\n  \t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n  \t\t// Try the built in decoder first\n  \t\treturn decodeURIComponent(encodedURI);\n  \t} catch (err) {\n  \t\t// Fallback to a more advanced decoder\n  \t\treturn customDecodeURIComponent(encodedURI);\n  \t}\n  };\n\n  function encoderForArrayFormat(opts) {\n  \tswitch (opts.arrayFormat) {\n  \t\tcase 'index':\n  \t\t\treturn function (key, value, index) {\n  \t\t\t\treturn value === null ? [\n  \t\t\t\t\tencode(key, opts),\n  \t\t\t\t\t'[',\n  \t\t\t\t\tindex,\n  \t\t\t\t\t']'\n  \t\t\t\t].join('') : [\n  \t\t\t\t\tencode(key, opts),\n  \t\t\t\t\t'[',\n  \t\t\t\t\tencode(index, opts),\n  \t\t\t\t\t']=',\n  \t\t\t\t\tencode(value, opts)\n  \t\t\t\t].join('');\n  \t\t\t};\n\n  \t\tcase 'bracket':\n  \t\t\treturn function (key, value) {\n  \t\t\t\treturn value === null ? encode(key, opts) : [\n  \t\t\t\t\tencode(key, opts),\n  \t\t\t\t\t'[]=',\n  \t\t\t\t\tencode(value, opts)\n  \t\t\t\t].join('');\n  \t\t\t};\n\n  \t\tdefault:\n  \t\t\treturn function (key, value) {\n  \t\t\t\treturn value === null ? encode(key, opts) : [\n  \t\t\t\t\tencode(key, opts),\n  \t\t\t\t\t'=',\n  \t\t\t\t\tencode(value, opts)\n  \t\t\t\t].join('');\n  \t\t\t};\n  \t}\n  }\n\n  function parserForArrayFormat(opts) {\n  \tvar result;\n\n  \tswitch (opts.arrayFormat) {\n  \t\tcase 'index':\n  \t\t\treturn function (key, value, accumulator) {\n  \t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n  \t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n  \t\t\t\tif (!result) {\n  \t\t\t\t\taccumulator[key] = value;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tif (accumulator[key] === undefined) {\n  \t\t\t\t\taccumulator[key] = {};\n  \t\t\t\t}\n\n  \t\t\t\taccumulator[key][result[1]] = value;\n  \t\t\t};\n\n  \t\tcase 'bracket':\n  \t\t\treturn function (key, value, accumulator) {\n  \t\t\t\tresult = /(\\[\\])$/.exec(key);\n  \t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n  \t\t\t\tif (!result) {\n  \t\t\t\t\taccumulator[key] = value;\n  \t\t\t\t\treturn;\n  \t\t\t\t} else if (accumulator[key] === undefined) {\n  \t\t\t\t\taccumulator[key] = [value];\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n  \t\t\t};\n\n  \t\tdefault:\n  \t\t\treturn function (key, value, accumulator) {\n  \t\t\t\tif (accumulator[key] === undefined) {\n  \t\t\t\t\taccumulator[key] = value;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n  \t\t\t};\n  \t}\n  }\n\n  function encode(value, opts) {\n  \tif (opts.encode) {\n  \t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n  \t}\n\n  \treturn value;\n  }\n\n  function keysSorter(input) {\n  \tif (Array.isArray(input)) {\n  \t\treturn input.sort();\n  \t} else if (typeof input === 'object') {\n  \t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n  \t\t\treturn Number(a) - Number(b);\n  \t\t}).map(function (key) {\n  \t\t\treturn input[key];\n  \t\t});\n  \t}\n\n  \treturn input;\n  }\n\n  function extract(str) {\n  \tvar queryStart = str.indexOf('?');\n  \tif (queryStart === -1) {\n  \t\treturn '';\n  \t}\n  \treturn str.slice(queryStart + 1);\n  }\n\n  function parse(str, opts) {\n  \topts = objectAssign({arrayFormat: 'none'}, opts);\n\n  \tvar formatter = parserForArrayFormat(opts);\n\n  \t// Create an object with no prototype\n  \t// https://github.com/sindresorhus/query-string/issues/47\n  \tvar ret = Object.create(null);\n\n  \tif (typeof str !== 'string') {\n  \t\treturn ret;\n  \t}\n\n  \tstr = str.trim().replace(/^[?#&]/, '');\n\n  \tif (!str) {\n  \t\treturn ret;\n  \t}\n\n  \tstr.split('&').forEach(function (param) {\n  \t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n  \t\t// Firefox (pre 40) decodes `%3D` to `=`\n  \t\t// https://github.com/sindresorhus/query-string/pull/37\n  \t\tvar key = parts.shift();\n  \t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n  \t\t// missing `=` should be `null`:\n  \t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n  \t\tval = val === undefined ? null : decodeUriComponent(val);\n\n  \t\tformatter(decodeUriComponent(key), val, ret);\n  \t});\n\n  \treturn Object.keys(ret).sort().reduce(function (result, key) {\n  \t\tvar val = ret[key];\n  \t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n  \t\t\t// Sort object keys, not values\n  \t\t\tresult[key] = keysSorter(val);\n  \t\t} else {\n  \t\t\tresult[key] = val;\n  \t\t}\n\n  \t\treturn result;\n  \t}, Object.create(null));\n  }\n\n  var extract_1 = extract;\n  var parse_1 = parse;\n\n  var stringify = function (obj, opts) {\n  \tvar defaults = {\n  \t\tencode: true,\n  \t\tstrict: true,\n  \t\tarrayFormat: 'none'\n  \t};\n\n  \topts = objectAssign(defaults, opts);\n\n  \tif (opts.sort === false) {\n  \t\topts.sort = function () {};\n  \t}\n\n  \tvar formatter = encoderForArrayFormat(opts);\n\n  \treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n  \t\tvar val = obj[key];\n\n  \t\tif (val === undefined) {\n  \t\t\treturn '';\n  \t\t}\n\n  \t\tif (val === null) {\n  \t\t\treturn encode(key, opts);\n  \t\t}\n\n  \t\tif (Array.isArray(val)) {\n  \t\t\tvar result = [];\n\n  \t\t\tval.slice().forEach(function (val2) {\n  \t\t\t\tif (val2 === undefined) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tresult.push(formatter(key, val2, result.length));\n  \t\t\t});\n\n  \t\t\treturn result.join('&');\n  \t\t}\n\n  \t\treturn encode(key, opts) + '=' + encode(val, opts);\n  \t}).filter(function (x) {\n  \t\treturn x.length > 0;\n  \t}).join('&') : '';\n  };\n\n  var parseUrl = function (str, opts) {\n  \treturn {\n  \t\turl: str.split('?')[0] || '',\n  \t\tquery: parse(extract(str), opts)\n  \t};\n  };\n\n  var queryString = {\n  \textract: extract_1,\n  \tparse: parse_1,\n  \tstringify: stringify,\n  \tparseUrl: parseUrl\n  };\n\n  /*\n   * Simple AJAX request object\n   */\n\n  var Request = function Request(url, data) {\n    this.url = url;\n    this.data = data || {};\n  };\n\n  Request.prototype.send = function (callback) {\n    var isIE = window.XDomainRequest ? true : false;\n\n    if (isIE) {\n      var xdr = new window.XDomainRequest();\n      xdr.open('POST', this.url, true);\n\n      xdr.onload = function () {\n        callback(200, xdr.responseText);\n      };\n\n      xdr.onerror = function () {\n        // status code not available from xdr, try string matching on responseText\n        if (xdr.responseText === 'Request Entity Too Large') {\n          callback(413, xdr.responseText);\n        } else {\n          callback(500, xdr.responseText);\n        }\n      };\n\n      xdr.ontimeout = function () {};\n\n      xdr.onprogress = function () {};\n\n      xdr.send(queryString.stringify(this.data));\n    } else {\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', this.url, true);\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          callback(xhr.status, xhr.responseText);\n        }\n      };\n\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n      xhr.send(queryString.stringify(this.data));\n    } //log('sent request to ' + this.url + ' with data ' + decodeURIComponent(queryString(this.data)));\n\n  };\n\n  /*\n   * Wrapper for logging Revenue data. Revenue objects get passed to amplitude.logRevenueV2 to send to Amplitude servers.\n   * Note: price is the only required field. If quantity is not specified, then defaults to 1.\n   */\n\n  /**\n   * Revenue API - instance constructor. Revenue objects are a wrapper for revenue data.\n   * Each method updates a revenue property in the Revenue object, and returns the same Revenue object,\n   * allowing you to chain multiple method calls together.\n   * Note: price is a required field to log revenue events.\n   * If quantity is not specified then defaults to 1.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue} for more information\n   * about logging Revenue.\n   * @constructor Revenue\n   * @public\n   * @example var revenue = new amplitude.Revenue();\n   */\n\n  var Revenue = function Revenue() {\n    // required fields\n    this._price = null; // optional fields\n\n    this._productId = null;\n    this._quantity = 1;\n    this._revenueType = null;\n    this._properties = null;\n  };\n  /**\n   * Set a value for the product identifer.\n   * @public\n   * @param {string} productId - The value for the product identifier. Empty and invalid strings are ignored.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n\n\n  Revenue.prototype.setProductId = function setProductId(productId) {\n    if (type(productId) !== 'string') {\n      utils.log.error('Unsupported type for productId: ' + type(productId) + ', expecting string');\n    } else if (utils.isEmptyString(productId)) {\n      utils.log.error('Invalid empty productId');\n    } else {\n      this._productId = productId;\n    }\n\n    return this;\n  };\n  /**\n   * Set a value for the quantity. Note revenue amount is calculated as price * quantity.\n   * @public\n   * @param {number} quantity - Integer value for the quantity. If not set, quantity defaults to 1.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setQuantity(5);\n   * amplitude.logRevenueV2(revenue);\n   */\n\n\n  Revenue.prototype.setQuantity = function setQuantity(quantity) {\n    if (type(quantity) !== 'number') {\n      utils.log.error('Unsupported type for quantity: ' + type(quantity) + ', expecting number');\n    } else {\n      this._quantity = parseInt(quantity);\n    }\n\n    return this;\n  };\n  /**\n   * Set a value for the price. This field is required for all revenue being logged.\n   * Note revenue amount is calculated as price * quantity.\n   * @public\n   * @param {number} price - Double value for the quantity.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n\n\n  Revenue.prototype.setPrice = function setPrice(price) {\n    if (type(price) !== 'number') {\n      utils.log.error('Unsupported type for price: ' + type(price) + ', expecting number');\n    } else {\n      this._price = price;\n    }\n\n    return this;\n  };\n  /**\n   * Set a value for the revenueType (for example purchase, cost, tax, refund, etc).\n   * @public\n   * @param {string} revenueType - RevenueType to designate.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setRevenueType('purchase');\n   * amplitude.logRevenueV2(revenue);\n   */\n\n\n  Revenue.prototype.setRevenueType = function setRevenueType(revenueType) {\n    if (type(revenueType) !== 'string') {\n      utils.log.error('Unsupported type for revenueType: ' + type(revenueType) + ', expecting string');\n    } else {\n      this._revenueType = revenueType;\n    }\n\n    return this;\n  };\n  /**\n   * Set event properties for the revenue event.\n   * @public\n   * @param {object} eventProperties - Revenue event properties to set.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var event_properties = {'city': 'San Francisco'};\n   * var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setEventProperties(event_properties);\n   * amplitude.logRevenueV2(revenue);\n  */\n\n\n  Revenue.prototype.setEventProperties = function setEventProperties(eventProperties) {\n    if (type(eventProperties) !== 'object') {\n      utils.log.error('Unsupported type for eventProperties: ' + type(eventProperties) + ', expecting object');\n    } else {\n      this._properties = utils.validateProperties(eventProperties);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   */\n\n\n  Revenue.prototype._isValidRevenue = function _isValidRevenue() {\n    if (type(this._price) !== 'number') {\n      utils.log.error('Invalid revenue, need to set price field');\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   */\n\n\n  Revenue.prototype._toJSONObject = function _toJSONObject() {\n    var obj = type(this._properties) === 'object' ? this._properties : {};\n\n    if (this._productId !== null) {\n      obj[Constants.REVENUE_PRODUCT_ID] = this._productId;\n    }\n\n    if (this._quantity !== null) {\n      obj[Constants.REVENUE_QUANTITY] = this._quantity;\n    }\n\n    if (this._price !== null) {\n      obj[Constants.REVENUE_PRICE] = this._price;\n    }\n\n    if (this._revenueType !== null) {\n      obj[Constants.REVENUE_REVENUE_TYPE] = this._revenueType;\n    }\n\n    return obj;\n  };\n\n  var uaParser = createCommonjsModule(function (module, exports) {\n  /*!\n   * UAParser.js v0.7.21\n   * Lightweight JavaScript-based User-Agent string parser\n   * https://github.com/faisalman/ua-parser-js\n   *\n   * Copyright © 2012-2019 Faisal Salman <f@faisalman.com>\n   * Licensed under MIT License\n   */\n\n  (function (window, undefined$1) {\n\n      //////////////\n      // Constants\n      /////////////\n\n\n      var LIBVERSION  = '0.7.21',\n          EMPTY       = '',\n          UNKNOWN     = '?',\n          FUNC_TYPE   = 'function',\n          OBJ_TYPE    = 'object',\n          STR_TYPE    = 'string',\n          MAJOR       = 'major', // deprecated\n          MODEL       = 'model',\n          NAME        = 'name',\n          TYPE        = 'type',\n          VENDOR      = 'vendor',\n          VERSION     = 'version',\n          ARCHITECTURE= 'architecture',\n          CONSOLE     = 'console',\n          MOBILE      = 'mobile',\n          TABLET      = 'tablet',\n          SMARTTV     = 'smarttv',\n          WEARABLE    = 'wearable',\n          EMBEDDED    = 'embedded';\n\n\n      ///////////\n      // Helper\n      //////////\n\n\n      var util = {\n          extend : function (regexes, extensions) {\n              var mergedRegexes = {};\n              for (var i in regexes) {\n                  if (extensions[i] && extensions[i].length % 2 === 0) {\n                      mergedRegexes[i] = extensions[i].concat(regexes[i]);\n                  } else {\n                      mergedRegexes[i] = regexes[i];\n                  }\n              }\n              return mergedRegexes;\n          },\n          has : function (str1, str2) {\n            if (typeof str1 === \"string\") {\n              return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;\n            } else {\n              return false;\n            }\n          },\n          lowerize : function (str) {\n              return str.toLowerCase();\n          },\n          major : function (version) {\n              return typeof(version) === STR_TYPE ? version.replace(/[^\\d\\.]/g,'').split(\".\")[0] : undefined$1;\n          },\n          trim : function (str) {\n            return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n          }\n      };\n\n\n      ///////////////\n      // Map helper\n      //////////////\n\n\n      var mapper = {\n\n          rgx : function (ua, arrays) {\n\n              var i = 0, j, k, p, q, matches, match;\n\n              // loop through all regexes maps\n              while (i < arrays.length && !matches) {\n\n                  var regex = arrays[i],       // even sequence (0,2,4,..)\n                      props = arrays[i + 1];   // odd sequence (1,3,5,..)\n                  j = k = 0;\n\n                  // try matching uastring with regexes\n                  while (j < regex.length && !matches) {\n\n                      matches = regex[j++].exec(ua);\n\n                      if (!!matches) {\n                          for (p = 0; p < props.length; p++) {\n                              match = matches[++k];\n                              q = props[p];\n                              // check if given property is actually array\n                              if (typeof q === OBJ_TYPE && q.length > 0) {\n                                  if (q.length == 2) {\n                                      if (typeof q[1] == FUNC_TYPE) {\n                                          // assign modified match\n                                          this[q[0]] = q[1].call(this, match);\n                                      } else {\n                                          // assign given value, ignore regex match\n                                          this[q[0]] = q[1];\n                                      }\n                                  } else if (q.length == 3) {\n                                      // check whether function or regex\n                                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                                          // call function (usually string mapper)\n                                          this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;\n                                      } else {\n                                          // sanitize match using given regex\n                                          this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;\n                                      }\n                                  } else if (q.length == 4) {\n                                          this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;\n                                  }\n                              } else {\n                                  this[q] = match ? match : undefined$1;\n                              }\n                          }\n                      }\n                  }\n                  i += 2;\n              }\n          },\n\n          str : function (str, map) {\n\n              for (var i in map) {\n                  // check if array\n                  if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n                      for (var j = 0; j < map[i].length; j++) {\n                          if (util.has(map[i][j], str)) {\n                              return (i === UNKNOWN) ? undefined$1 : i;\n                          }\n                      }\n                  } else if (util.has(map[i], str)) {\n                      return (i === UNKNOWN) ? undefined$1 : i;\n                  }\n              }\n              return str;\n          }\n      };\n\n\n      ///////////////\n      // String map\n      //////////////\n\n\n      var maps = {\n\n          browser : {\n              oldsafari : {\n                  version : {\n                      '1.0'   : '/8',\n                      '1.2'   : '/1',\n                      '1.3'   : '/3',\n                      '2.0'   : '/412',\n                      '2.0.2' : '/416',\n                      '2.0.3' : '/417',\n                      '2.0.4' : '/419',\n                      '?'     : '/'\n                  }\n              }\n          },\n\n          device : {\n              amazon : {\n                  model : {\n                      'Fire Phone' : ['SD', 'KF']\n                  }\n              },\n              sprint : {\n                  model : {\n                      'Evo Shift 4G' : '7373KT'\n                  },\n                  vendor : {\n                      'HTC'       : 'APA',\n                      'Sprint'    : 'Sprint'\n                  }\n              }\n          },\n\n          os : {\n              windows : {\n                  version : {\n                      'ME'        : '4.90',\n                      'NT 3.11'   : 'NT3.51',\n                      'NT 4.0'    : 'NT4.0',\n                      '2000'      : 'NT 5.0',\n                      'XP'        : ['NT 5.1', 'NT 5.2'],\n                      'Vista'     : 'NT 6.0',\n                      '7'         : 'NT 6.1',\n                      '8'         : 'NT 6.2',\n                      '8.1'       : 'NT 6.3',\n                      '10'        : ['NT 6.4', 'NT 10.0'],\n                      'RT'        : 'ARM'\n                  }\n              }\n          }\n      };\n\n\n      //////////////\n      // Regex map\n      /////////////\n\n\n      var regexes = {\n\n          browser : [[\n\n              // Presto based\n              /(opera\\smini)\\/([\\w\\.-]+)/i,                                       // Opera Mini\n              /(opera\\s[mobiletab]+).+version\\/([\\w\\.-]+)/i,                      // Opera Mobi/Tablet\n              /(opera).+version\\/([\\w\\.]+)/i,                                     // Opera > 9.80\n              /(opera)[\\/\\s]+([\\w\\.]+)/i                                          // Opera < 9.80\n              ], [NAME, VERSION], [\n\n              /(opios)[\\/\\s]+([\\w\\.]+)/i                                          // Opera mini on iphone >= 8.0\n              ], [[NAME, 'Opera Mini'], VERSION], [\n\n              /\\s(opr)\\/([\\w\\.]+)/i                                               // Opera Webkit\n              ], [[NAME, 'Opera'], VERSION], [\n\n              // Mixed\n              /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n              /(lunascape|maxthon|netfront|jasmine|blazer)[\\/\\s]?([\\w\\.]*)/i,\n                                                                                  // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n              // Trident based\n              /(avant\\s|iemobile|slim)(?:browser)?[\\/\\s]?([\\w\\.]*)/i,\n                                                                                  // Avant/IEMobile/SlimBrowser\n              /(bidubrowser|baidubrowser)[\\/\\s]?([\\w\\.]+)/i,                      // Baidu Browser\n              /(?:ms|\\()(ie)\\s([\\w\\.]+)/i,                                        // Internet Explorer\n\n              // Webkit/KHTML based\n              /(rekonq)\\/([\\w\\.]*)/i,                                             // Rekonq\n              /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\\/([\\w\\.-]+)/i\n                                                                                  // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n              ], [NAME, VERSION], [\n\n              /(konqueror)\\/([\\w\\.]+)/i                                           // Konqueror\n              ], [[NAME, 'Konqueror'], VERSION], [\n\n              /(trident).+rv[:\\s]([\\w\\.]+).+like\\sgecko/i                         // IE11\n              ], [[NAME, 'IE'], VERSION], [\n\n              /(edge|edgios|edga|edg)\\/((\\d+)?[\\w\\.]+)/i                          // Microsoft Edge\n              ], [[NAME, 'Edge'], VERSION], [\n\n              /(yabrowser)\\/([\\w\\.]+)/i                                           // Yandex\n              ], [[NAME, 'Yandex'], VERSION], [\n\n              /(Avast)\\/([\\w\\.]+)/i                                               // Avast Secure Browser\n              ], [[NAME, 'Avast Secure Browser'], VERSION], [\n\n              /(AVG)\\/([\\w\\.]+)/i                                                 // AVG Secure Browser\n              ], [[NAME, 'AVG Secure Browser'], VERSION], [\n\n              /(puffin)\\/([\\w\\.]+)/i                                              // Puffin\n              ], [[NAME, 'Puffin'], VERSION], [\n\n              /(focus)\\/([\\w\\.]+)/i                                               // Firefox Focus\n              ], [[NAME, 'Firefox Focus'], VERSION], [\n\n              /(opt)\\/([\\w\\.]+)/i                                                 // Opera Touch\n              ], [[NAME, 'Opera Touch'], VERSION], [\n\n              /((?:[\\s\\/])uc?\\s?browser|(?:juc.+)ucweb)[\\/\\s]?([\\w\\.]+)/i         // UCBrowser\n              ], [[NAME, 'UCBrowser'], VERSION], [\n\n              /(comodo_dragon)\\/([\\w\\.]+)/i                                       // Comodo Dragon\n              ], [[NAME, /_/g, ' '], VERSION], [\n\n              /(windowswechat qbcore)\\/([\\w\\.]+)/i                                // WeChat Desktop for Windows Built-in Browser\n              ], [[NAME, 'WeChat(Win) Desktop'], VERSION], [\n\n              /(micromessenger)\\/([\\w\\.]+)/i                                      // WeChat\n              ], [[NAME, 'WeChat'], VERSION], [\n\n              /(brave)\\/([\\w\\.]+)/i                                               // Brave browser\n              ], [[NAME, 'Brave'], VERSION], [\n\n              /(qqbrowserlite)\\/([\\w\\.]+)/i                                       // QQBrowserLite\n              ], [NAME, VERSION], [\n\n              /(QQ)\\/([\\d\\.]+)/i                                                  // QQ, aka ShouQ\n              ], [NAME, VERSION], [\n\n              /m?(qqbrowser)[\\/\\s]?([\\w\\.]+)/i                                    // QQBrowser\n              ], [NAME, VERSION], [\n\n              /(baiduboxapp)[\\/\\s]?([\\w\\.]+)/i                                    // Baidu App\n              ], [NAME, VERSION], [\n\n              /(2345Explorer)[\\/\\s]?([\\w\\.]+)/i                                   // 2345 Browser\n              ], [NAME, VERSION], [\n\n              /(MetaSr)[\\/\\s]?([\\w\\.]+)/i                                         // SouGouBrowser\n              ], [NAME], [\n\n              /(LBBROWSER)/i                                                      // LieBao Browser\n              ], [NAME], [\n\n              /xiaomi\\/miuibrowser\\/([\\w\\.]+)/i                                   // MIUI Browser\n              ], [VERSION, [NAME, 'MIUI Browser']], [\n\n              /;fbav\\/([\\w\\.]+);/i                                                // Facebook App for iOS & Android\n              ], [VERSION, [NAME, 'Facebook']], [\n\n              /safari\\s(line)\\/([\\w\\.]+)/i,                                       // Line App for iOS\n              /android.+(line)\\/([\\w\\.]+)\\/iab/i                                  // Line App for Android\n              ], [NAME, VERSION], [\n\n              /headlesschrome(?:\\/([\\w\\.]+)|\\s)/i                                 // Chrome Headless\n              ], [VERSION, [NAME, 'Chrome Headless']], [\n\n              /\\swv\\).+(chrome)\\/([\\w\\.]+)/i                                      // Chrome WebView\n              ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [\n\n              /((?:oculus|samsung)browser)\\/([\\w\\.]+)/i\n              ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser\n\n              /android.+version\\/([\\w\\.]+)\\s+(?:mobile\\s?safari|safari)*/i        // Android Browser\n              ], [VERSION, [NAME, 'Android Browser']], [\n\n              /(sailfishbrowser)\\/([\\w\\.]+)/i                                     // Sailfish Browser\n              ], [[NAME, 'Sailfish Browser'], VERSION], [\n\n              /(chrome|omniweb|arora|[tizenoka]{5}\\s?browser)\\/v?([\\w\\.]+)/i\n                                                                                  // Chrome/OmniWeb/Arora/Tizen/Nokia\n              ], [NAME, VERSION], [\n\n              /(dolfin)\\/([\\w\\.]+)/i                                              // Dolphin\n              ], [[NAME, 'Dolphin'], VERSION], [\n\n              /(qihu|qhbrowser|qihoobrowser|360browser)/i                         // 360\n              ], [[NAME, '360 Browser']], [\n\n              /((?:android.+)crmo|crios)\\/([\\w\\.]+)/i                             // Chrome for Android/iOS\n              ], [[NAME, 'Chrome Mobile'], VERSION], [\n\n              /(coast)\\/([\\w\\.]+)/i                                               // Opera Coast\n              ], [[NAME, 'Opera Coast'], VERSION], [\n\n              /fxios\\/([\\w\\.-]+)/i                                                // Firefox for iOS\n              ], [VERSION, [NAME, 'Firefox']], [\n\n              /version\\/([\\w\\.]+).+?mobile\\/\\w+\\s(safari)/i                       // Mobile Safari\n              ], [VERSION, [NAME, 'Mobile Safari']], [\n\n              /version\\/([\\w\\.]+).+?(mobile\\s?safari|safari)/i                    // Safari & Safari Mobile\n              ], [VERSION, NAME], [\n\n              /webkit.+?(gsa)\\/([\\w\\.]+).+?(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i  // Google Search Appliance on iOS\n              ], [[NAME, 'GSA'], VERSION], [\n\n              /webkit.+?(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i                     // Safari < 3.0\n              ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [\n\n              /(webkit|khtml)\\/([\\w\\.]+)/i\n              ], [NAME, VERSION], [\n\n              // Gecko based\n              /(navigator|netscape)\\/([\\w\\.-]+)/i                                 // Netscape\n              ], [[NAME, 'Netscape'], VERSION], [\n              /(swiftfox)/i,                                                      // Swiftfox\n              /(icedragon|iceweasel|camino|chimera|fennec|maemo\\sbrowser|minimo|conkeror)[\\/\\s]?([\\w\\.\\+]+)/i,\n                                                                                  // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror\n              /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([\\w\\.-]+)$/i,\n\n                                                                                  // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n              /(mozilla)\\/([\\w\\.]+).+rv\\:.+gecko\\/\\d+/i,                          // Mozilla\n\n              // Other\n              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\\/\\s]?([\\w\\.]+)/i,\n                                                                                  // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir\n              /(links)\\s\\(([\\w\\.]+)/i,                                            // Links\n              /(gobrowser)\\/?([\\w\\.]*)/i,                                         // GoBrowser\n              /(ice\\s?browser)\\/v?([\\w\\._]+)/i,                                   // ICE Browser\n              /(mosaic)[\\/\\s]([\\w\\.]+)/i                                          // Mosaic\n              ], [NAME, VERSION]\n          ],\n\n          cpu : [[\n\n              /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\\)]/i                     // AMD64\n              ], [[ARCHITECTURE, 'amd64']], [\n\n              /(ia32(?=;))/i                                                      // IA32 (quicktime)\n              ], [[ARCHITECTURE, util.lowerize]], [\n\n              /((?:i[346]|x)86)[;\\)]/i                                            // IA32\n              ], [[ARCHITECTURE, 'ia32']], [\n\n              // PocketPC mistakenly identified as PowerPC\n              /windows\\s(ce|mobile);\\sppc;/i\n              ], [[ARCHITECTURE, 'arm']], [\n\n              /((?:ppc|powerpc)(?:64)?)(?:\\smac|;|\\))/i                           // PowerPC\n              ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [\n\n              /(sun4\\w)[;\\)]/i                                                    // SPARC\n              ], [[ARCHITECTURE, 'sparc']], [\n\n              /((?:avr32|ia64(?=;))|68k(?=\\))|arm(?:64|(?=v\\d+[;l]))|(?=atmel\\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i\n                                                                                  // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n              ], [[ARCHITECTURE, util.lowerize]]\n          ],\n\n          device : [[\n\n              /\\((ipad|playbook);[\\w\\s\\),;-]+(rim|apple)/i                        // iPad/PlayBook\n              ], [MODEL, VENDOR, [TYPE, TABLET]], [\n\n              /applecoremedia\\/[\\w\\.]+ \\((ipad)/                                  // iPad\n              ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [\n\n              /(apple\\s{0,1}tv)/i                                                 // Apple TV\n              ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple'], [TYPE, SMARTTV]], [\n\n              /(archos)\\s(gamepad2?)/i,                                           // Archos\n              /(hp).+(touchpad)/i,                                                // HP TouchPad\n              /(hp).+(tablet)/i,                                                  // HP Tablet\n              /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n              /\\s(nook)[\\w\\s]+build\\/(\\w+)/i,                                     // Nook\n              /(dell)\\s(strea[kpr\\s\\d]*[\\dko])/i                                  // Dell Streak\n              ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n              /(kf[A-z]+)\\sbuild\\/.+silk\\//i                                      // Kindle Fire HD\n              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [\n              /(sd|kf)[0349hijorstuw]+\\sbuild\\/.+silk\\//i                         // Fire Phone\n              ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [\n              /android.+aft([bms])\\sbuild/i                                       // Fire TV\n              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [\n\n              /\\((ip[honed|\\s\\w*]+);.+(apple)/i                                   // iPod/iPhone\n              ], [MODEL, VENDOR, [TYPE, MOBILE]], [\n              /\\((ip[honed|\\s\\w*]+);/i                                            // iPod/iPhone\n              ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [\n\n              /(blackberry)[\\s-]?(\\w+)/i,                                         // BlackBerry\n              /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\\s_-]?([\\w-]*)/i,\n                                                                                  // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n              /(hp)\\s([\\w\\s]+\\w)/i,                                               // HP iPAQ\n              /(asus)-?(\\w+)/i                                                    // Asus\n              ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n              /\\(bb10;\\s(\\w+)/i                                                   // BlackBerry 10\n              ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [\n                                                                                  // Asus Tablets\n              /android.+(transfo[prime\\s]{4,10}\\s\\w+|eeepc|slider\\s\\w+|nexus 7|padfone|p00c)/i\n              ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [\n\n              /(sony)\\s(tablet\\s[ps])\\sbuild\\//i,                                  // Sony\n              /(sony)?(?:sgp.+)\\sbuild\\//i\n              ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [\n              /android.+\\s([c-g]\\d{4}|so[-l]\\w+)(?=\\sbuild\\/|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n              ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [\n\n              /\\s(ouya)\\s/i,                                                      // Ouya\n              /(nintendo)\\s([wids3u]+)/i                                          // Nintendo\n              ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n\n              /android.+;\\s(shield)\\sbuild/i                                      // Nvidia\n              ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [\n\n              /(playstation\\s[34portablevi]+)/i                                   // Playstation\n              ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [\n\n              /(sprint\\s(\\w+))/i                                                  // Sprint Phones\n              ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [\n\n              /(htc)[;_\\s-]+([\\w\\s]+(?=\\)|\\sbuild)|\\w+)/i,                        // HTC\n              /(zte)-(\\w*)/i,                                                     // ZTE\n              /(alcatel|geeksphone|nexian|panasonic|(?=;\\s)sony)[_\\s-]?([\\w-]*)/i\n                                                                                  // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n              ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [\n\n              /(nexus\\s9)/i                                                       // HTC Nexus 9\n              ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [\n\n              /d\\/huawei([\\w\\s-]+)[;\\)]/i,\n              /(nexus\\s6p|vog-l29|ane-lx1|eml-l29)/i                              // Huawei\n              ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [\n\n              /android.+(bah2?-a?[lw]\\d{2})/i                                     // Huawei MediaPad\n              ], [MODEL, [VENDOR, 'Huawei'], [TYPE, TABLET]], [\n\n              /(microsoft);\\s(lumia[\\s\\w]+)/i                                     // Microsoft Lumia\n              ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n              /[\\s\\(;](xbox(?:\\sone)?)[\\s\\);]/i                                   // Microsoft Xbox\n              ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [\n              /(kin\\.[onetw]{3})/i                                                // Microsoft Kin\n              ], [[MODEL, /\\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [\n\n                                                                                  // Motorola\n              /\\s(milestone|droid(?:[2-4x]|\\s(?:bionic|x2|pro|razr))?:?(\\s4g)?)[\\w\\s]+build\\//i,\n              /mot[\\s-]?(\\w*)/i,\n              /(XT\\d{3,4}) build\\//i,\n              /(nexus\\s6)/i\n              ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [\n              /android.+\\s(mz60\\d|xoom[\\s2]{0,2})\\sbuild\\//i\n              ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [\n\n              /hbbtv\\/\\d+\\.\\d+\\.\\d+\\s+\\([\\w\\s]*;\\s*(\\w[^;]*);([^;]*)/i            // HbbTV devices\n              ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [\n\n              /hbbtv.+maple;(\\d+)/i\n              ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [\n\n              /\\(dtv[\\);].+(aquos)/i                                              // Sharp\n              ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [\n\n              /android.+((sch-i[89]0\\d|shw-m380s|gt-p\\d{4}|gt-n\\d+|sgh-t8[56]9|nexus 10))/i,\n              /((SM-T\\w+))/i\n              ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung\n              /smart-tv.+(samsung)/i\n              ], [VENDOR, [TYPE, SMARTTV], MODEL], [\n              /((s[cgp]h-\\w+|gt-\\w+|galaxy\\snexus|sm-\\w[\\w\\d]+))/i,\n              /(sam[sung]*)[\\s-]*(\\w+-?[\\w-]*)/i,\n              /sec-((sgh\\w+))/i\n              ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [\n\n              /sie-(\\w*)/i                                                        // Siemens\n              ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [\n\n              /(maemo|nokia).*(n900|lumia\\s\\d+)/i,                                // Nokia\n              /(nokia)[\\s_-]?([\\w-]*)/i\n              ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [\n\n              /android[x\\d\\.\\s;]+\\s([ab][1-7]\\-?[0178a]\\d\\d?)/i                   // Acer\n              ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [\n\n              /android.+([vl]k\\-?\\d{3})\\s+build/i                                 // LG Tablet\n              ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [\n              /android\\s3\\.[\\s\\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet\n              ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [\n              /(lg) netcast\\.tv/i                                                 // LG SmartTV\n              ], [VENDOR, MODEL, [TYPE, SMARTTV]], [\n              /(nexus\\s[45])/i,                                                   // LG\n              /lg[e;\\s\\/-]+(\\w*)/i,\n              /android.+lg(\\-?[\\d\\w]+)\\s+build/i\n              ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [\n\n              /(lenovo)\\s?(s(?:5000|6000)(?:[\\w-]+)|tab(?:[\\s\\w]+))/i             // Lenovo tablets\n              ], [VENDOR, MODEL, [TYPE, TABLET]], [\n              /android.+(ideatab[a-z0-9\\-\\s]+)/i                                  // Lenovo\n              ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [\n              /(lenovo)[_\\s-]?([\\w-]+)/i\n              ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n              /linux;.+((jolla));/i                                               // Jolla\n              ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n              /((pebble))app\\/[\\d\\.]+\\s/i                                         // Pebble\n              ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n\n              /android.+;\\s(oppo)\\s?([\\w\\s]+)\\sbuild/i                            // OPPO\n              ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n              /crkey/i                                                            // Google Chromecast\n              ], [[MODEL, 'Chromecast'], [VENDOR, 'Google'], [TYPE, SMARTTV]], [\n\n              /android.+;\\s(glass)\\s\\d/i                                          // Google Glass\n              ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [\n\n              /android.+;\\s(pixel c)[\\s)]/i                                       // Google Pixel C\n              ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [\n\n              /android.+;\\s(pixel( [23])?( xl)?)[\\s)]/i                              // Google Pixel\n              ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [\n\n              /android.+;\\s(\\w+)\\s+build\\/hm\\1/i,                                 // Xiaomi Hongmi 'numeric' models\n              /android.+(hm[\\s\\-_]*note?[\\s_]*(?:\\d\\w)?)\\s+build/i,               // Xiaomi Hongmi\n              /android.+(mi[\\s\\-_]*(?:a\\d|one|one[\\s_]plus|note lte)?[\\s_]*(?:\\d?\\w?)[\\s_]*(?:plus)?)\\s+build/i,    \n                                                                                  // Xiaomi Mi\n              /android.+(redmi[\\s\\-_]*(?:note)?(?:[\\s_]*[\\w\\s]+))\\s+build/i       // Redmi Phones\n              ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [\n              /android.+(mi[\\s\\-_]*(?:pad)(?:[\\s_]*[\\w\\s]+))\\s+build/i            // Mi Pad tablets\n              ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [\n              /android.+;\\s(m[1-5]\\snote)\\sbuild/i                                // Meizu\n              ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [\n              /(mz)-([\\w-]{2,})/i\n              ], [[VENDOR, 'Meizu'], MODEL, [TYPE, MOBILE]], [\n\n              /android.+a000(1)\\s+build/i,                                        // OnePlus\n              /android.+oneplus\\s(a\\d{4})[\\s)]/i\n              ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [\n\n              /android.+[;\\/]\\s*(RCT[\\d\\w]+)\\s+build/i                            // RCA Tablets\n              ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [\n\n              /android.+[;\\/\\s]+(Venue[\\d\\s]{2,7})\\s+build/i                      // Dell Venue Tablets\n              ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(Q[T|M][\\d\\w]+)\\s+build/i                         // Verizon Tablet\n              ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s+(Barnes[&\\s]+Noble\\s+|BN[RT])(V?.*)\\s+build/i     // Barnes & Noble Tablet\n              ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s+(TM\\d{3}.*\\b)\\s+build/i                           // Barnes & Noble Tablet\n              ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [\n\n              /android.+;\\s(k88)\\sbuild/i                                         // ZTE K Series Tablet\n              ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(gen\\d{3})\\s+build.*49h/i                         // Swiss GEN Mobile\n              ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [\n\n              /android.+[;\\/]\\s*(zur\\d{3})\\s+build/i                              // Swiss ZUR Tablet\n              ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*((Zeki)?TB.*\\b)\\s+build/i                         // Zeki Tablets\n              ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [\n\n              /(android).+[;\\/]\\s+([YR]\\d{2})\\s+build/i,\n              /android.+[;\\/]\\s+(Dragon[\\-\\s]+Touch\\s+|DT)(\\w{5})\\sbuild/i        // Dragon Touch Tablet\n              ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(NS-?\\w{0,9})\\sbuild/i                            // Insignia Tablets\n              ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*((NX|Next)-?\\w{0,9})\\s+build/i                    // NextBook Tablets\n              ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(Xtreme\\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\\s+build/i\n              ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones\n\n              /android.+[;\\/]\\s*(LVTEL\\-)?(V1[12])\\s+build/i                     // LvTel Phones\n              ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [\n\n              /android.+;\\s(PH-1)\\s/i\n              ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1\n\n              /android.+[;\\/]\\s*(V(100MD|700NA|7011|917G).*\\b)\\s+build/i          // Envizen Tablets\n              ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(Le[\\s\\-]+Pan)[\\s\\-]+(\\w{1,9})\\s+build/i          // Le Pan Tablets\n              ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(Trio[\\s\\-]*.*)\\s+build/i                         // MachSpeed Tablets\n              ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*(Trinity)[\\-\\s]*(T\\d{3})\\s+build/i                // Trinity Tablets\n              ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n              /android.+[;\\/]\\s*TU_(1491)\\s+build/i                               // Rotor Tablets\n              ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [\n\n              /android.+(KS(.+))\\s+build/i                                        // Amazon Kindle Tablets\n              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [\n\n              /android.+(Gigaset)[\\s\\-]+(Q\\w{1,9})\\s+build/i                      // Gigaset Tablets\n              ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n              /\\s(tablet|tab)[;\\/]/i,                                             // Unidentifiable Tablet\n              /\\s(mobile)(?:[;\\/]|\\ssafari)/i                                     // Unidentifiable Mobile\n              ], [[TYPE, util.lowerize], VENDOR, MODEL], [\n\n              /[\\s\\/\\(](smart-?tv)[;\\)]/i                                         // SmartTV\n              ], [[TYPE, SMARTTV]], [\n\n              /(android[\\w\\.\\s\\-]{0,9});.+build/i                                 // Generic Android Device\n              ], [MODEL, [VENDOR, 'Generic']]\n          ],\n\n          engine : [[\n\n              /windows.+\\sedge\\/([\\w\\.]+)/i                                       // EdgeHTML\n              ], [VERSION, [NAME, 'EdgeHTML']], [\n\n              /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i                         // Blink\n              ], [VERSION, [NAME, 'Blink']], [\n\n              /(presto)\\/([\\w\\.]+)/i,                                             // Presto\n              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,     \n                                                                                  // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n              /(khtml|tasman|links)[\\/\\s]\\(?([\\w\\.]+)/i,                          // KHTML/Tasman/Links\n              /(icab)[\\/\\s]([23]\\.[\\d\\.]+)/i                                      // iCab\n              ], [NAME, VERSION], [\n\n              /rv\\:([\\w\\.]{1,9}).+(gecko)/i                                       // Gecko\n              ], [VERSION, NAME]\n          ],\n\n          os : [[\n\n              // Windows based\n              /microsoft\\s(windows)\\s(vista|xp)/i                                 // Windows (iTunes)\n              ], [NAME, VERSION], [\n              /(windows)\\snt\\s6\\.2;\\s(arm)/i,                                     // Windows RT\n              /(windows\\sphone(?:\\sos)*)[\\s\\/]?([\\d\\.\\s\\w]*)/i,                   // Windows Phone\n              /(windows\\smobile|windows)[\\s\\/]?([ntce\\d\\.\\s]+\\w)/i\n              ], [[NAME, mapper.str, maps.os.windows.name], [VERSION, mapper.str, maps.os.windows.version]], [\n              /(win(?=3|9|n)|win\\s9x\\s)([nt\\d\\.]+)/i\n              ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [\n\n              // Mobile/Embedded OS\n              /\\((bb)(10);/i                                                      // BlackBerry 10\n              ], [[NAME, 'BlackBerry'], VERSION], [\n              /(blackberry)\\w*\\/?([\\w\\.]*)/i,                                     // Blackberry\n              /(tizen|kaios)[\\/\\s]([\\w\\.]+)/i,                                    // Tizen/KaiOS\n              /(android|webos|palm\\sos|qnx|bada|rim\\stablet\\sos|meego|sailfish|contiki)[\\/\\s-]?([\\w\\.]*)/i\n                                                                                  // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki/Sailfish OS\n              ], [NAME, VERSION], [\n              /(symbian\\s?os|symbos|s60(?=;))[\\/\\s-]?([\\w\\.]*)/i                  // Symbian\n              ], [[NAME, 'Symbian'], VERSION], [\n              /\\((series40);/i                                                    // Series 40\n              ], [NAME], [\n              /mozilla.+\\(mobile;.+gecko.+firefox/i                               // Firefox OS\n              ], [[NAME, 'Firefox OS'], VERSION], [\n\n              // Console\n              /(nintendo|playstation)\\s([wids34portablevu]+)/i,                   // Nintendo/Playstation\n\n              // GNU/Linux based\n              /(mint)[\\/\\s\\(]?(\\w*)/i,                                            // Mint\n              /(mageia|vectorlinux)[;\\s]/i,                                       // Mageia/VectorLinux\n              /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\\/\\s-]?(?!chrom)([\\w\\.-]*)/i,\n                                                                                  // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware\n                                                                                  // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus\n              /(hurd|linux)\\s?([\\w\\.]*)/i,                                        // Hurd/Linux\n              /(gnu)\\s?([\\w\\.]*)/i                                                // GNU\n              ], [[NAME, 'Linux'], VERSION], [\n\n              /(cros)\\s[\\w]+\\s([\\w\\.]+\\w)/i                                       // Chromium OS\n              ], [[NAME, 'Chromium OS'], VERSION],[\n\n              // Solaris\n              /(sunos)\\s?([\\w\\.\\d]*)/i                                            // Solaris\n              ], [[NAME, 'Solaris'], VERSION], [\n\n              // BSD based\n              /\\s([frentopc-]{0,4}bsd|dragonfly)\\s?([\\w\\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly\n              ], [[NAME, 'Linux'], VERSION],[\n\n              /(iphone)(?:.*os\\s*([\\w]*)\\slike\\smac|;\\sopera)/i                  // iOS\n              ], [[NAME, 'iPhone'], [VERSION, /_/g, '.']], [\n\n              /(ipad)(?:.*os\\s*([\\w]*)\\slike\\smac|;\\sopera)/i                    // iOS\n              ], [[NAME, 'iPad'], [VERSION, /_/g, '.']], [\n\n              /(haiku)\\s(\\w+)/i                                                   // Haiku\n              ], [NAME, VERSION],[\n\n              /cfnetwork\\/.+darwin/i,\n              /ip[honead]{2,4}(?:.*os\\s([\\w]+)\\slike\\smac|;\\sopera)/i             // iOS\n              ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [\n\n              /(mac\\sos\\sx)\\s?([\\w\\s\\.]*)/i,\n              /(macintosh|mac(?=_powerpc)\\s)/i                                    // Mac OS\n              ], [[NAME, 'Mac'], [VERSION, /_/g, '.']], [\n\n              // Other\n              /((?:open)?solaris)[\\/\\s-]?([\\w\\.]*)/i,                             // Solaris\n              /(aix)\\s((\\d)(?=\\.|\\)|\\s)[\\w\\.])*/i,                                // AIX\n              /(plan\\s9|minix|beos|os\\/2|amigaos|morphos|risc\\sos|openvms|fuchsia)/i,\n                                                                                  // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia\n              /(unix)\\s?([\\w\\.]*)/i                                               // UNIX\n              ], [NAME, VERSION]\n          ]\n      };\n\n\n      /////////////////\n      // Constructor\n      ////////////////\n      var UAParser = function (uastring, extensions) {\n\n          if (typeof uastring === 'object') {\n              extensions = uastring;\n              uastring = undefined$1;\n          }\n\n          if (!(this instanceof UAParser)) {\n              return new UAParser(uastring, extensions).getResult();\n          }\n\n          var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);\n          var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;\n\n          this.getBrowser = function () {\n              var browser = { name: undefined$1, version: undefined$1 };\n              mapper.rgx.call(browser, ua, rgxmap.browser);\n              browser.major = util.major(browser.version); // deprecated\n              return browser;\n          };\n          this.getCPU = function () {\n              var cpu = { architecture: undefined$1 };\n              mapper.rgx.call(cpu, ua, rgxmap.cpu);\n              return cpu;\n          };\n          this.getDevice = function () {\n              var device = { vendor: undefined$1, model: undefined$1, type: undefined$1 };\n              mapper.rgx.call(device, ua, rgxmap.device);\n              return device;\n          };\n          this.getEngine = function () {\n              var engine = { name: undefined$1, version: undefined$1 };\n              mapper.rgx.call(engine, ua, rgxmap.engine);\n              return engine;\n          };\n          this.getOS = function () {\n              var os = { name: undefined$1, version: undefined$1 };\n              mapper.rgx.call(os, ua, rgxmap.os);\n              return os;\n          };\n          this.getResult = function () {\n              return {\n                  ua      : this.getUA(),\n                  browser : this.getBrowser(),\n                  engine  : this.getEngine(),\n                  os      : this.getOS(),\n                  device  : this.getDevice(),\n                  cpu     : this.getCPU()\n              };\n          };\n          this.getUA = function () {\n              return ua;\n          };\n          this.setUA = function (uastring) {\n              ua = uastring;\n              return this;\n          };\n          return this;\n      };\n\n      UAParser.VERSION = LIBVERSION;\n      UAParser.BROWSER = {\n          NAME    : NAME,\n          MAJOR   : MAJOR, // deprecated\n          VERSION : VERSION\n      };\n      UAParser.CPU = {\n          ARCHITECTURE : ARCHITECTURE\n      };\n      UAParser.DEVICE = {\n          MODEL   : MODEL,\n          VENDOR  : VENDOR,\n          TYPE    : TYPE,\n          CONSOLE : CONSOLE,\n          MOBILE  : MOBILE,\n          SMARTTV : SMARTTV,\n          TABLET  : TABLET,\n          WEARABLE: WEARABLE,\n          EMBEDDED: EMBEDDED\n      };\n      UAParser.ENGINE = {\n          NAME    : NAME,\n          VERSION : VERSION\n      };\n      UAParser.OS = {\n          NAME    : NAME,\n          VERSION : VERSION\n      };\n\n      ///////////\n      // Export\n      //////////\n\n\n      // check js environment\n      {\n          // nodejs env\n          if (module.exports) {\n              exports = module.exports = UAParser;\n          }\n          exports.UAParser = UAParser;\n      }\n\n      // jQuery/Zepto specific (optional)\n      // Note:\n      //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n      //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n      //   and we should catch that.\n      var $ = window && (window.jQuery || window.Zepto);\n      if ($ && !$.ua) {\n          var parser = new UAParser();\n          $.ua = parser.getResult();\n          $.ua.get = function () {\n              return parser.getUA();\n          };\n          $.ua.set = function (uastring) {\n              parser.setUA(uastring);\n              var result = parser.getResult();\n              for (var prop in result) {\n                  $.ua[prop] = result[prop];\n              }\n          };\n      }\n\n  })(typeof window === 'object' ? window : commonjsGlobal);\n  });\n  var uaParser_1 = uaParser.UAParser;\n\n  /* jshint bitwise: false, laxbreak: true */\n\n  /**\n   * Source: [jed's gist]{@link https://gist.github.com/982883}.\n   * Returns a random v4 UUID of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx,\n   * where each x is replaced with a random hexadecimal digit from 0 to f, and\n   * y is replaced with a random hexadecimal digit from 8 to b.\n   * Used to generate UUIDs for deviceIds.\n   * @private\n   */\n  var uuid = function uuid(a) {\n    return a // if the placeholder was passed, return\n    ? ( // a random number from 0 to 15\n    a ^ // unless b is 8,\n    Math.random() // in which case\n    * 16 // a random number from\n    >> a / 4 // 8 to 11\n    ).toString(16) // in hexadecimal\n    : ( // or otherwise a concatenated string:\n    [1e7] + // 10000000 +\n    -1e3 + // -1000 +\n    -4e3 + // -4000 +\n    -8e3 + // -80000000 +\n    -1e11 // -100000000000,\n    ).replace( // replacing\n    /[018]/g, // zeroes, ones, and eights with\n    uuid // random hex digits\n    );\n  };\n\n  // A URL safe variation on the the list of Base64 characters \n  var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n  var base64Id = function base64Id() {\n    var str = '';\n\n    for (var i = 0; i < 22; ++i) {\n      str += base64Chars.charAt(Math.floor(Math.random() * 64));\n    }\n\n    return str;\n  };\n\n  var version = \"7.0.0\";\n\n  var getLanguage = function getLanguage() {\n    return navigator && (navigator.languages && navigator.languages[0] || navigator.language || navigator.userLanguage) || '';\n  };\n\n  var language = {\n    getLanguage: getLanguage\n  };\n\n  var platform = 'Web';\n\n  var DEFAULT_OPTIONS = {\n    apiEndpoint: 'api.amplitude.com',\n    batchEvents: false,\n    cookieExpiration: 365 * 10,\n    cookieName: 'amplitude_id',\n    // this is a deprecated option\n    sameSiteCookie: 'None',\n    cookieForceUpgrade: false,\n    deferInitialization: false,\n    disableCookies: false,\n    deviceIdFromUrlParam: false,\n    domain: '',\n    eventUploadPeriodMillis: 30 * 1000,\n    // 30s\n    eventUploadThreshold: 30,\n    forceHttps: true,\n    includeGclid: false,\n    includeReferrer: false,\n    includeUtm: false,\n    language: language.getLanguage(),\n    logLevel: 'WARN',\n    optOut: false,\n    onError: function onError() {},\n    platform: platform,\n    savedMaxCount: 1000,\n    saveEvents: true,\n    saveParamsReferrerOncePerSession: true,\n    secureCookie: false,\n    sessionTimeout: 30 * 60 * 1000,\n    trackingOptions: {\n      city: true,\n      country: true,\n      carrier: true,\n      device_manufacturer: true,\n      device_model: true,\n      dma: true,\n      ip_address: true,\n      language: true,\n      os_name: true,\n      os_version: true,\n      platform: true,\n      region: true,\n      version_name: true\n    },\n    unsetParamsReferrerOnNewSession: false,\n    unsentKey: 'amplitude_unsent',\n    unsentIdentifyKey: 'amplitude_unsent_identify',\n    uploadBatchSize: 100\n  };\n\n  var AsyncStorage;\n  var DeviceInfo;\n  /**\n   * AmplitudeClient SDK API - instance constructor.\n   * The Amplitude class handles creation of client instances, all you need to do is call amplitude.getInstance()\n   * @constructor AmplitudeClient\n   * @public\n   * @example var amplitudeClient = new AmplitudeClient();\n   */\n\n\n  var AmplitudeClient = function AmplitudeClient(instanceName) {\n    this._instanceName = utils.isEmptyString(instanceName) ? Constants.DEFAULT_INSTANCE : instanceName.toLowerCase();\n    this._unsentEvents = [];\n    this._unsentIdentifys = [];\n    this._ua = new uaParser(navigator.userAgent).getResult();\n    this.options = _objectSpread({}, DEFAULT_OPTIONS, {\n      trackingOptions: _objectSpread({}, DEFAULT_OPTIONS.trackingOptions)\n    });\n    this.cookieStorage = new cookieStorage().getStorage();\n    this._q = []; // queue for proxied functions before script load\n\n    this._sending = false;\n    this._updateScheduled = false;\n    this._onInit = []; // event meta data\n\n    this._eventId = 0;\n    this._identifyId = 0;\n    this._lastEventTime = null;\n    this._newSession = false;\n    this._sequenceNumber = 0;\n    this._sessionId = null;\n    this._isInitialized = false;\n    this._userAgent = navigator && navigator.userAgent || null;\n  };\n\n  AmplitudeClient.prototype.Identify = Identify;\n  AmplitudeClient.prototype.Revenue = Revenue;\n  /**\n   * Initializes the Amplitude Javascript SDK with your apiKey and any optional configurations.\n   * This is required before any other methods can be called.\n   * @public\n   * @param {string} apiKey - The API key for your app.\n   * @param {string} opt_userId - (optional) An identifier for this user.\n   * @param {object} opt_config - (optional) Configuration options.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#configuration-options} for list of options and default values.\n   * @param {function} opt_callback - (optional) Provide a callback function to run after initialization is complete.\n   * @example amplitudeClient.init('API_KEY', 'USER_ID', {includeReferrer: true, includeUtm: true}, function() { alert('init complete'); });\n   */\n\n  AmplitudeClient.prototype.init = function init(apiKey, opt_userId, opt_config, opt_callback) {\n    var _this = this;\n\n    if (type(apiKey) !== 'string' || utils.isEmptyString(apiKey)) {\n      utils.log.error('Invalid apiKey. Please re-initialize with a valid apiKey');\n      return;\n    }\n\n    try {\n      _parseConfig(this.options, opt_config);\n\n      if (this.options.cookieName !== DEFAULT_OPTIONS.cookieName) {\n        utils.log.warn('The cookieName option is deprecated. We will be ignoring it for newer cookies');\n      }\n\n      this.options.apiKey = apiKey;\n      this._storageSuffix = '_' + apiKey + (this._instanceName === Constants.DEFAULT_INSTANCE ? '' : '_' + this._instanceName);\n      this._storageSuffixV5 = apiKey.slice(0, 6);\n      this._oldCookiename = this.options.cookieName + this._storageSuffix;\n      this._unsentKey = this.options.unsentKey + this._storageSuffix;\n      this._unsentIdentifyKey = this.options.unsentIdentifyKey + this._storageSuffix;\n      this._cookieName = Constants.COOKIE_PREFIX + '_' + this._storageSuffixV5;\n      this.cookieStorage.options({\n        expirationDays: this.options.cookieExpiration,\n        domain: this.options.domain,\n        secure: this.options.secureCookie,\n        sameSite: this.options.sameSiteCookie\n      });\n      this._metadataStorage = new MetadataStorage({\n        storageKey: this._cookieName,\n        disableCookies: this.options.disableCookies,\n        expirationDays: this.options.cookieExpiration,\n        domain: this.options.domain,\n        secure: this.options.secureCookie,\n        sameSite: this.options.sameSiteCookie\n      });\n      var hasOldCookie = !!this.cookieStorage.get(this._oldCookiename);\n      var hasNewCookie = !!this._metadataStorage.load();\n      this._useOldCookie = !hasNewCookie && hasOldCookie && !this.options.cookieForceUpgrade;\n      var hasCookie = hasNewCookie || hasOldCookie;\n      this.options.domain = this.cookieStorage.options().domain;\n\n      if (this.options.deferInitialization && !hasCookie) {\n        this._deferInitialization(apiKey, opt_userId, opt_config, opt_callback);\n\n        return;\n      }\n\n      if (type(this.options.logLevel) === 'string') {\n        utils.setLogLevel(this.options.logLevel);\n      }\n\n      var trackingOptions = _generateApiPropertiesTrackingConfig(this);\n\n      this._apiPropertiesTrackingOptions = Object.keys(trackingOptions).length > 0 ? {\n        tracking_options: trackingOptions\n      } : {};\n\n      if (this.options.cookieForceUpgrade && hasOldCookie) {\n        if (!hasNewCookie) {\n          _upgradeCookieData(this);\n        }\n\n        this.cookieStorage.remove(this._oldCookiename);\n      }\n\n      _loadCookieData(this);\n\n      this._pendingReadStorage = true;\n\n      var initFromStorage = function initFromStorage(deviceId) {\n        // load deviceId and userId from input, or try to fetch existing value from cookie\n        _this.options.deviceId = type(opt_config) === 'object' && type(opt_config.deviceId) === 'string' && !utils.isEmptyString(opt_config.deviceId) && opt_config.deviceId || _this.options.deviceIdFromUrlParam && _this._getDeviceIdFromUrlParam(_this._getUrlParams()) || _this.options.deviceId || deviceId || base64Id();\n        _this.options.userId = type(opt_userId) === 'string' && !utils.isEmptyString(opt_userId) && opt_userId || type(opt_userId) === 'number' && opt_userId.toString() || _this.options.userId || null;\n        var now = new Date().getTime();\n\n        if (!_this._sessionId || !_this._lastEventTime || now - _this._lastEventTime > _this.options.sessionTimeout) {\n          if (_this.options.unsetParamsReferrerOnNewSession) {\n            _this._unsetUTMParams();\n          }\n\n          _this._newSession = true;\n          _this._sessionId = now; // only capture UTM params and referrer if new session\n\n          if (_this.options.saveParamsReferrerOncePerSession) {\n            _this._trackParamsAndReferrer();\n          }\n        }\n\n        if (!_this.options.saveParamsReferrerOncePerSession) {\n          _this._trackParamsAndReferrer();\n        } // load unsent events and identifies before any attempt to log new ones\n\n\n        if (_this.options.saveEvents) {\n          _validateUnsentEventQueue(_this._unsentEvents);\n\n          _validateUnsentEventQueue(_this._unsentIdentifys);\n        }\n\n        _this._lastEventTime = now;\n\n        _saveCookieData(_this);\n\n        _this._pendingReadStorage = false;\n\n        _this._sendEventsIfReady(); // try sending unsent events\n\n\n        for (var i = 0; i < _this._onInit.length; i++) {\n          _this._onInit[i](_this);\n        }\n\n        _this._onInit = [];\n        _this._isInitialized = true;\n      };\n\n      if (AsyncStorage) {\n        this._migrateUnsentEvents(function () {\n          Promise.all([AsyncStorage.getItem(_this._storageSuffix), AsyncStorage.getItem(_this.options.unsentKey + _this._storageSuffix), AsyncStorage.getItem(_this.options.unsentIdentifyKey + _this._storageSuffix)]).then(function (values) {\n            if (values[0]) {\n              var cookieData = JSON.parse(values[0]);\n\n              if (cookieData) {\n                _loadCookieDataProps(_this, cookieData);\n              }\n            }\n\n            if (_this.options.saveEvents) {\n              _this._unsentEvents = _this._parseSavedUnsentEventsString(values[1]).map(function (event) {\n                return {\n                  event: event\n                };\n              }).concat(_this._unsentEvents);\n              _this._unsentIdentifys = _this._parseSavedUnsentEventsString(values[2]).map(function (event) {\n                return {\n                  event: event\n                };\n              }).concat(_this._unsentIdentifys);\n            }\n\n            if (DeviceInfo) {\n              Promise.all([DeviceInfo.getCarrier(), DeviceInfo.getModel(), DeviceInfo.getManufacturer(), DeviceInfo.getVersion(), DeviceInfo.getUniqueId()]).then(function (values) {\n                _this.deviceInfo = {\n                  carrier: values[0],\n                  model: values[1],\n                  manufacturer: values[2],\n                  version: values[3]\n                };\n                initFromStorage(values[4]);\n\n                _this.runQueuedFunctions();\n\n                if (type(opt_callback) === 'function') {\n                  opt_callback(_this);\n                }\n              }).catch(function (err) {\n                _this.options.onError(err);\n              });\n            } else {\n              initFromStorage();\n\n              _this.runQueuedFunctions();\n            }\n          }).catch(function (err) {\n            _this.options.onError(err);\n          });\n        });\n      } else {\n        if (this.options.saveEvents) {\n          this._unsentEvents = this._loadSavedUnsentEvents(this.options.unsentKey).map(function (event) {\n            return {\n              event: event\n            };\n          }).concat(this._unsentEvents);\n          this._unsentIdentifys = this._loadSavedUnsentEvents(this.options.unsentIdentifyKey).map(function (event) {\n            return {\n              event: event\n            };\n          }).concat(this._unsentIdentifys);\n        }\n\n        initFromStorage();\n        this.runQueuedFunctions();\n\n        if (type(opt_callback) === 'function') {\n          opt_callback(this);\n        }\n      }\n    } catch (err) {\n      utils.log.error(err);\n      this.options.onError(err);\n    }\n  }; // validate properties for unsent events\n\n\n  var _validateUnsentEventQueue = function _validateUnsentEventQueue(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      var userProperties = queue[i].event.user_properties;\n      var eventProperties = queue[i].event.event_properties;\n      var groups = queue[i].event.groups;\n      queue[i].event.user_properties = utils.validateProperties(userProperties);\n      queue[i].event.event_properties = utils.validateProperties(eventProperties);\n      queue[i].event.groups = utils.validateGroups(groups);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._migrateUnsentEvents = function _migrateUnsentEvents(cb) {\n    var _this2 = this;\n\n    Promise.all([AsyncStorage.getItem(this.options.unsentKey), AsyncStorage.getItem(this.options.unsentIdentifyKey)]).then(function (values) {\n      if (_this2.options.saveEvents) {\n        var unsentEventsString = values[0];\n        var unsentIdentifyKey = values[1];\n        var itemsToSet = [];\n        var itemsToRemove = [];\n\n        if (!!unsentEventsString) {\n          itemsToSet.push(AsyncStorage.setItem(_this2.options.unsentKey + _this2._storageSuffix, JSON.stringify(unsentEventsString)));\n          itemsToRemove.push(AsyncStorage.removeItem(_this2.options.unsentKey));\n        }\n\n        if (!!unsentIdentifyKey) {\n          itemsToSet.push(AsyncStorage.setItem(_this2.options.unsentIdentifyKey + _this2._storageSuffix, JSON.stringify(unsentIdentifyKey)));\n          itemsToRemove.push(AsyncStorage.removeItem(_this2.options.unsentIdentifyKey));\n        }\n\n        if (itemsToSet.length > 0) {\n          Promise.all(itemsToSet).then(function () {\n          }).catch(function (err) {\n            _this2.options.onError(err);\n          });\n        }\n      }\n    }).then(cb).catch(function (err) {\n      _this2.options.onError(err);\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._trackParamsAndReferrer = function _trackParamsAndReferrer() {\n    if (this.options.includeUtm) {\n      this._initUtmData();\n    }\n\n    if (this.options.includeReferrer) {\n      this._saveReferrer(this._getReferrer());\n    }\n\n    if (this.options.includeGclid) {\n      this._saveGclid(this._getUrlParams());\n    }\n  };\n  /**\n   * Parse and validate user specified config values and overwrite existing option value\n   * DEFAULT_OPTIONS provides list of all config keys that are modifiable, as well as expected types for values\n   * @private\n   */\n\n\n  var _parseConfig = function _parseConfig(options, config) {\n    if (type(config) !== 'object') {\n      return;\n    } // validates config value is defined, is the correct type, and some additional value sanity checks\n\n\n    var parseValidateAndLoad = function parseValidateAndLoad(key) {\n      if (!options.hasOwnProperty(key)) {\n        return; // skip bogus config values\n      }\n\n      var inputValue = config[key];\n      var expectedType = type(options[key]);\n\n      if (!utils.validateInput(inputValue, key + ' option', expectedType)) {\n        return;\n      }\n\n      if (expectedType === 'boolean') {\n        options[key] = !!inputValue;\n      } else if (expectedType === 'string' && !utils.isEmptyString(inputValue) || expectedType === 'number' && inputValue > 0) {\n        options[key] = inputValue;\n      } else if (expectedType === 'object') {\n        _parseConfig(options[key], inputValue);\n      }\n    };\n\n    for (var key in config) {\n      if (config.hasOwnProperty(key)) {\n        parseValidateAndLoad(key);\n      }\n    }\n  };\n  /**\n   * Run functions queued up by proxy loading snippet\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.runQueuedFunctions = function () {\n    var queue = this._q;\n    this._q = [];\n\n    for (var i = 0; i < queue.length; i++) {\n      var fn = this[queue[i][0]];\n\n      if (type(fn) === 'function') {\n        fn.apply(this, queue[i].slice(1));\n      }\n    }\n  };\n  /**\n   * Check that the apiKey is set before calling a function. Logs a warning message if not set.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._apiKeySet = function _apiKeySet(methodName) {\n    if (utils.isEmptyString(this.options.apiKey)) {\n      utils.log.error('Invalid apiKey. Please set a valid apiKey with init() before calling ' + methodName);\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Load saved events from localStorage. JSON deserializes event array. Handles case where string is corrupted.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._loadSavedUnsentEvents = function _loadSavedUnsentEvents(unsentKey) {\n    var savedUnsentEventsString = this._getFromStorage(localStorage$1, unsentKey);\n\n    var unsentEvents = this._parseSavedUnsentEventsString(savedUnsentEventsString, unsentKey);\n\n    this._setInStorage(localStorage$1, unsentKey, JSON.stringify(unsentEvents));\n\n    return unsentEvents;\n  };\n  /**\n   * Load saved events from localStorage. JSON deserializes event array. Handles case where string is corrupted.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._parseSavedUnsentEventsString = function _parseSavedUnsentEventsString(savedUnsentEventsString, unsentKey) {\n    if (utils.isEmptyString(savedUnsentEventsString)) {\n      return []; // new app, does not have any saved events\n    }\n\n    if (type(savedUnsentEventsString) === 'string') {\n      try {\n        var events = JSON.parse(savedUnsentEventsString);\n\n        if (type(events) === 'array') {\n          // handle case where JSON dumping of unsent events is corrupted\n          return events;\n        }\n      } catch (e) {}\n    }\n\n    utils.log.error('Unable to load ' + unsentKey + ' events. Restart with a new empty queue.');\n    return [];\n  };\n  /**\n   * Returns true if a new session was created during initialization, otherwise false.\n   * @public\n   * @return {boolean} Whether a new session was created during initialization.\n   */\n\n\n  AmplitudeClient.prototype.isNewSession = function isNewSession() {\n    return this._newSession;\n  };\n  /**\n   * Store callbacks to call after init\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.onInit = function (callback) {\n    if (this._isInitialized) {\n      callback();\n    } else {\n      this._onInit.push(callback);\n    }\n  };\n  /**\n   * Returns the id of the current session.\n   * @public\n   * @return {number} Id of the current session.\n   */\n\n\n  AmplitudeClient.prototype.getSessionId = function getSessionId() {\n    return this._sessionId;\n  };\n  /**\n   * Increments the eventId and returns it.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.nextEventId = function nextEventId() {\n    this._eventId++;\n    return this._eventId;\n  };\n  /**\n   * Increments the identifyId and returns it.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.nextIdentifyId = function nextIdentifyId() {\n    this._identifyId++;\n    return this._identifyId;\n  };\n  /**\n   * Increments the sequenceNumber and returns it.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.nextSequenceNumber = function nextSequenceNumber() {\n    this._sequenceNumber++;\n    return this._sequenceNumber;\n  };\n  /**\n   * Returns the total count of unsent events and identifys\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._unsentCount = function _unsentCount() {\n    return this._unsentEvents.length + this._unsentIdentifys.length;\n  };\n  /**\n   * Send events if ready. Returns true if events are sent.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._sendEventsIfReady = function _sendEventsIfReady() {\n    if (this._unsentCount() === 0) {\n      return false;\n    } // if batching disabled, send any unsent events immediately\n\n\n    if (!this.options.batchEvents) {\n      this.sendEvents();\n      return true;\n    } // if batching enabled, check if min threshold met for batch size\n\n\n    if (this._unsentCount() >= this.options.eventUploadThreshold) {\n      this.sendEvents();\n      return true;\n    } // otherwise schedule an upload after 30s\n\n\n    if (!this._updateScheduled) {\n      // make sure we only schedule 1 upload\n      this._updateScheduled = true;\n      setTimeout(function () {\n        this._updateScheduled = false;\n        this.sendEvents();\n      }.bind(this), this.options.eventUploadPeriodMillis);\n    }\n\n    return false; // an upload was scheduled, no events were uploaded\n  };\n  /**\n   * Helper function to fetch values from storage\n   * Storage argument allows for localStoraoge and sessionStoraoge\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._getFromStorage = function _getFromStorage(storage, key) {\n    return storage.getItem(key + this._storageSuffix);\n  };\n  /**\n   * Helper function to set values in storage\n   * Storage argument allows for localStoraoge and sessionStoraoge\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._setInStorage = function _setInStorage(storage, key, value) {\n    storage.setItem(key + this._storageSuffix, value);\n  };\n  /**\n   * Fetches deviceId, userId, event meta data from amplitude cookie\n   * @private\n   */\n\n\n  var _loadCookieData = function _loadCookieData(scope) {\n    if (!scope._useOldCookie) {\n      var props = scope._metadataStorage.load();\n\n      if (type(props) === 'object') {\n        _loadCookieDataProps(scope, props);\n      }\n\n      return JSON.stringify(props);\n    }\n\n    var cookieData = scope.cookieStorage.get(scope._oldCookiename);\n\n    if (type(cookieData) === 'object') {\n      _loadCookieDataProps(scope, cookieData);\n    }\n\n    return JSON.stringify(cookieData);\n  };\n\n  var _upgradeCookieData = function _upgradeCookieData(scope) {\n    var cookieData = scope.cookieStorage.get(scope._oldCookiename);\n\n    if (type(cookieData) === 'object') {\n      _loadCookieDataProps(scope, cookieData);\n\n      _saveCookieData(scope);\n    }\n  };\n\n  var _loadCookieDataProps = function _loadCookieDataProps(scope, cookieData) {\n    if (cookieData.deviceId) {\n      scope.options.deviceId = cookieData.deviceId;\n    }\n\n    if (cookieData.userId) {\n      scope.options.userId = cookieData.userId;\n    }\n\n    if (cookieData.optOut !== null && cookieData.optOut !== undefined) {\n      // Do not clobber config opt out value if cookieData has optOut as false\n      if (cookieData.optOut !== false) {\n        scope.options.optOut = cookieData.optOut;\n      }\n    }\n\n    if (cookieData.sessionId) {\n      scope._sessionId = parseInt(cookieData.sessionId, 10);\n    }\n\n    if (cookieData.lastEventTime) {\n      scope._lastEventTime = parseInt(cookieData.lastEventTime, 10);\n    }\n\n    if (cookieData.eventId) {\n      scope._eventId = parseInt(cookieData.eventId, 10);\n    }\n\n    if (cookieData.identifyId) {\n      scope._identifyId = parseInt(cookieData.identifyId, 10);\n    }\n\n    if (cookieData.sequenceNumber) {\n      scope._sequenceNumber = parseInt(cookieData.sequenceNumber, 10);\n    }\n  };\n  /**\n   * Saves deviceId, userId, event meta data to amplitude cookie\n   * @private\n   */\n\n\n  var _saveCookieData = function _saveCookieData(scope) {\n    var cookieData = {\n      deviceId: scope.options.deviceId,\n      userId: scope.options.userId,\n      optOut: scope.options.optOut,\n      sessionId: scope._sessionId,\n      lastEventTime: scope._lastEventTime,\n      eventId: scope._eventId,\n      identifyId: scope._identifyId,\n      sequenceNumber: scope._sequenceNumber\n    };\n\n    if (AsyncStorage) {\n      AsyncStorage.setItem(scope._storageSuffix, JSON.stringify(cookieData));\n    }\n\n    if (scope._useOldCookie) {\n      scope.cookieStorage.set(scope.options.cookieName + scope._storageSuffix, cookieData);\n    } else {\n      return scope._metadataStorage.save(cookieData);\n    }\n  };\n  /**\n   * Parse the utm properties out of cookies and query for adding to user properties.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._initUtmData = function _initUtmData(queryParams, cookieParams) {\n    queryParams = queryParams || this._getUrlParams();\n    cookieParams = cookieParams || this.cookieStorage.get('__utmz');\n    var utmProperties = getUtmData(cookieParams, queryParams);\n\n    _sendParamsReferrerUserProperties(this, utmProperties);\n  };\n  /**\n   * Unset the utm params from the Amplitude instance and update the identify.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._unsetUTMParams = function _unsetUTMParams() {\n    var identify = new Identify();\n    identify.unset(Constants.REFERRER);\n    identify.unset(Constants.UTM_SOURCE);\n    identify.unset(Constants.UTM_MEDIUM);\n    identify.unset(Constants.UTM_CAMPAIGN);\n    identify.unset(Constants.UTM_TERM);\n    identify.unset(Constants.UTM_CONTENT);\n    this.identify(identify);\n  };\n  /**\n   * The calling function should determine when it is appropriate to send these user properties. This function\n   * will no longer contain any session storage checking logic.\n   * @private\n   */\n\n\n  var _sendParamsReferrerUserProperties = function _sendParamsReferrerUserProperties(scope, userProperties) {\n    if (type(userProperties) !== 'object' || Object.keys(userProperties).length === 0) {\n      return;\n    } // setOnce the initial user properties\n\n\n    var identify = new Identify();\n\n    for (var key in userProperties) {\n      if (userProperties.hasOwnProperty(key)) {\n        identify.setOnce('initial_' + key, userProperties[key]);\n        identify.set(key, userProperties[key]);\n      }\n    }\n\n    scope.identify(identify);\n  };\n  /**\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._getReferrer = function _getReferrer() {\n    return document.referrer;\n  };\n  /**\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._getUrlParams = function _getUrlParams() {\n    return location.search;\n  };\n  /**\n   * Try to fetch Google Gclid from url params.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._saveGclid = function _saveGclid(urlParams) {\n    var gclid = utils.getQueryParam('gclid', urlParams);\n\n    if (utils.isEmptyString(gclid)) {\n      return;\n    }\n\n    var gclidProperties = {\n      'gclid': gclid\n    };\n\n    _sendParamsReferrerUserProperties(this, gclidProperties);\n  };\n  /**\n   * Try to fetch Amplitude device id from url params.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._getDeviceIdFromUrlParam = function _getDeviceIdFromUrlParam(urlParams) {\n    return utils.getQueryParam(Constants.AMP_DEVICE_ID_PARAM, urlParams);\n  };\n  /**\n   * Parse the domain from referrer info\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._getReferringDomain = function _getReferringDomain(referrer) {\n    if (utils.isEmptyString(referrer)) {\n      return null;\n    }\n\n    var parts = referrer.split('/');\n\n    if (parts.length >= 3) {\n      return parts[2];\n    }\n\n    return null;\n  };\n  /**\n   * Fetch the referrer information, parse the domain and send.\n   * Since user properties are propagated on the server, only send once per session, don't need to send with every event\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._saveReferrer = function _saveReferrer(referrer) {\n    if (utils.isEmptyString(referrer)) {\n      return;\n    }\n\n    var referrerInfo = {\n      'referrer': referrer,\n      'referring_domain': this._getReferringDomain(referrer)\n    };\n\n    _sendParamsReferrerUserProperties(this, referrerInfo);\n  };\n  /**\n   * Saves unsent events and identifies to localStorage. JSON stringifies event queues before saving.\n   * Note: this is called automatically every time events are logged, unless you explicitly set option saveEvents to false.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.saveEvents = function saveEvents() {\n    try {\n      var serializedUnsentEvents = JSON.stringify(this._unsentEvents.map(function (_ref) {\n        var event = _ref.event;\n        return event;\n      }));\n\n      if (AsyncStorage) {\n        AsyncStorage.setItem(this.options.unsentKey + this._storageSuffix, serializedUnsentEvents);\n      } else {\n        this._setInStorage(localStorage$1, this.options.unsentKey, serializedUnsentEvents);\n      }\n    } catch (e) {}\n\n    try {\n      var serializedIdentifys = JSON.stringify(this._unsentIdentifys.map(function (unsentIdentify) {\n        return unsentIdentify.event;\n      }));\n\n      if (AsyncStorage) {\n        AsyncStorage.setItem(this.options.unsentIdentifyKey + this._storageSuffix, serializedIdentifys);\n      } else {\n        this._setInStorage(localStorage$1, this.options.unsentIdentifyKey, serializedIdentifys);\n      }\n    } catch (e) {}\n  };\n  /**\n   * Sets a customer domain for the amplitude cookie. Useful if you want to support cross-subdomain tracking.\n   * @public\n   * @param {string} domain to set.\n   * @example amplitudeClient.setDomain('.amplitude.com');\n   */\n\n\n  AmplitudeClient.prototype.setDomain = function setDomain(domain) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setDomain'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!utils.validateInput(domain, 'domain', 'string')) {\n      return;\n    }\n\n    try {\n      this.cookieStorage.options({\n        expirationDays: this.options.cookieExpiration,\n        secure: this.options.secureCookie,\n        domain: domain,\n        sameSite: this.options.sameSiteCookie\n      });\n      this.options.domain = this.cookieStorage.options().domain;\n\n      _loadCookieData(this);\n\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n  /**\n   * Sets an identifier for the current user.\n   * @public\n   * @param {string} userId - identifier to set. Can be null.\n   * @example amplitudeClient.setUserId('joe@gmail.com');\n   */\n\n\n  AmplitudeClient.prototype.setUserId = function setUserId(userId) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setUserId'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    try {\n      this.options.userId = userId !== undefined && userId !== null && '' + userId || null;\n\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n  /**\n   * Add user to a group or groups. You need to specify a groupType and groupName(s).\n   * For example you can group people by their organization.\n   * In that case groupType is \"orgId\" and groupName would be the actual ID(s).\n   * groupName can be a string or an array of strings to indicate a user in multiple gruups.\n   * You can also call setGroup multiple times with different groupTypes to track multiple types of groups (up to 5 per app).\n   * Note: this will also set groupType: groupName as a user property.\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information.\n   * @public\n   * @param {string} groupType - the group type (ex: orgId)\n   * @param {string|list} groupName - the name of the group (ex: 15), or a list of names of the groups\n   * @example amplitudeClient.setGroup('orgId', 15); // this adds the current user to orgId 15.\n   */\n\n\n  AmplitudeClient.prototype.setGroup = function (groupType, groupName) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setGroup'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('setGroup()') || !utils.validateInput(groupType, 'groupType', 'string') || utils.isEmptyString(groupType)) {\n      return;\n    }\n\n    var groups = {};\n    groups[groupType] = groupName;\n    var identify = new Identify().set(groupType, groupName);\n\n    this._logEvent(Constants.IDENTIFY_EVENT, null, null, identify.userPropertiesOperations, groups, null, null, null);\n  };\n  /**\n   * Sets whether to opt current user out of tracking.\n   * @public\n   * @param {boolean} enable - if true then no events will be logged or sent.\n   * @example: amplitude.setOptOut(true);\n   */\n\n\n  AmplitudeClient.prototype.setOptOut = function setOptOut(enable) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setOptOut'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!utils.validateInput(enable, 'enable', 'boolean')) {\n      return;\n    }\n\n    try {\n      this.options.optOut = enable;\n\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  AmplitudeClient.prototype.setSessionId = function setSessionId(sessionId) {\n    if (!utils.validateInput(sessionId, 'sessionId', 'number')) {\n      return;\n    }\n\n    try {\n      this._sessionId = sessionId;\n\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  AmplitudeClient.prototype.resetSessionId = function resetSessionId() {\n    this.setSessionId(new Date().getTime());\n  };\n  /**\n    * Regenerates a new random deviceId for current user. Note: this is not recommended unless you know what you\n    * are doing. This can be used in conjunction with `setUserId(null)` to anonymize users after they log out.\n    * With a null userId and a completely new deviceId, the current user would appear as a brand new user in dashboard.\n    * This uses src/uuid.js to regenerate the deviceId.\n    * @public\n    */\n\n\n  AmplitudeClient.prototype.regenerateDeviceId = function regenerateDeviceId() {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['regenerateDeviceId'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    this.setDeviceId(base64Id());\n  };\n  /**\n    * Sets a custom deviceId for current user. Note: this is not recommended unless you know what you are doing\n    * (like if you have your own system for managing deviceIds). Make sure the deviceId you set is sufficiently unique\n    * (we recommend something like a UUID - see src/uuid.js for an example of how to generate) to prevent conflicts with other devices in our system.\n    * @public\n    * @param {string} deviceId - custom deviceId for current user.\n    * @example amplitudeClient.setDeviceId('45f0954f-eb79-4463-ac8a-233a6f45a8f0');\n    */\n\n\n  AmplitudeClient.prototype.setDeviceId = function setDeviceId(deviceId) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setDeviceId'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!utils.validateInput(deviceId, 'deviceId', 'string')) {\n      return;\n    }\n\n    try {\n      if (!utils.isEmptyString(deviceId)) {\n        this.options.deviceId = '' + deviceId;\n\n        _saveCookieData(this);\n      }\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n  /**\n   * Sets user properties for the current user.\n   * @public\n   * @param {object} - object with string keys and values for the user properties to set.\n   * @param {boolean} - DEPRECATED opt_replace: in earlier versions of the JS SDK the user properties object was kept in\n   * memory and replace = true would replace the object in memory. Now the properties are no longer stored in memory, so replace is deprecated.\n   * @example amplitudeClient.setUserProperties({'gender': 'female', 'sign_up_complete': true})\n   */\n\n\n  AmplitudeClient.prototype.setUserProperties = function setUserProperties(userProperties) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setUserProperties'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('setUserProperties()') || !utils.validateInput(userProperties, 'userProperties', 'object')) {\n      return;\n    } // sanitize the userProperties dict before converting into identify\n\n\n    var sanitized = utils.truncate(utils.validateProperties(userProperties));\n\n    if (Object.keys(sanitized).length === 0) {\n      return;\n    } // convert userProperties into an identify call\n\n\n    var identify = new Identify();\n\n    for (var property in sanitized) {\n      if (sanitized.hasOwnProperty(property)) {\n        identify.set(property, sanitized[property]);\n      }\n    }\n\n    this.identify(identify);\n  };\n  /**\n   * Clear all of the user properties for the current user. Note: clearing user properties is irreversible!\n   * @public\n   * @example amplitudeClient.clearUserProperties();\n   */\n\n\n  AmplitudeClient.prototype.clearUserProperties = function clearUserProperties() {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['clearUserProperties'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('clearUserProperties()')) {\n      return;\n    }\n\n    var identify = new Identify();\n    identify.clearAll();\n    this.identify(identify);\n  };\n  /**\n   * Applies the proxied functions on the proxied object to an instance of the real object.\n   * Used to convert proxied Identify and Revenue objects.\n   * @private\n   */\n\n\n  var _convertProxyObjectToRealObject = function _convertProxyObjectToRealObject(instance, proxy) {\n    for (var i = 0; i < proxy._q.length; i++) {\n      var fn = instance[proxy._q[i][0]];\n\n      if (type(fn) === 'function') {\n        fn.apply(instance, proxy._q[i].slice(1));\n      }\n    }\n\n    return instance;\n  };\n  /**\n   * Send an identify call containing user property operations to Amplitude servers.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n   * for more information on the Identify API and user property operations.\n   * @param {Identify} identify_obj - the Identify object containing the user property operations to send.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) callback function to run when the identify event has been sent.\n   * Note: the server response code and response body from the identify event upload are passed to the callback function.\n   * @example\n   * var identify = new amplitude.Identify().set('colors', ['rose', 'gold']).add('karma', 1).setOnce('sign_up_date', '2016-03-31');\n   * amplitude.identify(identify);\n   */\n\n\n  AmplitudeClient.prototype.identify = function (identify_obj, opt_callback) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['identify'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('identify()')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'API key is not set'\n        });\n      }\n\n      return;\n    } // if identify input is a proxied object created by the async loading snippet, convert it into an identify object\n\n\n    if (type(identify_obj) === 'object' && identify_obj.hasOwnProperty('_q')) {\n      identify_obj = _convertProxyObjectToRealObject(new Identify(), identify_obj);\n    }\n\n    if (identify_obj instanceof Identify) {\n      // only send if there are operations\n      if (Object.keys(identify_obj.userPropertiesOperations).length > 0) {\n        return this._logEvent(Constants.IDENTIFY_EVENT, null, null, identify_obj.userPropertiesOperations, null, null, null, opt_callback);\n      } else {\n        if (type(opt_callback) === 'function') {\n          opt_callback(0, 'No request sent', {\n            reason: 'No user property operations'\n          });\n        }\n      }\n    } else {\n      utils.log.error('Invalid identify input type. Expected Identify object but saw ' + type(identify_obj));\n\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid identify input type'\n        });\n      }\n    }\n  };\n\n  AmplitudeClient.prototype.groupIdentify = function (group_type, group_name, identify_obj, opt_callback) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['groupIdentify'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('groupIdentify()')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'API key is not set'\n        });\n      }\n\n      return;\n    }\n\n    if (!utils.validateInput(group_type, 'group_type', 'string') || utils.isEmptyString(group_type)) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid group type'\n        });\n      }\n\n      return;\n    }\n\n    if (group_name === null || group_name === undefined) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid group name'\n        });\n      }\n\n      return;\n    } // if identify input is a proxied object created by the async loading snippet, convert it into an identify object\n\n\n    if (type(identify_obj) === 'object' && identify_obj.hasOwnProperty('_q')) {\n      identify_obj = _convertProxyObjectToRealObject(new Identify(), identify_obj);\n    }\n\n    if (identify_obj instanceof Identify) {\n      // only send if there are operations\n      if (Object.keys(identify_obj.userPropertiesOperations).length > 0) {\n        return this._logEvent(Constants.GROUP_IDENTIFY_EVENT, null, null, null, _defineProperty({}, group_type, group_name), identify_obj.userPropertiesOperations, null, opt_callback);\n      } else {\n        if (type(opt_callback) === 'function') {\n          opt_callback(0, 'No request sent', {\n            reason: 'No group property operations'\n          });\n        }\n      }\n    } else {\n      utils.log.error('Invalid identify input type. Expected Identify object but saw ' + type(identify_obj));\n\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid identify input type'\n        });\n      }\n    }\n  };\n  /**\n   * Set a versionName for your application.\n   * @public\n   * @param {string} versionName - The version to set for your application.\n   * @example amplitudeClient.setVersionName('1.12.3');\n   */\n\n\n  AmplitudeClient.prototype.setVersionName = function setVersionName(versionName) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['setVersionName'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!utils.validateInput(versionName, 'versionName', 'string')) {\n      return;\n    }\n\n    this.options.versionName = versionName;\n  };\n  /**\n   * Private logEvent method. Keeps apiProperties from being publicly exposed.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._logEvent = function _logEvent(eventType, eventProperties, apiProperties, userProperties, groups, groupProperties, timestamp, callback) {\n    var loadedCookieData = \"\";\n\n    {\n      loadedCookieData = _loadCookieData(this); // reload cookie before each log event to sync event meta-data between windows and tabs\n    }\n\n    if (!eventType) {\n      if (type(callback) === 'function') {\n        callback(0, 'No request sent', {\n          reason: 'Missing eventType'\n        });\n      }\n\n      return;\n    }\n\n    if (this.options.optOut) {\n      if (type(callback) === 'function') {\n        callback(0, 'No request sent', {\n          reason: 'optOut is set to true'\n        });\n      }\n\n      return;\n    }\n\n    try {\n      var eventId;\n\n      if (eventType === Constants.IDENTIFY_EVENT || eventType === Constants.GROUP_IDENTIFY_EVENT) {\n        eventId = this.nextIdentifyId();\n      } else {\n        eventId = this.nextEventId();\n      }\n\n      var sequenceNumber = this.nextSequenceNumber();\n      var eventTime = type(timestamp) === 'number' ? timestamp : new Date().getTime();\n\n      if (!this._sessionId || !this._lastEventTime || eventTime - this._lastEventTime > this.options.sessionTimeout) {\n        this._sessionId = eventTime;\n      }\n\n      this._lastEventTime = eventTime;\n\n      var savedCookieData = _saveCookieData(this);\n\n      var osName = this._ua.browser.name;\n      var osVersion = this._ua.browser.major;\n      var deviceModel = this._ua.device.model;\n      var deviceManufacturer = this._ua.device.vendor;\n      var versionName;\n      var carrier;\n\n      userProperties = userProperties || {};\n\n      var trackingOptions = _objectSpread({}, this._apiPropertiesTrackingOptions);\n\n      apiProperties = _objectSpread({}, apiProperties || {}, trackingOptions);\n      eventProperties = eventProperties || {};\n      groups = groups || {};\n      groupProperties = groupProperties || {};\n      var event = {\n        device_id: this.options.deviceId,\n        user_id: this.options.userId,\n        timestamp: eventTime,\n        event_id: eventId,\n        session_id: this._sessionId || -1,\n        event_type: eventType,\n        version_name: _shouldTrackField(this, 'version_name') ? this.options.versionName || versionName || null : null,\n        platform: _shouldTrackField(this, 'platform') ? this.options.platform : null,\n        os_name: _shouldTrackField(this, 'os_name') ? osName || null : null,\n        os_version: _shouldTrackField(this, 'os_version') ? osVersion || null : null,\n        device_model: _shouldTrackField(this, 'device_model') ? deviceModel || null : null,\n        device_manufacturer: _shouldTrackField(this, 'device_manufacturer') ? deviceManufacturer || null : null,\n        language: _shouldTrackField(this, 'language') ? this.options.language : null,\n        carrier: _shouldTrackField(this, 'carrier') ? carrier || null : null,\n        api_properties: apiProperties,\n        event_properties: utils.truncate(utils.validateProperties(eventProperties)),\n        user_properties: _objectSpread({}, utils.truncate(utils.validateProperties(userProperties)), {\n          'cookies disabled': this._metadataStorage.disableCookieStorage,\n          'blank cookie': this._metadataStorage.blankCookie,\n          'cookie error': this._metadataStorage.cookieError,\n          'use old cookie': this._useOldCookie,\n          'saved cookie data': savedCookieData,\n          'loaded cookie data': loadedCookieData\n        }),\n        uuid: uuid(),\n        library: {\n          name: 'amplitude-js',\n          version: version\n        },\n        sequence_number: sequenceNumber,\n        // for ordering events and identifys\n        groups: utils.truncate(utils.validateGroups(groups)),\n        group_properties: utils.truncate(utils.validateProperties(groupProperties)),\n        user_agent: this._userAgent\n      };\n\n      if (eventType === Constants.IDENTIFY_EVENT || eventType === Constants.GROUP_IDENTIFY_EVENT) {\n        this._unsentIdentifys.push({\n          event: event,\n          callback: callback\n        });\n\n        this._limitEventsQueued(this._unsentIdentifys);\n      } else {\n        this._unsentEvents.push({\n          event: event,\n          callback: callback\n        });\n\n        this._limitEventsQueued(this._unsentEvents);\n      }\n\n      if (this.options.saveEvents) {\n        this.saveEvents();\n      }\n\n      this._sendEventsIfReady(callback);\n\n      return eventId;\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  var _shouldTrackField = function _shouldTrackField(scope, field) {\n    return !!scope.options.trackingOptions[field];\n  };\n\n  var _generateApiPropertiesTrackingConfig = function _generateApiPropertiesTrackingConfig(scope) {\n    // to limit size of config payload, only send fields that have been disabled\n    var fields = ['city', 'country', 'dma', 'ip_address', 'region'];\n    var config = {};\n\n    for (var i = 0; i < fields.length; i++) {\n      var field = fields[i];\n\n      if (!_shouldTrackField(scope, field)) {\n        config[field] = false;\n      }\n    }\n\n    return config;\n  };\n  /**\n   * Remove old events from the beginning of the array if too many have accumulated. Default limit is 1000 events.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._limitEventsQueued = function _limitEventsQueued(queue) {\n    if (queue.length > this.options.savedMaxCount) {\n      queue.splice(0, queue.length - this.options.savedMaxCount);\n    }\n  };\n  /**\n   * This is the callback for logEvent and identify calls. It gets called after the event/identify is uploaded,\n   * and the server response code and response body from the upload request are passed to the callback function.\n   * @callback Amplitude~eventCallback\n   * @param {number} responseCode - Server response code for the event / identify upload request.\n   * @param {string} responseBody - Server response body for the event / identify upload request.\n   */\n\n  /**\n   * Log an event with eventType and eventProperties\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n   */\n\n\n  AmplitudeClient.prototype.logEvent = function logEvent(eventType, eventProperties, opt_callback) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['logEvent'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    return this.logEventWithTimestamp(eventType, eventProperties, null, opt_callback);\n  };\n  /**\n   * Log an event with eventType and eventProperties and a custom timestamp\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {number} timestamp - (optional) the custom timestamp as milliseconds since epoch.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n   */\n\n\n  AmplitudeClient.prototype.logEventWithTimestamp = function logEvent(eventType, eventProperties, timestamp, opt_callback) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['logEventWithTimestamp'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('logEvent()')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'API key not set'\n        });\n      }\n\n      return -1;\n    }\n\n    if (!utils.validateInput(eventType, 'eventType', 'string')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid type for eventType'\n        });\n      }\n\n      return -1;\n    }\n\n    if (utils.isEmptyString(eventType)) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Missing eventType'\n        });\n      }\n\n      return -1;\n    }\n\n    return this._logEvent(eventType, eventProperties, null, null, null, null, timestamp, opt_callback);\n  };\n  /**\n   * Log an event with eventType, eventProperties, and groups. Use this to set event-level groups.\n   * Note: the group(s) set only apply for the specific event type being logged and does not persist on the user\n   * (unless you explicitly set it with setGroup).\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information\n   * about groups and Count by Distinct on the Amplitude platform.\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {object} groups - (optional) an object with string groupType: groupName values for the event being logged.\n   * groupName can be a string or an array of strings.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEventWithGroups('Clicked Button', null, {'orgId': 24});\n   */\n\n\n  AmplitudeClient.prototype.logEventWithGroups = function (eventType, eventProperties, groups, opt_callback) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['logEventWithGroups'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('logEventWithGroups()')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'API key not set'\n        });\n      }\n\n      return -1;\n    }\n\n    if (!utils.validateInput(eventType, 'eventType', 'string')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent', {\n          reason: 'Invalid type for eventType'\n        });\n      }\n\n      return -1;\n    }\n\n    return this._logEvent(eventType, eventProperties, null, null, groups, null, null, opt_callback);\n  };\n  /**\n   * Test that n is a number or a numeric value.\n   * @private\n   */\n\n\n  var _isNumber = function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  };\n  /**\n   * Log revenue with Revenue interface. The new revenue interface allows for more revenue fields like\n   * revenueType and event properties.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue}\n   * for more information on the Revenue interface and logging revenue.\n   * @public\n   * @param {Revenue} revenue_obj - the revenue object containing the revenue data being logged.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n\n\n  AmplitudeClient.prototype.logRevenueV2 = function logRevenueV2(revenue_obj) {\n    if (this._shouldDeferCall()) {\n      return this._q.push(['logRevenueV2'].concat(Array.prototype.slice.call(arguments, 0)));\n    }\n\n    if (!this._apiKeySet('logRevenueV2()')) {\n      return;\n    } // if revenue input is a proxied object created by the async loading snippet, convert it into an revenue object\n\n\n    if (type(revenue_obj) === 'object' && revenue_obj.hasOwnProperty('_q')) {\n      revenue_obj = _convertProxyObjectToRealObject(new Revenue(), revenue_obj);\n    }\n\n    if (revenue_obj instanceof Revenue) {\n      // only send if revenue is valid\n      if (revenue_obj && revenue_obj._isValidRevenue()) {\n        return this.logEvent(Constants.REVENUE_EVENT, revenue_obj._toJSONObject());\n      }\n    } else {\n      utils.log.error('Invalid revenue input type. Expected Revenue object but saw ' + type(revenue_obj));\n    }\n  };\n\n  {\n    /**\n     * Log revenue event with a price, quantity, and product identifier. DEPRECATED - use logRevenueV2\n     * @public\n     * @deprecated\n     * @param {number} price - price of revenue event\n     * @param {number} quantity - (optional) quantity of products in revenue event. If no quantity specified default to 1.\n     * @param {string} product - (optional) product identifier\n     * @example amplitudeClient.logRevenue(3.99, 1, 'product_1234');\n     */\n    AmplitudeClient.prototype.logRevenue = function logRevenue(price, quantity, product) {\n      if (this._shouldDeferCall()) {\n        return this._q.push(['logRevenue'].concat(Array.prototype.slice.call(arguments, 0)));\n      } // Test that the parameters are of the right type.\n\n\n      if (!this._apiKeySet('logRevenue()') || !_isNumber(price) || quantity !== undefined && !_isNumber(quantity)) {\n        // utils.log('Price and quantity arguments to logRevenue must be numbers');\n        return -1;\n      }\n\n      return this._logEvent(Constants.REVENUE_EVENT, {}, {\n        productId: product,\n        special: 'revenue_amount',\n        quantity: quantity || 1,\n        price: price\n      }, null, null, null, null, null);\n    };\n  }\n  /**\n   * Remove events in storage with event ids up to and including maxEventId.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.removeEvents = function removeEvents(maxEventId, maxIdentifyId, status, response) {\n    _removeEvents(this, '_unsentEvents', maxEventId, status, response);\n\n    _removeEvents(this, '_unsentIdentifys', maxIdentifyId, status, response);\n  };\n  /**\n   * Helper function to remove events up to maxId from a single queue.\n   * Does a true filter in case events get out of order or old events are removed.\n   * @private\n   */\n\n\n  var _removeEvents = function _removeEvents(scope, eventQueue, maxId, status, response) {\n    if (maxId < 0) {\n      return;\n    }\n\n    var filteredEvents = [];\n\n    for (var i = 0; i < scope[eventQueue].length || 0; i++) {\n      var unsentEvent = scope[eventQueue][i];\n\n      if (unsentEvent.event.event_id > maxId) {\n        filteredEvents.push(unsentEvent);\n      } else {\n        if (unsentEvent.callback) {\n          unsentEvent.callback(status, response);\n        }\n      }\n    }\n\n    scope[eventQueue] = filteredEvents;\n  };\n  /**\n   * Send unsent events. Note: this is called automatically after events are logged if option batchEvents is false.\n   * If batchEvents is true, then events are only sent when batch criterias are met.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype.sendEvents = function sendEvents() {\n    if (!this._apiKeySet('sendEvents()')) {\n      this.removeEvents(Infinity, Infinity, 0, 'No request sent', {\n        reason: 'API key not set'\n      });\n      return;\n    }\n\n    if (this.options.optOut) {\n      this.removeEvents(Infinity, Infinity, 0, 'No request sent', {\n        reason: 'Opt out is set to true'\n      });\n      return;\n    } // How is it possible to get into this state?\n\n\n    if (this._unsentCount() === 0) {\n      return;\n    } // We only make one request at a time. sendEvents will be invoked again once\n    // the last request completes.\n\n\n    if (this._sending) {\n      return;\n    }\n\n    this._sending = true;\n    var protocol = this.options.forceHttps ? 'https' : 'https:' === window.location.protocol ? 'https' : 'http';\n    var url = protocol + '://' + this.options.apiEndpoint; // fetch events to send\n\n    var numEvents = Math.min(this._unsentCount(), this.options.uploadBatchSize);\n\n    var mergedEvents = this._mergeEventsAndIdentifys(numEvents);\n\n    var maxEventId = mergedEvents.maxEventId;\n    var maxIdentifyId = mergedEvents.maxIdentifyId;\n    var events = JSON.stringify(mergedEvents.eventsToSend.map(function (_ref2) {\n      var event = _ref2.event;\n      return event;\n    }));\n    var uploadTime = new Date().getTime();\n    var data = {\n      client: this.options.apiKey,\n      e: events,\n      v: Constants.API_VERSION,\n      upload_time: uploadTime,\n      checksum: md5(Constants.API_VERSION + this.options.apiKey + events + uploadTime)\n    };\n    var scope = this;\n    new Request(url, data).send(function (status, response) {\n      scope._sending = false;\n\n      try {\n        if (status === 200 && response === 'success') {\n          scope.removeEvents(maxEventId, maxIdentifyId, status, response); // Update the event cache after the removal of sent events.\n\n          if (scope.options.saveEvents) {\n            scope.saveEvents();\n          } // Send more events if any queued during previous send.\n\n\n          scope._sendEventsIfReady(); // handle payload too large\n\n        } else if (status === 413) {\n          // utils.log('request too large');\n          // Can't even get this one massive event through. Drop it, even if it is an identify.\n          if (scope.options.uploadBatchSize === 1) {\n            scope.removeEvents(maxEventId, maxIdentifyId, status, response);\n          } // The server complained about the length of the request. Backoff and try again.\n\n\n          scope.options.uploadBatchSize = Math.ceil(numEvents / 2);\n          scope.sendEvents();\n        } // else {\n        //  all the events are still queued, and will be retried when the next\n        //  event is sent In the interest of debugging, it would be nice to have\n        //  something like an event emitter for a better debugging experince\n        //  here.\n        // }\n\n      } catch (e) {// utils.log('failed upload');\n      }\n    });\n  };\n  /**\n   * Merge unsent events and identifys together in sequential order based on their sequence number, for uploading.\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._mergeEventsAndIdentifys = function _mergeEventsAndIdentifys(numEvents) {\n    // coalesce events from both queues\n    var eventsToSend = [];\n    var eventIndex = 0;\n    var maxEventId = -1;\n    var identifyIndex = 0;\n    var maxIdentifyId = -1;\n\n    while (eventsToSend.length < numEvents) {\n      var unsentEvent = void 0;\n      var noIdentifys = identifyIndex >= this._unsentIdentifys.length;\n      var noEvents = eventIndex >= this._unsentEvents.length; // case 0: no events or identifys left\n      // note this should not happen, this means we have less events and identifys than expected\n\n      if (noEvents && noIdentifys) {\n        utils.log.error('Merging Events and Identifys, less events and identifys than expected');\n        break;\n      } // case 1: no identifys - grab from events\n      else if (noIdentifys) {\n          unsentEvent = this._unsentEvents[eventIndex++];\n          maxEventId = unsentEvent.event.event_id; // case 2: no events - grab from identifys\n        } else if (noEvents) {\n          unsentEvent = this._unsentIdentifys[identifyIndex++];\n          maxIdentifyId = unsentEvent.event.event_id; // case 3: need to compare sequence numbers\n        } else {\n          // events logged before v2.5.0 won't have a sequence number, put those first\n          if (!('sequence_number' in this._unsentEvents[eventIndex].event) || this._unsentEvents[eventIndex].event.sequence_number < this._unsentIdentifys[identifyIndex].event.sequence_number) {\n            unsentEvent = this._unsentEvents[eventIndex++];\n            maxEventId = unsentEvent.event.event_id;\n          } else {\n            unsentEvent = this._unsentIdentifys[identifyIndex++];\n            maxIdentifyId = unsentEvent.event.event_id;\n          }\n        }\n\n      eventsToSend.push(unsentEvent);\n    }\n\n    return {\n      eventsToSend: eventsToSend,\n      maxEventId: maxEventId,\n      maxIdentifyId: maxIdentifyId\n    };\n  };\n\n  {\n    /**\n     * Set global user properties. Note this is deprecated, and we recommend using setUserProperties\n     * @public\n     * @deprecated\n     */\n    AmplitudeClient.prototype.setGlobalUserProperties = function setGlobalUserProperties(userProperties) {\n      this.setUserProperties(userProperties);\n    };\n  }\n  /**\n   * Get the current version of Amplitude's Javascript SDK.\n   * @public\n   * @returns {number} version number\n   * @example var amplitudeVersion = amplitude.__VERSION__;\n   */\n\n\n  AmplitudeClient.prototype.__VERSION__ = version;\n  /**\n   * Determines whether or not to push call to this._q or invoke it\n   * @private\n   */\n\n  AmplitudeClient.prototype._shouldDeferCall = function _shouldDeferCall() {\n    return this._pendingReadStorage || this._initializationDeferred;\n  };\n  /**\n   * Defers Initialization by putting all functions into storage until users\n   * have accepted terms for tracking\n   * @private\n   */\n\n\n  AmplitudeClient.prototype._deferInitialization = function _deferInitialization() {\n    this._initializationDeferred = true;\n\n    this._q.push(['init'].concat(Array.prototype.slice.call(arguments, 0)));\n  };\n  /**\n   * Enable tracking via logging events and dropping a cookie\n   * Intended to be used with the deferInitialization configuration flag\n   * This will drop a cookie and reset initialization deferred\n   * @public\n   */\n\n\n  AmplitudeClient.prototype.enableTracking = function enableTracking() {\n    // This will call init (which drops the cookie) and will run any pending tasks\n    this._initializationDeferred = false;\n\n    _saveCookieData(this);\n\n    this.runQueuedFunctions();\n  };\n\n  /**\n   * Amplitude SDK API - instance manager.\n   * Function calls directly on amplitude have been deprecated. Please call methods on the default shared instance: amplitude.getInstance() instead.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#300-update-and-logging-events-to-multiple-amplitude-apps} for more information about this change.\n   * @constructor Amplitude\n   * @public\n   * @example var amplitude = new Amplitude();\n   */\n\n  var Amplitude = function Amplitude() {\n    this.options = _objectSpread({}, DEFAULT_OPTIONS);\n    this._q = [];\n    this._instances = {}; // mapping of instance names to instances\n  };\n\n  Amplitude.prototype.Identify = Identify;\n  Amplitude.prototype.Revenue = Revenue;\n\n  Amplitude.prototype.getInstance = function getInstance(instance) {\n    instance = utils.isEmptyString(instance) ? Constants.DEFAULT_INSTANCE : instance.toLowerCase();\n    var client = this._instances[instance];\n\n    if (client === undefined) {\n      client = new AmplitudeClient(instance);\n      this._instances[instance] = client;\n    }\n\n    return client;\n  };\n\n  {\n    /**\n     * Run functions queued up by proxy loading snippet\n     * @private\n     */\n    Amplitude.prototype.runQueuedFunctions = function () {\n      // run queued up old versions of functions\n      for (var i = 0; i < this._q.length; i++) {\n        var fn = this[this._q[i][0]];\n\n        if (type(fn) === 'function') {\n          fn.apply(this, this._q[i].slice(1));\n        }\n      }\n\n      this._q = []; // clear function queue after running\n      // run queued up functions on instances\n\n      for (var instance in this._instances) {\n        if (this._instances.hasOwnProperty(instance)) {\n          this._instances[instance].runQueuedFunctions();\n        }\n      }\n    };\n  }\n\n  {\n    /**\n     * Initializes the Amplitude Javascript SDK with your apiKey and any optional configurations.\n     * This is required before any other methods can be called.\n     * @public\n     * @param {string} apiKey - The API key for your app.\n     * @param {string} opt_userId - (optional) An identifier for this user.\n     * @param {object} opt_config - (optional) Configuration options.\n     * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#configuration-options} for list of options and default values.\n     * @param {function} opt_callback - (optional) Provide a callback function to run after initialization is complete.\n     * @deprecated Please use amplitude.getInstance().init(apiKey, opt_userId, opt_config, opt_callback);\n     * @example amplitude.init('API_KEY', 'USER_ID', {includeReferrer: true, includeUtm: true}, function() { alert('init complete'); });\n     */\n    Amplitude.prototype.init = function init(apiKey, opt_userId, opt_config, opt_callback) {\n      this.getInstance().init(apiKey, opt_userId, opt_config, function (instance) {\n        // make options such as deviceId available for callback functions\n        this.options = instance.options;\n\n        if (type(opt_callback) === 'function') {\n          opt_callback(instance);\n        }\n      }.bind(this));\n    };\n    /**\n     * Returns true if a new session was created during initialization, otherwise false.\n     * @public\n     * @return {boolean} Whether a new session was created during initialization.\n     * @deprecated Please use amplitude.getInstance().isNewSession();\n     */\n\n\n    Amplitude.prototype.isNewSession = function isNewSession() {\n      return this.getInstance().isNewSession();\n    };\n    /**\n     * Returns the id of the current session.\n     * @public\n     * @return {number} Id of the current session.\n     * @deprecated Please use amplitude.getInstance().getSessionId();\n     */\n\n\n    Amplitude.prototype.getSessionId = function getSessionId() {\n      return this.getInstance().getSessionId();\n    };\n    /**\n     * Increments the eventId and returns it.\n     * @private\n     */\n\n\n    Amplitude.prototype.nextEventId = function nextEventId() {\n      return this.getInstance().nextEventId();\n    };\n    /**\n     * Increments the identifyId and returns it.\n     * @private\n     */\n\n\n    Amplitude.prototype.nextIdentifyId = function nextIdentifyId() {\n      return this.getInstance().nextIdentifyId();\n    };\n    /**\n     * Increments the sequenceNumber and returns it.\n     * @private\n     */\n\n\n    Amplitude.prototype.nextSequenceNumber = function nextSequenceNumber() {\n      return this.getInstance().nextSequenceNumber();\n    };\n    /**\n     * Saves unsent events and identifies to localStorage. JSON stringifies event queues before saving.\n     * Note: this is called automatically every time events are logged, unless you explicitly set option saveEvents to false.\n     * @private\n     */\n\n\n    Amplitude.prototype.saveEvents = function saveEvents() {\n      this.getInstance().saveEvents();\n    };\n    /**\n     * Sets a customer domain for the amplitude cookie. Useful if you want to support cross-subdomain tracking.\n     * @public\n     * @param {string} domain to set.\n     * @deprecated Please use amplitude.getInstance().setDomain(domain);\n     * @example amplitude.setDomain('.amplitude.com');\n     */\n\n\n    Amplitude.prototype.setDomain = function setDomain(domain) {\n      this.getInstance().setDomain(domain);\n    };\n    /**\n     * Sets an identifier for the current user.\n     * @public\n     * @param {string} userId - identifier to set. Can be null.\n     * @deprecated Please use amplitude.getInstance().setUserId(userId);\n     * @example amplitude.setUserId('joe@gmail.com');\n     */\n\n\n    Amplitude.prototype.setUserId = function setUserId(userId) {\n      this.getInstance().setUserId(userId);\n    };\n    /**\n     * Add user to a group or groups. You need to specify a groupType and groupName(s).\n     * For example you can group people by their organization.\n     * In that case groupType is \"orgId\" and groupName would be the actual ID(s).\n     * groupName can be a string or an array of strings to indicate a user in multiple gruups.\n     * You can also call setGroup multiple times with different groupTypes to track multiple types of groups (up to 5 per app).\n     * Note: this will also set groupType: groupName as a user property.\n     * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information.\n     * @public\n     * @param {string} groupType - the group type (ex: orgId)\n     * @param {string|list} groupName - the name of the group (ex: 15), or a list of names of the groups\n     * @deprecated Please use amplitude.getInstance().setGroup(groupType, groupName);\n     * @example amplitude.setGroup('orgId', 15); // this adds the current user to orgId 15.\n     */\n\n\n    Amplitude.prototype.setGroup = function (groupType, groupName) {\n      this.getInstance().setGroup(groupType, groupName);\n    };\n    /**\n     * Sets whether to opt current user out of tracking.\n     * @public\n     * @param {boolean} enable - if true then no events will be logged or sent.\n     * @deprecated Please use amplitude.getInstance().setOptOut(enable);\n     * @example: amplitude.setOptOut(true);\n     */\n\n\n    Amplitude.prototype.setOptOut = function setOptOut(enable) {\n      this.getInstance().setOptOut(enable);\n    };\n    /**\n      * Regenerates a new random deviceId for current user. Note: this is not recommended unless you know what you\n      * are doing. This can be used in conjunction with `setUserId(null)` to anonymize users after they log out.\n      * With a null userId and a completely new deviceId, the current user would appear as a brand new user in dashboard.\n      * This uses src/uuid.js to regenerate the deviceId.\n      * @public\n      * @deprecated Please use amplitude.getInstance().regenerateDeviceId();\n      */\n\n\n    Amplitude.prototype.regenerateDeviceId = function regenerateDeviceId() {\n      this.getInstance().regenerateDeviceId();\n    };\n    /**\n      * Sets a custom deviceId for current user. Note: this is not recommended unless you know what you are doing\n      * (like if you have your own system for managing deviceIds). Make sure the deviceId you set is sufficiently unique\n      * (we recommend something like a UUID - see src/uuid.js for an example of how to generate) to prevent conflicts with other devices in our system.\n      * @public\n      * @param {string} deviceId - custom deviceId for current user.\n      * @deprecated Please use amplitude.getInstance().setDeviceId(deviceId);\n      * @example amplitude.setDeviceId('45f0954f-eb79-4463-ac8a-233a6f45a8f0');\n      */\n\n\n    Amplitude.prototype.setDeviceId = function setDeviceId(deviceId) {\n      this.getInstance().setDeviceId(deviceId);\n    };\n    /**\n     * Sets user properties for the current user.\n     * @public\n     * @param {object} - object with string keys and values for the user properties to set.\n     * @param {boolean} - DEPRECATED opt_replace: in earlier versions of the JS SDK the user properties object was kept in\n     * memory and replace = true would replace the object in memory. Now the properties are no longer stored in memory, so replace is deprecated.\n     * @deprecated Please use amplitude.getInstance.setUserProperties(userProperties);\n     * @example amplitude.setUserProperties({'gender': 'female', 'sign_up_complete': true})\n     */\n\n\n    Amplitude.prototype.setUserProperties = function setUserProperties(userProperties) {\n      this.getInstance().setUserProperties(userProperties);\n    };\n    /**\n     * Clear all of the user properties for the current user. Note: clearing user properties is irreversible!\n     * @public\n     * @deprecated Please use amplitude.getInstance().clearUserProperties();\n     * @example amplitude.clearUserProperties();\n     */\n\n\n    Amplitude.prototype.clearUserProperties = function clearUserProperties() {\n      this.getInstance().clearUserProperties();\n    };\n    /**\n     * Send an identify call containing user property operations to Amplitude servers.\n     * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n     * for more information on the Identify API and user property operations.\n     * @param {Identify} identify_obj - the Identify object containing the user property operations to send.\n     * @param {Amplitude~eventCallback} opt_callback - (optional) callback function to run when the identify event has been sent.\n     * Note: the server response code and response body from the identify event upload are passed to the callback function.\n     * @deprecated Please use amplitude.getInstance().identify(identify);\n     * @example\n     * var identify = new amplitude.Identify().set('colors', ['rose', 'gold']).add('karma', 1).setOnce('sign_up_date', '2016-03-31');\n     * amplitude.identify(identify);\n     */\n\n\n    Amplitude.prototype.identify = function (identify_obj, opt_callback) {\n      this.getInstance().identify(identify_obj, opt_callback);\n    };\n    /**\n     * Set a versionName for your application.\n     * @public\n     * @param {string} versionName - The version to set for your application.\n     * @deprecated Please use amplitude.getInstance().setVersionName(versionName);\n     * @example amplitude.setVersionName('1.12.3');\n     */\n\n\n    Amplitude.prototype.setVersionName = function setVersionName(versionName) {\n      this.getInstance().setVersionName(versionName);\n    };\n    /**\n     * This is the callback for logEvent and identify calls. It gets called after the event/identify is uploaded,\n     * and the server response code and response body from the upload request are passed to the callback function.\n     * @callback Amplitude~eventCallback\n     * @param {number} responseCode - Server response code for the event / identify upload request.\n     * @param {string} responseBody - Server response body for the event / identify upload request.\n     */\n\n    /**\n     * Log an event with eventType and eventProperties\n     * @public\n     * @param {string} eventType - name of event\n     * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n     * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n     * Note: the server response code and response body from the event upload are passed to the callback function.\n     * @deprecated Please use amplitude.getInstance().logEvent(eventType, eventProperties, opt_callback);\n     * @example amplitude.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n     */\n\n\n    Amplitude.prototype.logEvent = function logEvent(eventType, eventProperties, opt_callback) {\n      return this.getInstance().logEvent(eventType, eventProperties, opt_callback);\n    };\n    /**\n     * Log an event with eventType, eventProperties, and groups. Use this to set event-level groups.\n     * Note: the group(s) set only apply for the specific event type being logged and does not persist on the user\n     * (unless you explicitly set it with setGroup).\n     * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information\n     * about groups and Count by Distinct on the Amplitude platform.\n     * @public\n     * @param {string} eventType - name of event\n     * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n     * @param {object} groups - (optional) an object with string groupType: groupName values for the event being logged.\n     * groupName can be a string or an array of strings.\n     * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n     * Note: the server response code and response body from the event upload are passed to the callback function.\n     * Deprecated Please use amplitude.getInstance().logEventWithGroups(eventType, eventProperties, groups, opt_callback);\n     * @example amplitude.logEventWithGroups('Clicked Button', null, {'orgId': 24});\n     */\n\n\n    Amplitude.prototype.logEventWithGroups = function (eventType, eventProperties, groups, opt_callback) {\n      return this.getInstance().logEventWithGroups(eventType, eventProperties, groups, opt_callback);\n    };\n    /**\n     * Log revenue with Revenue interface. The new revenue interface allows for more revenue fields like\n     * revenueType and event properties.\n     * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue}\n     * for more information on the Revenue interface and logging revenue.\n     * @public\n     * @param {Revenue} revenue_obj - the revenue object containing the revenue data being logged.\n     * @deprecated Please use amplitude.getInstance().logRevenueV2(revenue_obj);\n     * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n     * amplitude.logRevenueV2(revenue);\n     */\n\n\n    Amplitude.prototype.logRevenueV2 = function logRevenueV2(revenue_obj) {\n      return this.getInstance().logRevenueV2(revenue_obj);\n    };\n    /**\n     * Log revenue event with a price, quantity, and product identifier. DEPRECATED - use logRevenueV2\n     * @public\n     * @param {number} price - price of revenue event\n     * @param {number} quantity - (optional) quantity of products in revenue event. If no quantity specified default to 1.\n     * @param {string} product - (optional) product identifier\n     * @deprecated Please use amplitude.getInstance().logRevenueV2(revenue_obj);\n     * @example amplitude.logRevenue(3.99, 1, 'product_1234');\n     */\n\n\n    Amplitude.prototype.logRevenue = function logRevenue(price, quantity, product) {\n      return this.getInstance().logRevenue(price, quantity, product);\n    };\n    /**\n     * Remove events in storage with event ids up to and including maxEventId.\n     * @private\n     */\n\n\n    Amplitude.prototype.removeEvents = function removeEvents(maxEventId, maxIdentifyId) {\n      this.getInstance().removeEvents(maxEventId, maxIdentifyId);\n    };\n    /**\n     * Send unsent events. Note: this is called automatically after events are logged if option batchEvents is false.\n     * If batchEvents is true, then events are only sent when batch criterias are met.\n     * @private\n     * @param {Amplitude~eventCallback} callback - (optional) callback to run after events are sent.\n     * Note the server response code and response body are passed to the callback as input arguments.\n     */\n\n\n    Amplitude.prototype.sendEvents = function sendEvents(callback) {\n      this.getInstance().sendEvents(callback);\n    };\n    /**\n     * Set global user properties. Note this is deprecated, and we recommend using setUserProperties\n     * @public\n     * @deprecated\n     */\n\n\n    Amplitude.prototype.setGlobalUserProperties = function setGlobalUserProperties(userProperties) {\n      this.getInstance().setUserProperties(userProperties);\n    };\n  }\n  /**\n   * Get the current version of Amplitude's Javascript SDK.\n   * @public\n   * @returns {number} version number\n   * @example var amplitudeVersion = amplitude.__VERSION__;\n   */\n\n\n  Amplitude.prototype.__VERSION__ = version;\n\n  /* jshint expr:true */\n  var old = window.amplitude || {};\n  var newInstance = new Amplitude();\n  newInstance._q = old._q || [];\n\n  for (var instance in old._iq) {\n    // migrate each instance's queue\n    if (old._iq.hasOwnProperty(instance)) {\n      newInstance.getInstance(instance)._q = old._iq[instance]._q || [];\n    }\n  }\n\n  {\n    newInstance.runQueuedFunctions();\n  } // export the instance\n\n  return newInstance;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1wbGl0dWRlLWpzL2FtcGxpdHVkZS51bWQuanM/NTFjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxTQUN1RDtBQUN6RCxDQUFDLG9CQUFvQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVk7QUFDbkI7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVk7QUFDbkI7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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Q0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkMsNkNBQTZDO0FBQzdDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGOztBQUU3RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isb0JBQW9COztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhFQUE4RTtBQUM5RTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdEQUF3RDtBQUN4RDs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7O0FBRUEsaURBQWlEO0FBQ2pEOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQSxpQ0FBaUMsK0JBQStCLGtEQUFrRDtBQUNsSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLFNBQVM7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsSUFBSTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUUsNkNBQTZDLElBQUk7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQSx3Q0FBd0MsRUFBRTtBQUMxQzs7QUFFQSwyQkFBMkI7QUFDM0I7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBLDZCQUE2QixFQUFFO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDs7QUFFQSxnREFBZ0QsU0FBUyxJQUFJLElBQUk7QUFDakU7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQSx3REFBd0QsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjs7QUFFQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBLGlDQUFpQyxHQUFHLEdBQUcsZUFBZSxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7O0FBRUE7QUFDQSxzQ0FBc0MsRUFBRTtBQUN4Qzs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsMEJBQTBCLG1CQUFtQixJQUFJO0FBQ2pEOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsMEJBQTBCLFlBQVksRUFBRTtBQUN4Qzs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUEsMEJBQTBCLGFBQWEsRUFBRTtBQUN6Qzs7QUFFQSwwQkFBMEIsYUFBYSxFQUFFO0FBQ3pDOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQSw0QkFBNEIsY0FBYyxFQUFFO0FBQzVDLDBCQUEwQixvQ0FBb0MsRUFBRTtBQUNoRTs7QUFFQSwwQkFBMEIsY0FBYyxJQUFJO0FBQzVDOztBQUVBLDBCQUEwQixxQkFBcUIsSUFBSTtBQUNuRDs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsMEJBQTBCLCtCQUErQixJQUFJO0FBQzdEOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQSwwQkFBMEIsMkJBQTJCLEVBQUU7QUFDdkQ7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLElBQUk7QUFDakQ7O0FBRUEsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5Qjs7QUFFQSxvQ0FBb0M7QUFDcEM7O0FBRUEsa0NBQWtDLElBQUksRUFBRTtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixJQUFJLDZCQUE2QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGtCQUFrQiw4RUFBOEU7QUFDaEcsYUFBYSxTQUFTO0FBQ3RCLDBEQUEwRCx3Q0FBd0MsY0FBYyx3QkFBd0IsRUFBRTtBQUMxSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7O0FBR25DLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1wbGl0dWRlLWpzL2FtcGxpdHVkZS51bWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnYW1wbGl0dWRlJywgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5hbXBsaXR1ZGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2YXIgQ29uc3RhbnRzID0ge1xuICAgIERFRkFVTFRfSU5TVEFOQ0U6ICckZGVmYXVsdF9pbnN0YW5jZScsXG4gICAgQVBJX1ZFUlNJT046IDIsXG4gICAgTUFYX1NUUklOR19MRU5HVEg6IDQwOTYsXG4gICAgTUFYX1BST1BFUlRZX0tFWVM6IDEwMDAsXG4gICAgSURFTlRJRllfRVZFTlQ6ICckaWRlbnRpZnknLFxuICAgIEdST1VQX0lERU5USUZZX0VWRU5UOiAnJGdyb3VwaWRlbnRpZnknLFxuICAgIC8vIGxvY2FsU3RvcmFnZUtleXNcbiAgICBMQVNUX0VWRU5UX0lEOiAnYW1wbGl0dWRlX2xhc3RFdmVudElkJyxcbiAgICBMQVNUX0VWRU5UX1RJTUU6ICdhbXBsaXR1ZGVfbGFzdEV2ZW50VGltZScsXG4gICAgTEFTVF9JREVOVElGWV9JRDogJ2FtcGxpdHVkZV9sYXN0SWRlbnRpZnlJZCcsXG4gICAgTEFTVF9TRVFVRU5DRV9OVU1CRVI6ICdhbXBsaXR1ZGVfbGFzdFNlcXVlbmNlTnVtYmVyJyxcbiAgICBTRVNTSU9OX0lEOiAnYW1wbGl0dWRlX3Nlc3Npb25JZCcsXG4gICAgLy8gVXNlZCBpbiBjb29raWUgYXMgd2VsbFxuICAgIERFVklDRV9JRDogJ2FtcGxpdHVkZV9kZXZpY2VJZCcsXG4gICAgT1BUX09VVDogJ2FtcGxpdHVkZV9vcHRPdXQnLFxuICAgIFVTRVJfSUQ6ICdhbXBsaXR1ZGVfdXNlcklkJyxcbiAgICBDT09LSUVfVEVTVDogJ2FtcGxpdHVkZV9jb29raWVfdGVzdCcsXG4gICAgQ09PS0lFX1BSRUZJWDogXCJhbXBcIixcbiAgICAvLyByZXZlbnVlIGtleXNcbiAgICBSRVZFTlVFX0VWRU5UOiAncmV2ZW51ZV9hbW91bnQnLFxuICAgIFJFVkVOVUVfUFJPRFVDVF9JRDogJyRwcm9kdWN0SWQnLFxuICAgIFJFVkVOVUVfUVVBTlRJVFk6ICckcXVhbnRpdHknLFxuICAgIFJFVkVOVUVfUFJJQ0U6ICckcHJpY2UnLFxuICAgIFJFVkVOVUVfUkVWRU5VRV9UWVBFOiAnJHJldmVudWVUeXBlJyxcbiAgICBBTVBfREVWSUNFX0lEX1BBUkFNOiAnYW1wX2RldmljZV9pZCcsXG4gICAgLy8gdXJsIHBhcmFtXG4gICAgUkVGRVJSRVI6ICdyZWZlcnJlcicsXG4gICAgLy8gVVRNIFBhcmFtc1xuICAgIFVUTV9TT1VSQ0U6ICd1dG1fc291cmNlJyxcbiAgICBVVE1fTUVESVVNOiAndXRtX21lZGl1bScsXG4gICAgVVRNX0NBTVBBSUdOOiAndXRtX2NhbXBhaWduJyxcbiAgICBVVE1fVEVSTTogJ3V0bV90ZXJtJyxcbiAgICBVVE1fQ09OVEVOVDogJ3V0bV9jb250ZW50J1xuICB9O1xuXG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuXG4gIC8qXG4gICAqIFVURi04IGVuY29kZXIvZGVjb2RlclxuICAgKiBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby9cbiAgICovXG4gIHZhciBVVEY4ID0ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICAgIHZhciB1dGZ0ZXh0ID0gJyc7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChuKTtcblxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID4gMTI3ICYmIGMgPCAyMDQ4KSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPj4gNiB8IDE5Mik7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgJiA2MyB8IDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPj4gMTIgfCAyMjQpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjID4+IDYgJiA2MyB8IDEyOCk7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgJiA2MyB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHV0ZnRleHQ7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSh1dGZ0ZXh0KSB7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGMgPSAwLFxuICAgICAgICAgIGMxID0gMCxcbiAgICAgICAgICBjMiA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgdXRmdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHV0ZnRleHQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+IDE5MSAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgYzEgPSB1dGZ0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzEgJiA2Myk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMxID0gdXRmdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBjMiA9IHV0ZnRleHQuY2hhckNvZGVBdChpICsgMik7XG4gICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGMxICYgNjMpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9O1xuXG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAvKlxuICAgKiBCYXNlNjQgZW5jb2Rlci9kZWNvZGVyXG4gICAqIGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvL1xuICAgKi9cblxuICB2YXIgQmFzZTY0ID0ge1xuICAgIF9rZXlTdHI6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScsXG4gICAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYXRvYikge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHsvL2xvZyhlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2U2NC5fZW5jb2RlKGlucHV0KTtcbiAgICB9LFxuICAgIF9lbmNvZGU6IGZ1bmN0aW9uIF9lbmNvZGUoaW5wdXQpIHtcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaW5wdXQgPSBVVEY4LmVuY29kZShpbnB1dCk7XG5cbiAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNocjMgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoY2hyMSAmIDMpIDw8IDQgfCBjaHIyID4+IDQ7XG4gICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xuICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuXG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMSkgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMikgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMykgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jNCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHdpbmRvdy5idG9hICYmIHdpbmRvdy5hdG9iKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUod2luZG93LmF0b2IoaW5wdXQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHsvL2xvZyhlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2U2NC5fZGVjb2RlKGlucHV0KTtcbiAgICB9LFxuICAgIF9kZWNvZGU6IGZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGVuYzEgPSBCYXNlNjQuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IEJhc2U2NC5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gQmFzZTY0Ll9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBCYXNlNjQuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgY2hyMSA9IGVuYzEgPDwgMiB8IGVuYzIgPj4gNDtcbiAgICAgICAgY2hyMiA9IChlbmMyICYgMTUpIDw8IDQgfCBlbmMzID4+IDI7XG4gICAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCA9IFVURjguZGVjb2RlKG91dHB1dCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdG9TdHJpbmcgcmVmLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gdHlwZSAodmFsKSB7XG4gICAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6XG4gICAgICAgIHJldHVybiAnYXJndW1lbnRzJztcblxuICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICByZXR1cm4gJ2FycmF5JztcblxuICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT09IHZhbCkge1xuICAgICAgcmV0dXJuICduYW4nO1xuICAgIH1cblxuICAgIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gJ2VsZW1lbnQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgICByZXR1cm4gJ2J1ZmZlcic7XG4gICAgfVxuXG4gICAgdmFsID0gdmFsLnZhbHVlT2YgPyB2YWwudmFsdWVPZigpIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbCk7XG4gICAgcmV0dXJuIF90eXBlb2YodmFsKTtcbiAgfVxuXG4gIHZhciBsb2dMZXZlbHMgPSB7XG4gICAgRElTQUJMRTogMCxcbiAgICBFUlJPUjogMSxcbiAgICBXQVJOOiAyLFxuICAgIElORk86IDNcbiAgfTtcbiAgdmFyIGxvZ0xldmVsID0gbG9nTGV2ZWxzLldBUk47XG5cbiAgdmFyIHNldExvZ0xldmVsID0gZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWxOYW1lKSB7XG4gICAgaWYgKGxvZ0xldmVscy5oYXNPd25Qcm9wZXJ0eShsb2dMZXZlbE5hbWUpKSB7XG4gICAgICBsb2dMZXZlbCA9IGxvZ0xldmVsc1tsb2dMZXZlbE5hbWVdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gbG9nTGV2ZWw7XG4gIH07XG5cbiAgdmFyIGxvZyA9IHtcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3Iocykge1xuICAgICAgaWYgKGxvZ0xldmVsID49IGxvZ0xldmVscy5FUlJPUikge1xuICAgICAgICBfbG9nKHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybjogZnVuY3Rpb24gd2FybihzKSB7XG4gICAgICBpZiAobG9nTGV2ZWwgPj0gbG9nTGV2ZWxzLldBUk4pIHtcbiAgICAgICAgX2xvZyhzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluZm86IGZ1bmN0aW9uIGluZm8ocykge1xuICAgICAgaWYgKGxvZ0xldmVsID49IGxvZ0xldmVscy5JTkZPKSB7XG4gICAgICAgIF9sb2cocyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBfbG9nID0gZnVuY3Rpb24gX2xvZyhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQW1wbGl0dWRlXSAnICsgcyk7XG4gICAgfSBjYXRjaCAoZSkgey8vIGNvbnNvbGUgbG9nZ2luZyBub3QgYXZhaWxhYmxlXG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0VtcHR5U3RyaW5nID0gZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gIXN0ciB8fCBzdHIubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIHZhciBzZXNzaW9uU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXNzaW9uU3RvcmFnZUVuYWJsZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge30gLy8gc2Vzc2lvblN0b3JhZ2UgZGlzYWJsZWRcblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyB0cnVuY2F0ZSBzdHJpbmcgdmFsdWVzIGluIGV2ZW50IGFuZCB1c2VyIHByb3BlcnRpZXMgc28gdGhhdCByZXF1ZXN0IHNpemUgZG9lcyBub3QgZ2V0IHRvbyBsYXJnZVxuXG5cbiAgdmFyIHRydW5jYXRlID0gZnVuY3Rpb24gdHJ1bmNhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZSh2YWx1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0cnVuY2F0ZSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhbHVlW2tleV0gPSB0cnVuY2F0ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IF90cnVuY2F0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIF90cnVuY2F0ZVZhbHVlID0gZnVuY3Rpb24gX3RydW5jYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gQ29uc3RhbnRzLk1BWF9TVFJJTkdfTEVOR1RIID8gdmFsdWUuc3Vic3RyaW5nKDAsIENvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSCkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KGlucHV0LCBuYW1lLCBleHBlY3RlZFR5cGUpIHtcbiAgICBpZiAodHlwZShpbnB1dCkgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgbG9nLmVycm9yKCdJbnZhbGlkICcgKyBuYW1lICsgJyBpbnB1dCB0eXBlLiBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlICsgJyBidXQgcmVjZWl2ZWQgJyArIHR5cGUoaW5wdXQpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gZG8gc29tZSBiYXNpYyBzYW5pdGl6YXRpb24gYW5kIHR5cGUgY2hlY2tpbmcsIGFsc28gY2F0Y2ggcHJvcGVydHkgZGljdHMgd2l0aCBtb3JlIHRoYW4gMTAwMCBrZXkvdmFsdWUgcGFpcnNcblxuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIHZhciBwcm9wc1R5cGUgPSB0eXBlKHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHByb3BzVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3I6IGludmFsaWQgcHJvcGVydGllcyBmb3JtYXQuIEV4cGVjdGluZyBKYXZhc2NyaXB0IG9iamVjdCwgcmVjZWl2ZWQgJyArIHByb3BzVHlwZSArICcsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCA+IENvbnN0YW50cy5NQVhfUFJPUEVSVFlfS0VZUykge1xuICAgICAgbG9nLmVycm9yKCdFcnJvcjogdG9vIG1hbnkgcHJvcGVydGllcyAobW9yZSB0aGFuIDEwMDApLCBpZ25vcmluZycpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBjb3B5ID0ge307IC8vIGNyZWF0ZSBhIGNvcHkgd2l0aCBhbGwgb2YgdGhlIHZhbGlkIHByb3BlcnRpZXNcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICghcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHZhbGlkYXRlIGtleVxuXG5cbiAgICAgIHZhciBrZXkgPSBwcm9wZXJ0eTtcbiAgICAgIHZhciBrZXlUeXBlID0gdHlwZShrZXkpO1xuXG4gICAgICBpZiAoa2V5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAga2V5ID0gU3RyaW5nKGtleSk7XG4gICAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBOb24tc3RyaW5nIHByb3BlcnR5IGtleSwgcmVjZWl2ZWQgdHlwZSAnICsga2V5VHlwZSArICcsIGNvZXJjaW5nIHRvIHN0cmluZyBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH0gLy8gdmFsaWRhdGUgdmFsdWVcblxuXG4gICAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3BlcnR5VmFsdWUoa2V5LCBwcm9wZXJ0aWVzW3Byb3BlcnR5XSk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29weVtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgdmFyIGludmFsaWRWYWx1ZVR5cGVzID0gWyduYW4nLCAnZnVuY3Rpb24nLCAnYXJndW1lbnRzJywgJ3JlZ2V4cCcsICdlbGVtZW50J107XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlVHlwZSA9IHR5cGUodmFsdWUpO1xuXG4gICAgaWYgKGludmFsaWRWYWx1ZVR5cGVzLmluZGV4T2YodmFsdWVUeXBlKSAhPT0gLTEpIHtcbiAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBQcm9wZXJ0eSBrZXkgXCInICsga2V5ICsgJ1wiIHdpdGggaW52YWxpZCB2YWx1ZSB0eXBlICcgKyB2YWx1ZVR5cGUgKyAnLCBpZ25vcmluZycpO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnZXJyb3InKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICBsb2cud2FybignV0FSTklORzogUHJvcGVydHkga2V5IFwiJyArIGtleSArICdcIiB3aXRoIHZhbHVlIHR5cGUgZXJyb3IsIGNvZXJjaW5nIHRvICcgKyB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBuZXN0ZWQgYXJyYXlzIG9yIG9iamVjdHNcbiAgICAgIHZhciBhcnJheUNvcHkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHZhbHVlW2ldO1xuICAgICAgICB2YXIgZWxlbVR5cGUgPSB0eXBlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChlbGVtVHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBDYW5ub3QgaGF2ZSAnICsgZWxlbVR5cGUgKyAnIG5lc3RlZCBpbiBhbiBhcnJheSBwcm9wZXJ0eSB2YWx1ZSwgc2tpcHBpbmcnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhcnJheUNvcHkucHVzaCh2YWxpZGF0ZVByb3BlcnRpZXMoZWxlbWVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5Q29weS5wdXNoKHZhbGlkYXRlUHJvcGVydHlWYWx1ZShrZXksIGVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGFycmF5Q29weTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbHVlID0gdmFsaWRhdGVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlR3JvdXBzID0gZnVuY3Rpb24gdmFsaWRhdGVHcm91cHMoZ3JvdXBzKSB7XG4gICAgdmFyIGdyb3Vwc1R5cGUgPSB0eXBlKGdyb3Vwcyk7XG5cbiAgICBpZiAoZ3JvdXBzVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3I6IGludmFsaWQgZ3JvdXBzIGZvcm1hdC4gRXhwZWN0aW5nIEphdmFzY3JpcHQgb2JqZWN0LCByZWNlaXZlZCAnICsgZ3JvdXBzVHlwZSArICcsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGNvcHkgPSB7fTsgLy8gY3JlYXRlIGEgY29weSB3aXRoIGFsbCBvZiB0aGUgdmFsaWQgcHJvcGVydGllc1xuXG4gICAgZm9yICh2YXIgZ3JvdXAgaW4gZ3JvdXBzKSB7XG4gICAgICBpZiAoIWdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHZhbGlkYXRlIGtleVxuXG5cbiAgICAgIHZhciBrZXkgPSBncm91cDtcbiAgICAgIHZhciBrZXlUeXBlID0gdHlwZShrZXkpO1xuXG4gICAgICBpZiAoa2V5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAga2V5ID0gU3RyaW5nKGtleSk7XG4gICAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBOb24tc3RyaW5nIGdyb3VwVHlwZSwgcmVjZWl2ZWQgdHlwZSAnICsga2V5VHlwZSArICcsIGNvZXJjaW5nIHRvIHN0cmluZyBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH0gLy8gdmFsaWRhdGUgdmFsdWVcblxuXG4gICAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZUdyb3VwTmFtZShrZXksIGdyb3Vwc1tncm91cF0pO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvcHlba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZUdyb3VwTmFtZSA9IGZ1bmN0aW9uIHZhbGlkYXRlR3JvdXBOYW1lKGtleSwgZ3JvdXBOYW1lKSB7XG4gICAgdmFyIGdyb3VwTmFtZVR5cGUgPSB0eXBlKGdyb3VwTmFtZSk7XG5cbiAgICBpZiAoZ3JvdXBOYW1lVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBncm91cE5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwTmFtZVR5cGUgPT09ICdkYXRlJyB8fCBncm91cE5hbWVUeXBlID09PSAnbnVtYmVyJyB8fCBncm91cE5hbWVUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGdyb3VwTmFtZSA9IFN0cmluZyhncm91cE5hbWUpO1xuICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IE5vbi1zdHJpbmcgZ3JvdXBOYW1lLCByZWNlaXZlZCB0eXBlICcgKyBncm91cE5hbWVUeXBlICsgJywgY29lcmNpbmcgdG8gc3RyaW5nIFwiJyArIGdyb3VwTmFtZSArICdcIicpO1xuICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBOYW1lVHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBhcnJheXMgb3Igb2JqZWN0c1xuICAgICAgdmFyIGFycmF5Q29weSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwTmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGdyb3VwTmFtZVtpXTtcbiAgICAgICAgdmFyIGVsZW1UeXBlID0gdHlwZShlbGVtZW50KTtcblxuICAgICAgICBpZiAoZWxlbVR5cGUgPT09ICdhcnJheScgfHwgZWxlbVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IFNraXBwaW5nIG5lc3RlZCAnICsgZWxlbVR5cGUgKyAnIGluIGFycmF5IGdyb3VwTmFtZScpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFycmF5Q29weS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1UeXBlID09PSAnZGF0ZScgfHwgZWxlbVR5cGUgPT09ICdudW1iZXInIHx8IGVsZW1UeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBlbGVtZW50ID0gU3RyaW5nKGVsZW1lbnQpO1xuICAgICAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBOb24tc3RyaW5nIGdyb3VwTmFtZSwgcmVjZWl2ZWQgdHlwZSAnICsgZWxlbVR5cGUgKyAnLCBjb2VyY2luZyB0byBzdHJpbmcgXCInICsgZWxlbWVudCArICdcIicpO1xuICAgICAgICAgIGFycmF5Q29weS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheUNvcHk7XG4gICAgfVxuXG4gICAgbG9nLndhcm4oJ1dBUk5JTkc6IE5vbi1zdHJpbmcgZ3JvdXBOYW1lLCByZWNlaXZlZCB0eXBlICcgKyBncm91cE5hbWVUeXBlICsgJy4gUGxlYXNlIHVzZSBzdHJpbmdzIG9yIGFycmF5IG9mIHN0cmluZ3MgZm9yIGdyb3VwTmFtZScpO1xuICB9OyAvLyBwYXJzZXMgdGhlIHZhbHVlIG9mIGEgdXJsIHBhcmFtIChmb3IgZXhhbXBsZSA/Z2NsaWQ9MTIzNCYuLi4pXG5cblxuICB2YXIgZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uIGdldFF1ZXJ5UGFyYW0obmFtZSwgcXVlcnkpIHtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sIFwiXFxcXFtcIikucmVwbGFjZSgvW1xcXV0vLCBcIlxcXFxdXCIpO1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJbXFxcXD8mXVwiICsgbmFtZSArIFwiPShbXiYjXSopXCIpO1xuICAgIHZhciByZXN1bHRzID0gcmVnZXguZXhlYyhxdWVyeSk7XG4gICAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyB1bmRlZmluZWQgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbiAgfTtcblxuICB2YXIgdXRpbHMgPSB7XG4gICAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsLFxuICAgIGdldExvZ0xldmVsOiBnZXRMb2dMZXZlbCxcbiAgICBsb2dMZXZlbHM6IGxvZ0xldmVscyxcbiAgICBsb2c6IGxvZyxcbiAgICBpc0VtcHR5U3RyaW5nOiBpc0VtcHR5U3RyaW5nLFxuICAgIGdldFF1ZXJ5UGFyYW06IGdldFF1ZXJ5UGFyYW0sXG4gICAgc2Vzc2lvblN0b3JhZ2VFbmFibGVkOiBzZXNzaW9uU3RvcmFnZUVuYWJsZWQsXG4gICAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICAgIHZhbGlkYXRlR3JvdXBzOiB2YWxpZGF0ZUdyb3VwcyxcbiAgICB2YWxpZGF0ZUlucHV0OiB2YWxpZGF0ZUlucHV0LFxuICAgIHZhbGlkYXRlUHJvcGVydGllczogdmFsaWRhdGVQcm9wZXJ0aWVzXG4gIH07XG5cbiAgdmFyIGdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjtcbiAgfTtcblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2FbaV07XG5cbiAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lKSA9PT0gMCkge1xuICAgICAgICAgIHZhbHVlID0gYy5zdWJzdHJpbmcobmFtZS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXQyID0gZnVuY3Rpb24gZ2V0MihuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNhW2ldO1xuXG4gICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLmluZGV4T2YobmFtZSkgPT09IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGMuc3Vic3RyaW5nKG5hbWUubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBcImVycm9yIFwiLmNvbmNhdChlLm1zZylcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHZhciBzZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUsIG9wdHMpIHtcbiAgICB2YXIgZXhwaXJlcyA9IHZhbHVlICE9PSBudWxsID8gb3B0cy5leHBpcmF0aW9uRGF5cyA6IC0xO1xuXG4gICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIGV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgIGV4cGlyZXMgPSBkYXRlO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBuYW1lICsgJz0nICsgdmFsdWU7XG5cbiAgICBpZiAoZXhwaXJlcykge1xuICAgICAgc3RyICs9ICc7IGV4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgcGF0aD0vJztcblxuICAgIGlmIChvcHRzLmRvbWFpbikge1xuICAgICAgc3RyICs9ICc7IGRvbWFpbj0nICsgb3B0cy5kb21haW47XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VjdXJlKSB7XG4gICAgICBzdHIgKz0gJzsgU2VjdXJlJztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zYW1lU2l0ZSkge1xuICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPScgKyBvcHRzLnNhbWVTaXRlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmNvb2tpZSA9IHN0cjtcbiAgfTsgLy8gdGVzdCB0aGF0IGNvb2tpZXMgYXJlIGVuYWJsZWQgLSBuYXZpZ2F0b3IuY29va2llc0VuYWJsZWQgeWllbGRzIGZhbHNlIHBvc2l0aXZlcyBpbiBJRSwgbmVlZCB0byB0ZXN0IGRpcmVjdGx5XG5cblxuICB2YXIgYXJlQ29va2llc0VuYWJsZWQgPSBmdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcbiAgICB2YXIgdWlkID0gU3RyaW5nKG5ldyBEYXRlKCkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldChDb25zdGFudHMuQ09PS0lFX1RFU1QsIHVpZCwge30pO1xuXG4gICAgICB2YXIgX2FyZUNvb2tpZXNFbmFibGVkID0gZ2V0KENvbnN0YW50cy5DT09LSUVfVEVTVCArICc9JykgPT09IHVpZDtcblxuICAgICAgc2V0KENvbnN0YW50cy5DT09LSUVfVEVTVCwgbnVsbCwge30pO1xuICAgICAgcmV0dXJuIF9hcmVDb29raWVzRW5hYmxlZDtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBiYXNlQ29va2llID0ge1xuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0LFxuICAgIGdldDI6IGdldDIsXG4gICAgYXJlQ29va2llc0VuYWJsZWQ6IGFyZUNvb2tpZXNFbmFibGVkXG4gIH07XG5cbiAgdmFyIGdldEhvc3QgPSBmdW5jdGlvbiBnZXRIb3N0KHVybCkge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5ob3N0bmFtZSB8fCBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgfTtcblxuICB2YXIgdG9wRG9tYWluID0gZnVuY3Rpb24gdG9wRG9tYWluKHVybCkge1xuICAgIHZhciBob3N0ID0gZ2V0SG9zdCh1cmwpO1xuICAgIHZhciBwYXJ0cyA9IGhvc3Quc3BsaXQoJy4nKTtcbiAgICB2YXIgbGV2ZWxzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGxldmVscy5wdXNoKHBhcnRzLnNsaWNlKGkpLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxldmVscy5sZW5ndGg7ICsrX2kpIHtcbiAgICAgIHZhciBjbmFtZSA9ICdfX3RsZF90ZXN0X18nO1xuICAgICAgdmFyIGRvbWFpbiA9IGxldmVsc1tfaV07XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgZG9tYWluOiAnLicgKyBkb21haW5cbiAgICAgIH07XG4gICAgICBiYXNlQ29va2llLnNldChjbmFtZSwgMSwgb3B0cyk7XG5cbiAgICAgIGlmIChiYXNlQ29va2llLmdldChjbmFtZSkpIHtcbiAgICAgICAgYmFzZUNvb2tpZS5zZXQoY25hbWUsIG51bGwsIG9wdHMpO1xuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKlxuICAgKiBDb29raWUgZGF0YVxuICAgKi9cbiAgdmFyIF9vcHRpb25zID0ge1xuICAgIGV4cGlyYXRpb25EYXlzOiB1bmRlZmluZWQsXG4gICAgZG9tYWluOiB1bmRlZmluZWRcbiAgfTtcblxuICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBfb3B0aW9ucyA9IHtcbiAgICAgIGV4cGlyYXRpb25EYXlzOiB1bmRlZmluZWQsXG4gICAgICBkb21haW46IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIG9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9vcHRpb25zO1xuICAgIH1cblxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIF9vcHRpb25zLmV4cGlyYXRpb25EYXlzID0gb3B0cy5leHBpcmF0aW9uRGF5cztcbiAgICBfb3B0aW9ucy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgICBfb3B0aW9ucy5zYW1lU2l0ZSA9IG9wdHMuc2FtZVNpdGU7XG4gICAgdmFyIGRvbWFpbiA9ICF1dGlscy5pc0VtcHR5U3RyaW5nKG9wdHMuZG9tYWluKSA/IG9wdHMuZG9tYWluIDogJy4nICsgdG9wRG9tYWluKGdldExvY2F0aW9uKCkuaHJlZik7XG4gICAgdmFyIHRva2VuID0gTWF0aC5yYW5kb20oKTtcbiAgICBfb3B0aW9ucy5kb21haW4gPSBkb21haW47XG4gICAgc2V0JDEoJ2FtcGxpdHVkZV90ZXN0JywgdG9rZW4pO1xuICAgIHZhciBzdG9yZWQgPSBnZXQkMSgnYW1wbGl0dWRlX3Rlc3QnKTtcblxuICAgIGlmICghc3RvcmVkIHx8IHN0b3JlZCAhPT0gdG9rZW4pIHtcbiAgICAgIGRvbWFpbiA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVtb3ZlKCdhbXBsaXR1ZGVfdGVzdCcpO1xuICAgIF9vcHRpb25zLmRvbWFpbiA9IGRvbWFpbjtcbiAgICByZXR1cm4gX29wdGlvbnM7XG4gIH07XG5cbiAgdmFyIF9kb21haW5TcGVjaWZpYyA9IGZ1bmN0aW9uIF9kb21haW5TcGVjaWZpYyhuYW1lKSB7XG4gICAgLy8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGNvb2tpZXMgb24gZGlmZmVyZW50IGRvbWFpbnNcbiAgICB2YXIgc3VmZml4ID0gJyc7XG5cbiAgICBpZiAoX29wdGlvbnMuZG9tYWluKSB7XG4gICAgICBzdWZmaXggPSBfb3B0aW9ucy5kb21haW4uY2hhckF0KDApID09PSAnLicgPyBfb3B0aW9ucy5kb21haW4uc3Vic3RyaW5nKDEpIDogX29wdGlvbnMuZG9tYWluO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lICsgc3VmZml4O1xuICB9O1xuXG4gIHZhciBnZXQkMSA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFyIG5hbWVFcSA9IF9kb21haW5TcGVjaWZpYyhuYW1lKSArICc9JztcbiAgICB2YXIgdmFsdWUgPSBiYXNlQ29va2llLmdldChuYW1lRXEpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShCYXNlNjQuZGVjb2RlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIHNldCQxID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJhc2VDb29raWUuc2V0KF9kb21haW5TcGVjaWZpYyhuYW1lKSwgQmFzZTY0LmVuY29kZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLCBfb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzZXRSYXcgPSBmdW5jdGlvbiBzZXRSYXcobmFtZSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgYmFzZUNvb2tpZS5zZXQoX2RvbWFpblNwZWNpZmljKG5hbWUpLCB2YWx1ZSwgX29wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0UmF3ID0gZnVuY3Rpb24gZ2V0UmF3KG5hbWUpIHtcbiAgICB2YXIgbmFtZUVxID0gX2RvbWFpblNwZWNpZmljKG5hbWUpICsgJz0nO1xuICAgIHJldHVybiBiYXNlQ29va2llLmdldChuYW1lRXEpO1xuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBiYXNlQ29va2llLnNldChfZG9tYWluU3BlY2lmaWMobmFtZSksIG51bGwsIF9vcHRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENvb2tpZSA9IHtcbiAgICByZXNldDogcmVzZXQsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBnZXQ6IGdldCQxLFxuICAgIHNldDogc2V0JDEsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgc2V0UmF3OiBzZXRSYXcsXG4gICAgZ2V0UmF3OiBnZXRSYXdcbiAgfTtcblxuICAvKiBqc2hpbnQgLVcwMjAsIHVudXNlZDogZmFsc2UsIG5vZW1wdHk6IGZhbHNlLCBib3NzOiB0cnVlICovXG5cbiAgLypcbiAgICogSW1wbGVtZW50IGxvY2FsU3RvcmFnZSB0byBzdXBwb3J0IEZpcmVmb3ggMi0zIGFuZCBJRSA1LTdcbiAgICovXG4gIHZhciBsb2NhbFN0b3JhZ2U7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gIHtcbiAgICAvLyB0ZXN0IHRoYXQgV2luZG93LmxvY2FsU3RvcmFnZSBpcyBhdmFpbGFibGUgYW5kIHdvcmtzXG4gICAgdmFyIHdpbmRvd0xvY2FsU3RvcmFnZUF2YWlsYWJsZSA9IGZ1bmN0aW9uIHdpbmRvd0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpIHtcbiAgICAgIHZhciB1aWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHVpZCwgdWlkKTtcbiAgICAgICAgcmVzdWx0ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHVpZCkgPT09IFN0cmluZyh1aWQpO1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odWlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUpIHsvLyBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmICh3aW5kb3dMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgbG9jYWxTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5nbG9iYWxTdG9yYWdlKSB7XG4gICAgICAvLyBGaXJlZm94IDItMyB1c2UgZ2xvYmFsU3RvcmFnZVxuICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvbS9zdG9yYWdlI2dsb2JhbFN0b3JhZ2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5nbG9iYWxTdG9yYWdlW3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZV07XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gU29tZXRoaW5nIGJhZCBoYXBwZW5lZC4uLlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSUUgNS03IHVzZSB1c2VyRGF0YVxuICAgICAgLy8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTQyNCh2PXZzLjg1KS5hc3B4XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgYXR0cktleSA9ICdsb2NhbFN0b3JhZ2UnO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgIGlmIChkaXYuYWRkQmVoYXZpb3IpIHtcbiAgICAgICAgZGl2LmFkZEJlaGF2aW9yKCcjZGVmYXVsdCN1c2VyZGF0YScpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UgPSB7XG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uIHNldEl0ZW0oaywgdikge1xuICAgICAgICAgICAgZGl2LmxvYWQoYXR0cktleSk7XG5cbiAgICAgICAgICAgIGlmICghZGl2LmdldEF0dHJpYnV0ZShrKSkge1xuICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgICAgICAgZGl2LnNhdmUoYXR0cktleSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKGspIHtcbiAgICAgICAgICAgIGRpdi5sb2FkKGF0dHJLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoayk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiByZW1vdmVJdGVtKGspIHtcbiAgICAgICAgICAgIGRpdi5sb2FkKGF0dHJLZXkpO1xuXG4gICAgICAgICAgICBpZiAoZGl2LmdldEF0dHJpYnV0ZShrKSkge1xuICAgICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYucmVtb3ZlQXR0cmlidXRlKGspO1xuICAgICAgICAgICAgZGl2LnNhdmUoYXR0cktleSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBhdHRyO1xuXG4gICAgICAgICAgICB3aGlsZSAoYXR0ciA9IGRpdi5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1tpKytdKSB7XG4gICAgICAgICAgICAgIGRpdi5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGl2LnNhdmUoYXR0cktleSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXk6IGZ1bmN0aW9uIGtleShrKSB7XG4gICAgICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkaXYuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNba107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLmxlbmd0aCA9IGRpdi5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFsb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGxvY2FsU3RvcmFnZSA9IHtcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiBzZXRJdGVtKGssIHYpIHt9LFxuICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKGspIHt9LFxuICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiByZW1vdmVJdGVtKGspIHt9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7fSxcbiAgICAgICAga2V5OiBmdW5jdGlvbiBrZXkoaykge31cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGxvY2FsU3RvcmFnZSQxID0gbG9jYWxTdG9yYWdlO1xuXG4gIC8qIGpzaGludCAtVzAyMCwgdW51c2VkOiBmYWxzZSwgbm9lbXB0eTogZmFsc2UsIGJvc3M6IHRydWUgKi9cblxuICB2YXIgY29va2llU3RvcmFnZSA9IGZ1bmN0aW9uIGNvb2tpZVN0b3JhZ2UoKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgfTsgLy8gdGVzdCB0aGF0IGNvb2tpZXMgYXJlIGVuYWJsZWQgLSBuYXZpZ2F0b3IuY29va2llc0VuYWJsZWQgeWllbGRzIGZhbHNlIHBvc2l0aXZlcyBpbiBJRSwgbmVlZCB0byB0ZXN0IGRpcmVjdGx5XG5cblxuICBjb29raWVTdG9yYWdlLnByb3RvdHlwZS5fY29va2llc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVpZCA9IFN0cmluZyhuZXcgRGF0ZSgpKTtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIENvb2tpZS5zZXQoQ29uc3RhbnRzLkNPT0tJRV9URVNULCB1aWQpO1xuICAgICAgcmVzdWx0ID0gQ29va2llLmdldChDb25zdGFudHMuQ09PS0lFX1RFU1QpID09PSB1aWQ7XG4gICAgICBDb29raWUucmVtb3ZlKENvbnN0YW50cy5DT09LSUVfVEVTVCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBjb29raWVzIGFyZSBub3QgZW5hYmxlZFxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBjb29raWVTdG9yYWdlLnByb3RvdHlwZS5nZXRTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nvb2tpZXNFbmFibGVkKCkpIHtcbiAgICAgIHRoaXMuc3RvcmFnZSA9IENvb2tpZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgY29va2llcyBkaXNhYmxlZCwgZmFsbGJhY2sgdG8gbG9jYWxzdG9yYWdlXG4gICAgICAvLyBub3RlOiBsb2NhbHN0b3JhZ2UgZG9lcyBub3QgcGVyc2lzdCBhY3Jvc3Mgc3ViZG9tYWluc1xuICAgICAgdmFyIGtleVByZWZpeCA9ICdhbXBfY29va2llc3RvcmVfJztcbiAgICAgIHRoaXMuc3RvcmFnZSA9IHtcbiAgICAgICAgX29wdGlvbnM6IHtcbiAgICAgICAgICBleHBpcmF0aW9uRGF5czogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbWFpbjogdW5kZWZpbmVkLFxuICAgICAgICAgIHNlY3VyZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBleHBpcmF0aW9uRGF5czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN1cmU6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucyhvcHRzKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMuZXhwaXJhdGlvbkRheXMgPSBvcHRzLmV4cGlyYXRpb25EYXlzIHx8IHRoaXMuX29wdGlvbnMuZXhwaXJhdGlvbkRheXM7IC8vIGxvY2FsU3RvcmFnZSBpcyBzcGVjaWZpYyB0byBzdWJkb21haW5zXG5cbiAgICAgICAgICB0aGlzLl9vcHRpb25zLmRvbWFpbiA9IG9wdHMuZG9tYWluIHx8IHRoaXMuX29wdGlvbnMuZG9tYWluIHx8IHdpbmRvdyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNlY3VyZSA9IG9wdHMuc2VjdXJlIHx8IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZSQxLmdldEl0ZW0oa2V5UHJlZml4ICsgbmFtZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlJDEuc2V0SXRlbShrZXlQcmVmaXggKyBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UkMS5yZW1vdmVJdGVtKGtleVByZWZpeCArIG5hbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZTtcbiAgfTtcblxuICB2YXIgTWV0YWRhdGFTdG9yYWdlID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0YWRhdGFTdG9yYWdlKF9yZWYpIHtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gX3JlZi5zdG9yYWdlS2V5LFxuICAgICAgICAgIGRpc2FibGVDb29raWVzID0gX3JlZi5kaXNhYmxlQ29va2llcyxcbiAgICAgICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgICAgICBzZWN1cmUgPSBfcmVmLnNlY3VyZSxcbiAgICAgICAgICBzYW1lU2l0ZSA9IF9yZWYuc2FtZVNpdGUsXG4gICAgICAgICAgZXhwaXJhdGlvbkRheXMgPSBfcmVmLmV4cGlyYXRpb25EYXlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWV0YWRhdGFTdG9yYWdlKTtcblxuICAgICAgdGhpcy5ibGFua0Nvb2tpZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICAgIHRoaXMuZGlzYWJsZUNvb2tpZVN0b3JhZ2UgPSAhYmFzZUNvb2tpZS5hcmVDb29raWVzRW5hYmxlZCgpIHx8IGRpc2FibGVDb29raWVzO1xuICAgICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZTtcbiAgICAgIHRoaXMuc2FtZVNpdGUgPSBzYW1lU2l0ZTtcbiAgICAgIHRoaXMuZXhwaXJhdGlvbkRheXMgPSBleHBpcmF0aW9uRGF5cztcbiAgICAgIHRoaXMuY29va2llRG9tYWluID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIHdyaXRhYmxlVG9wRG9tYWluID0gdG9wRG9tYWluKGdldExvY2F0aW9uKCkuaHJlZik7XG4gICAgICAgIHRoaXMuY29va2llRG9tYWluID0gZG9tYWluIHx8ICh3cml0YWJsZVRvcERvbWFpbiA/ICcuJyArIHdyaXRhYmxlVG9wRG9tYWluIDogbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1ldGFkYXRhU3RvcmFnZSwgW3tcbiAgICAgIGtleTogXCJnZXRDb29raWVTdG9yYWdlS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29va2llU3RvcmFnZUtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbWFpbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VLZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VmZml4ID0gdGhpcy5kb21haW4uY2hhckF0KDApID09PSAnLicgPyB0aGlzLmRvbWFpbi5zdWJzdHJpbmcoMSkgOiB0aGlzLmRvbWFpbjtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc3RvcmFnZUtleSkuY29uY2F0KHN1ZmZpeCA/IFwiX1wiLmNvbmNhdChzdWZmaXgpIDogJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzYXZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZShfcmVmMikge1xuICAgICAgICB2YXIgZGV2aWNlSWQgPSBfcmVmMi5kZXZpY2VJZCxcbiAgICAgICAgICAgIHVzZXJJZCA9IF9yZWYyLnVzZXJJZCxcbiAgICAgICAgICAgIG9wdE91dCA9IF9yZWYyLm9wdE91dCxcbiAgICAgICAgICAgIHNlc3Npb25JZCA9IF9yZWYyLnNlc3Npb25JZCxcbiAgICAgICAgICAgIGxhc3RFdmVudFRpbWUgPSBfcmVmMi5sYXN0RXZlbnRUaW1lLFxuICAgICAgICAgICAgZXZlbnRJZCA9IF9yZWYyLmV2ZW50SWQsXG4gICAgICAgICAgICBpZGVudGlmeUlkID0gX3JlZjIuaWRlbnRpZnlJZCxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyID0gX3JlZjIuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIC8vIGRvIG5vdCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZXNlIGl0ZW1zXG4gICAgICAgIHZhciB2YWx1ZSA9IFtkZXZpY2VJZCwgQmFzZTY0LmVuY29kZSh1c2VySWQgfHwgJycpLCBvcHRPdXQgPyAnMScgOiAnJywgc2Vzc2lvbklkID8gc2Vzc2lvbklkLnRvU3RyaW5nKDMyKSA6ICcwJywgbGFzdEV2ZW50VGltZSA/IGxhc3RFdmVudFRpbWUudG9TdHJpbmcoMzIpIDogJzAnLCBldmVudElkID8gZXZlbnRJZC50b1N0cmluZygzMikgOiAnMCcsIGlkZW50aWZ5SWQgPyBpZGVudGlmeUlkLnRvU3RyaW5nKDMyKSA6ICcwJywgc2VxdWVuY2VOdW1iZXIgPyBzZXF1ZW5jZU51bWJlci50b1N0cmluZygzMikgOiAnMCddLmpvaW4oJy4nKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ29va2llU3RvcmFnZSkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZSQxLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUNvb2tpZS5zZXQodGhpcy5nZXRDb29raWVTdG9yYWdlS2V5KCksIHZhbHVlLCB7XG4gICAgICAgICAgICBkb21haW46IHRoaXMuY29va2llRG9tYWluLFxuICAgICAgICAgICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICAgICAgICAgIHNhbWVTaXRlOiB0aGlzLnNhbWVTaXRlLFxuICAgICAgICAgICAgZXhwaXJhdGlvbkRheXM6IHRoaXMuZXhwaXJhdGlvbkRheXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmdldENvb2tpZVN0b3JhZ2VLZXkoKSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICB2YXIgc3RyO1xuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ29va2llU3RvcmFnZSkge1xuICAgICAgICAgIHN0ciA9IGJhc2VDb29raWUuZ2V0Mih0aGlzLmdldENvb2tpZVN0b3JhZ2VLZXkoKSArICc9Jyk7XG5cbiAgICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgdGhpcy5ibGFua0Nvb2tpZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0ciAmJiBfdHlwZW9mKHN0cikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmNvb2tpZUVycm9yID0gc3RyLmVycm9yO1xuICAgICAgICAgICAgc3RyID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICBzdHIgPSBsb2NhbFN0b3JhZ2UkMS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgdXNlcklkID0gbnVsbDtcblxuICAgICAgICBpZiAodmFsdWVzWzFdKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVzZXJJZCA9IEJhc2U2NC5kZWNvZGUodmFsdWVzWzFdKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1c2VySWQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGV2aWNlSWQ6IHZhbHVlc1swXSxcbiAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICBvcHRPdXQ6IHZhbHVlc1syXSA9PT0gJzEnLFxuICAgICAgICAgIHNlc3Npb25JZDogcGFyc2VJbnQodmFsdWVzWzNdLCAzMiksXG4gICAgICAgICAgbGFzdEV2ZW50VGltZTogcGFyc2VJbnQodmFsdWVzWzRdLCAzMiksXG4gICAgICAgICAgZXZlbnRJZDogcGFyc2VJbnQodmFsdWVzWzVdLCAzMiksXG4gICAgICAgICAgaWRlbnRpZnlJZDogcGFyc2VJbnQodmFsdWVzWzZdLCAzMiksXG4gICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IHBhcnNlSW50KHZhbHVlc1s3XSwgMzIpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1ldGFkYXRhU3RvcmFnZTtcbiAgfSgpO1xuXG4gIHZhciBnZXRVdG1EYXRhID0gZnVuY3Rpb24gZ2V0VXRtRGF0YShyYXdDb29raWUsIHF1ZXJ5KSB7XG4gICAgLy8gVHJhbnNsYXRlIHRoZSB1dG16IGNvb2tpZSBmb3JtYXQgaW50byB1cmwgcXVlcnkgc3RyaW5nIGZvcm1hdC5cbiAgICB2YXIgY29va2llID0gcmF3Q29va2llID8gJz8nICsgcmF3Q29va2llLnNwbGl0KCcuJykuc2xpY2UoLTEpWzBdLnJlcGxhY2UoL1xcfC9nLCAnJicpIDogJyc7XG5cbiAgICB2YXIgZmV0Y2hQYXJhbSA9IGZ1bmN0aW9uIGZldGNoUGFyYW0ocXVlcnlOYW1lLCBxdWVyeSwgY29va2llTmFtZSwgY29va2llKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZ2V0UXVlcnlQYXJhbShxdWVyeU5hbWUsIHF1ZXJ5KSB8fCB1dGlscy5nZXRRdWVyeVBhcmFtKGNvb2tpZU5hbWUsIGNvb2tpZSk7XG4gICAgfTtcblxuICAgIHZhciB1dG1Tb3VyY2UgPSBmZXRjaFBhcmFtKENvbnN0YW50cy5VVE1fU09VUkNFLCBxdWVyeSwgJ3V0bWNzcicsIGNvb2tpZSk7XG4gICAgdmFyIHV0bU1lZGl1bSA9IGZldGNoUGFyYW0oQ29uc3RhbnRzLlVUTV9NRURJVU0sIHF1ZXJ5LCAndXRtY21kJywgY29va2llKTtcbiAgICB2YXIgdXRtQ2FtcGFpZ24gPSBmZXRjaFBhcmFtKENvbnN0YW50cy5VVE1fQ0FNUEFJR04sIHF1ZXJ5LCAndXRtY2NuJywgY29va2llKTtcbiAgICB2YXIgdXRtVGVybSA9IGZldGNoUGFyYW0oQ29uc3RhbnRzLlVUTV9URVJNLCBxdWVyeSwgJ3V0bWN0cicsIGNvb2tpZSk7XG4gICAgdmFyIHV0bUNvbnRlbnQgPSBmZXRjaFBhcmFtKENvbnN0YW50cy5VVE1fQ09OVEVOVCwgcXVlcnksICd1dG1jY3QnLCBjb29raWUpO1xuICAgIHZhciB1dG1EYXRhID0ge307XG5cbiAgICB2YXIgYWRkSWZOb3ROdWxsID0gZnVuY3Rpb24gYWRkSWZOb3ROdWxsKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghdXRpbHMuaXNFbXB0eVN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdXRtRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZElmTm90TnVsbChDb25zdGFudHMuVVRNX1NPVVJDRSwgdXRtU291cmNlKTtcbiAgICBhZGRJZk5vdE51bGwoQ29uc3RhbnRzLlVUTV9NRURJVU0sIHV0bU1lZGl1bSk7XG4gICAgYWRkSWZOb3ROdWxsKENvbnN0YW50cy5VVE1fQ0FNUEFJR04sIHV0bUNhbXBhaWduKTtcbiAgICBhZGRJZk5vdE51bGwoQ29uc3RhbnRzLlVUTV9URVJNLCB1dG1UZXJtKTtcbiAgICBhZGRJZk5vdE51bGwoQ29uc3RhbnRzLlVUTV9DT05URU5ULCB1dG1Db250ZW50KTtcbiAgICByZXR1cm4gdXRtRGF0YTtcbiAgfTtcblxuICAvKlxuICAgKiBXcmFwcGVyIGZvciBhIHVzZXIgcHJvcGVydGllcyBKU09OIG9iamVjdCB0aGF0IHN1cHBvcnRzIG9wZXJhdGlvbnMuXG4gICAqIE5vdGU6IGlmIGEgdXNlciBwcm9wZXJ0eSBpcyB1c2VkIGluIG11bHRpcGxlIG9wZXJhdGlvbnMgb24gdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LFxuICAgKiBvbmx5IHRoZSBmaXJzdCBvcGVyYXRpb24gd2lsbCBiZSBzYXZlZCwgYW5kIHRoZSByZXN0IHdpbGwgYmUgaWdub3JlZC5cbiAgICovXG5cbiAgdmFyIEFNUF9PUF9BREQgPSAnJGFkZCc7XG4gIHZhciBBTVBfT1BfQVBQRU5EID0gJyRhcHBlbmQnO1xuICB2YXIgQU1QX09QX0NMRUFSX0FMTCA9ICckY2xlYXJBbGwnO1xuICB2YXIgQU1QX09QX1BSRVBFTkQgPSAnJHByZXBlbmQnO1xuICB2YXIgQU1QX09QX1NFVCA9ICckc2V0JztcbiAgdmFyIEFNUF9PUF9TRVRfT05DRSA9ICckc2V0T25jZSc7XG4gIHZhciBBTVBfT1BfVU5TRVQgPSAnJHVuc2V0JztcbiAgLyoqXG4gICAqIElkZW50aWZ5IEFQSSAtIGluc3RhbmNlIGNvbnN0cnVjdG9yLiBJZGVudGlmeSBvYmplY3RzIGFyZSBhIHdyYXBwZXIgZm9yIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9ucy5cbiAgICogRWFjaCBtZXRob2QgYWRkcyBhIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9uIHRvIHRoZSBJZGVudGlmeSBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBzYW1lIElkZW50aWZ5IG9iamVjdCxcbiAgICogYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogTm90ZTogaWYgdGhlIHNhbWUgdXNlciBwcm9wZXJ0eSBpcyB1c2VkIGluIG11bHRpcGxlIG9wZXJhdGlvbnMgb24gYSBzaW5nbGUgSWRlbnRpZnkgb2JqZWN0LFxuICAgKiBvbmx5IHRoZSBmaXJzdCBvcGVyYXRpb24gb24gdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIHNhdmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN1c2VyLXByb3BlcnRpZXMtYW5kLXVzZXItcHJvcGVydHktb3BlcmF0aW9uc31cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgKiBAY29uc3RydWN0b3IgSWRlbnRpZnlcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCk7XG4gICAqL1xuXG4gIHZhciBJZGVudGlmeSA9IGZ1bmN0aW9uIElkZW50aWZ5KCkge1xuICAgIHRoaXMudXNlclByb3BlcnRpZXNPcGVyYXRpb25zID0ge307XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gW107IC8vIGtlZXAgdHJhY2sgb2Yga2V5cyB0aGF0IGhhdmUgYmVlbiBhZGRlZFxuICB9O1xuICAvKipcbiAgICogSW5jcmVtZW50IGEgdXNlciBwcm9wZXJ0eSBieSBhIGdpdmVuIHZhbHVlIChjYW4gYWxzbyBiZSBuZWdhdGl2ZSB0byBkZWNyZW1lbnQpLlxuICAgKiBJZiB0aGUgdXNlciBwcm9wZXJ0eSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUgc2V0IHlldCwgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB0byAwIGJlZm9yZSBiZWluZyBpbmNyZW1lbnRlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGluY3JlbWVudCB0aGUgdXNlciBwcm9wZXJ0eS4gQWxsb3dzIG51bWJlcnMgYXMgc3RyaW5ncyAoZXg6ICcxMjMnKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuYWRkKCdrYXJtYScsIDEpLmFkZCgnZnJpZW5kcycsIDEpO1xuICAgKiBhbXBsaXR1ZGUuaWRlbnRpZnkoaWRlbnRpZnkpOyAvLyBzZW5kIHRoZSBJZGVudGlmeSBjYWxsXG4gICAqL1xuXG5cbiAgSWRlbnRpZnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSh2YWx1ZSkgPT09ICdudW1iZXInIHx8IHR5cGUodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYWRkT3BlcmF0aW9uKEFNUF9PUF9BREQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdmFsdWU6ICcgKyB0eXBlKHZhbHVlKSArICcsIGV4cGVjdGluZyBudW1iZXIgb3Igc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBcHBlbmQgYSB2YWx1ZSBvciB2YWx1ZXMgdG8gYSB1c2VyIHByb3BlcnR5LlxuICAgKiBJZiB0aGUgdXNlciBwcm9wZXJ0eSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUgc2V0IHlldCxcbiAgICogaXQgd2lsbCBiZSBpbml0aWFsaXplZCB0byBhbiBlbXB0eSBsaXN0IGJlZm9yZSB0aGUgbmV3IHZhbHVlcyBhcmUgYXBwZW5kZWQuXG4gICAqIElmIHRoZSB1c2VyIHByb3BlcnR5IGhhcyBhbiBleGlzdGluZyB2YWx1ZSBhbmQgaXQgaXMgbm90IGEgbGlzdCxcbiAgICogdGhlIGV4aXN0aW5nIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIGludG8gYSBsaXN0IHdpdGggdGhlIG5ldyB2YWx1ZXMgYXBwZW5kZWQuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHVzZXIgcHJvcGVydHkga2V5LlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bGlzdHxvYmplY3R9IHZhbHVlIC0gQSB2YWx1ZSBvciB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBWYWx1ZXMgY2FuIGJlIG51bWJlcnMsIHN0cmluZ3MsIGxpc3RzLCBvciBvYmplY3QgKGtleTp2YWx1ZSBkaWN0IHdpbGwgYmUgZmxhdHRlbmVkKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuYXBwZW5kKCdhYi10ZXN0cycsICduZXctdXNlci10ZXN0cycpO1xuICAgKiBpZGVudGlmeS5hcHBlbmQoJ3NvbWVfbGlzdCcsIFsxLCAyLCAzLCA0LCAndmFsdWVzJ10pO1xuICAgKiBhbXBsaXR1ZGUuaWRlbnRpZnkoaWRlbnRpZnkpOyAvLyBzZW5kIHRoZSBJZGVudGlmeSBjYWxsXG4gICAqL1xuXG5cbiAgSWRlbnRpZnkucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hZGRPcGVyYXRpb24oQU1QX09QX0FQUEVORCwgcHJvcGVydHksIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXIgYWxsIHVzZXIgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICogU0RLIHVzZXIgc2hvdWxkIGluc3RlYWQgY2FsbCBhbXBsaXR1ZGUuY2xlYXJVc2VyUHJvcGVydGllcygpIGluc3RlYWQgb2YgdXNpbmcgdGhpcy5cbiAgICogJGNsZWFyQWxsIG5lZWRzIHRvIGJlIHNlbnQgb24gaXRzIG93biBJZGVudGlmeSBvYmplY3QuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG90aGVyIG9wZXJhdGlvbnMsIHRoZW4gZG9uJ3QgYWRkICRjbGVhckFsbC5cbiAgICogSWYgJGNsZWFyQWxsIGFscmVhZHkgaW4gYW4gSWRlbnRpZnkgb2JqZWN0LCBkb24ndCBhbGxvdyBvdGhlciBvcGVyYXRpb25zIHRvIGJlIGFkZGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIElkZW50aWZ5LnByb3RvdHlwZS5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghdGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMuaGFzT3duUHJvcGVydHkoQU1QX09QX0NMRUFSX0FMTCkpIHtcbiAgICAgICAgdXRpbHMubG9nLmVycm9yKCdOZWVkIHRvIHNlbmQgJGNsZWFyQWxsIG9uIGl0cyBvd24gSWRlbnRpZnkgb2JqZWN0IHdpdGhvdXQgYW55IG90aGVyIG9wZXJhdGlvbnMsIHNraXBwaW5nICRjbGVhckFsbCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9uc1tBTVBfT1BfQ0xFQVJfQUxMXSA9ICctJztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFByZXBlbmQgYSB2YWx1ZSBvciB2YWx1ZXMgdG8gYSB1c2VyIHByb3BlcnR5LlxuICAgKiBQcmVwZW5kIG1lYW5zIGluc2VydGluZyB0aGUgdmFsdWUgb3IgdmFsdWVzIGF0IHRoZSBmcm9udCBvZiBhIGxpc3QuXG4gICAqIElmIHRoZSB1c2VyIHByb3BlcnR5IGRvZXMgbm90IGhhdmUgYSB2YWx1ZSBzZXQgeWV0LFxuICAgKiBpdCB3aWxsIGJlIGluaXRpYWxpemVkIHRvIGFuIGVtcHR5IGxpc3QgYmVmb3JlIHRoZSBuZXcgdmFsdWVzIGFyZSBwcmVwZW5kZWQuXG4gICAqIElmIHRoZSB1c2VyIHByb3BlcnR5IGhhcyBhbiBleGlzdGluZyB2YWx1ZSBhbmQgaXQgaXMgbm90IGEgbGlzdCxcbiAgICogdGhlIGV4aXN0aW5nIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIGludG8gYSBsaXN0IHdpdGggdGhlIG5ldyB2YWx1ZXMgcHJlcGVuZGVkLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSB1c2VyIHByb3BlcnR5IGtleS5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGxpc3R8b2JqZWN0fSB2YWx1ZSAtIEEgdmFsdWUgb3IgdmFsdWVzIHRvIHByZXBlbmQuXG4gICAqIFZhbHVlcyBjYW4gYmUgbnVtYmVycywgc3RyaW5ncywgbGlzdHMsIG9yIG9iamVjdCAoa2V5OnZhbHVlIGRpY3Qgd2lsbCBiZSBmbGF0dGVuZWQpLlxuICAgKiBAcmV0dXJuIHtJZGVudGlmeX0gUmV0dXJucyB0aGUgc2FtZSBJZGVudGlmeSBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBjaGFpbiBtdWx0aXBsZSBtZXRob2QgY2FsbHMgdG9nZXRoZXIuXG4gICAqIEBleGFtcGxlIHZhciBpZGVudGlmeSA9IG5ldyBhbXBsaXR1ZGUuSWRlbnRpZnkoKS5wcmVwZW5kKCdhYi10ZXN0cycsICduZXctdXNlci10ZXN0cycpO1xuICAgKiBpZGVudGlmeS5wcmVwZW5kKCdzb21lX2xpc3QnLCBbMSwgMiwgMywgNCwgJ3ZhbHVlcyddKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTsgLy8gc2VuZCB0aGUgSWRlbnRpZnkgY2FsbFxuICAgKi9cblxuXG4gIElkZW50aWZ5LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfUFJFUEVORCwgcHJvcGVydHksIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBnaXZlbiB1c2VyIHByb3BlcnR5LiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIG92ZXJ3cml0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSB1c2VyIHByb3BlcnR5IGtleS5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGxpc3R8Ym9vbGVhbnxvYmplY3R9IHZhbHVlIC0gQSB2YWx1ZSBvciB2YWx1ZXMgdG8gc2V0LlxuICAgKiBWYWx1ZXMgY2FuIGJlIG51bWJlcnMsIHN0cmluZ3MsIGxpc3RzLCBvciBvYmplY3QgKGtleTp2YWx1ZSBkaWN0IHdpbGwgYmUgZmxhdHRlbmVkKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuc2V0KCd1c2VyX3R5cGUnLCAnYmV0YScpO1xuICAgKiBpZGVudGlmeS5zZXQoJ25hbWUnLCB7J2ZpcnN0JzogJ0pvaG4nLCAnbGFzdCc6ICdEb2UnfSk7IC8vIGRpY3QgaXMgZmxhdHRlbmVkIGFuZCBiZWNvbWVzIG5hbWUuZmlyc3Q6IEpvaG4sIG5hbWUubGFzdDogRG9lXG4gICAqIGFtcGxpdHVkZS5pZGVudGlmeShpZGVudGlmeSk7IC8vIHNlbmQgdGhlIElkZW50aWZ5IGNhbGxcbiAgICovXG5cblxuICBJZGVudGlmeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfU0VULCBwcm9wZXJ0eSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHVzZXIgcHJvcGVydHkgb25seSBvbmNlLiBTdWJzZXF1ZW50IHNldE9uY2Ugb3BlcmF0aW9ucyBvbiB0aGF0IHVzZXIgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkO1xuICAgKiBob3dldmVyLCB0aGF0IHVzZXIgcHJvcGVydHkgY2FuIHN0aWxsIGJlIG1vZGlmaWVkIHRocm91Z2ggYW55IG9mIHRoZSBvdGhlciBvcGVyYXRpb25zLlxuICAgKiBVc2VmdWwgZm9yIGNhcHR1cmluZyBwcm9wZXJ0aWVzIHN1Y2ggYXMgJ2luaXRpYWxfc2lnbnVwX2RhdGUnLCAnaW5pdGlhbF9yZWZlcnJlcicsIGV0Yy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xsaXN0fGJvb2xlYW58b2JqZWN0fSB2YWx1ZSAtIEEgdmFsdWUgb3IgdmFsdWVzIHRvIHNldCBvbmNlLlxuICAgKiBWYWx1ZXMgY2FuIGJlIG51bWJlcnMsIHN0cmluZ3MsIGxpc3RzLCBvciBvYmplY3QgKGtleTp2YWx1ZSBkaWN0IHdpbGwgYmUgZmxhdHRlbmVkKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuc2V0T25jZSgnc2lnbl91cF9kYXRlJywgJzIwMTYtMDQtMDEnKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTsgLy8gc2VuZCB0aGUgSWRlbnRpZnkgY2FsbFxuICAgKi9cblxuXG4gIElkZW50aWZ5LnByb3RvdHlwZS5zZXRPbmNlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfU0VUX09OQ0UsIHByb3BlcnR5LCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFVuc2V0IGFuZCByZW1vdmUgYSB1c2VyIHByb3BlcnR5LiBUaGlzIHVzZXIgcHJvcGVydHkgd2lsbCBubyBsb25nZXIgc2hvdyB1cCBpbiBhIHVzZXIncyBwcm9maWxlLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSB1c2VyIHByb3BlcnR5IGtleS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkudW5zZXQoJ3VzZXJfdHlwZScpLnVuc2V0KCdhZ2UnKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTsgLy8gc2VuZCB0aGUgSWRlbnRpZnkgY2FsbFxuICAgKi9cblxuXG4gIElkZW50aWZ5LnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfVU5TRVQsIHByb3BlcnR5LCAnLScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBhZGRzIG9wZXJhdGlvbiB0byB0aGUgSWRlbnRpZnkncyBvYmplY3RcbiAgICogSGFuZGxlJ3MgZmlsdGVyaW5nIG9mIGR1cGxpY2F0ZSB1c2VyIHByb3BlcnR5IGtleXMsIGFuZCBmaWx0ZXJpbmcgZm9yIGNsZWFyQWxsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIElkZW50aWZ5LnByb3RvdHlwZS5fYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgaWRlbnRpZnkgZG9lc24ndCBhbHJlYWR5IGNvbnRhaW4gYSBjbGVhckFsbFxuICAgIGlmICh0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucy5oYXNPd25Qcm9wZXJ0eShBTVBfT1BfQ0xFQVJfQUxMKSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdUaGlzIGlkZW50aWZ5IGFscmVhZHkgY29udGFpbnMgYSAkY2xlYXJBbGwgb3BlcmF0aW9uLCBza2lwcGluZyBvcGVyYXRpb24gJyArIG9wZXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjaGVjayB0aGF0IHByb3BlcnR5IHdhc24ndCBhbHJlYWR5IHVzZWQgaW4gdGhpcyBJZGVudGlmeVxuXG5cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpICE9PSAtMSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdVc2VyIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiIGFscmVhZHkgdXNlZCBpbiB0aGlzIGlkZW50aWZ5LCBza2lwcGluZyBvcGVyYXRpb24gJyArIG9wZXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcGVyYXRpb24pKSB7XG4gICAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9uc1tvcGVyYXRpb25dID0ge307XG4gICAgfVxuXG4gICAgdGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnNbb3BlcmF0aW9uXVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB0aGlzLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gIH07XG5cbiAgdmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgdmFyIG1kNSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgKGZ1bmN0aW9uICgkKSB7XG5cbiAgICAvKlxuICAgICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICAgICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVBZGQgKHgsIHkpIHtcbiAgICAgIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gICAgICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhmZmZmKVxuICAgIH1cblxuICAgIC8qXG4gICAgKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBiaXRSb3RhdGVMZWZ0IChudW0sIGNudCkge1xuICAgICAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG4gICAgfVxuXG4gICAgLypcbiAgICAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBtZDVjbW4gKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICAgIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1kNWZmIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICByZXR1cm4gbWQ1Y21uKChiICYgYykgfCAofmIgJiBkKSwgYSwgYiwgeCwgcywgdClcbiAgICB9XG4gICAgZnVuY3Rpb24gbWQ1Z2cgKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgIHJldHVybiBtZDVjbW4oKGIgJiBkKSB8IChjICYgfmQpLCBhLCBiLCB4LCBzLCB0KVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZDVoaCAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1kNWlpIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdClcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmxNRDUgKHgsIGxlbikge1xuICAgICAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgICAgIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKGxlbiAlIDMyKTtcbiAgICAgIHhbKChsZW4gKyA2NCkgPj4+IDkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIG9sZGE7XG4gICAgICB2YXIgb2xkYjtcbiAgICAgIHZhciBvbGRjO1xuICAgICAgdmFyIG9sZGQ7XG4gICAgICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gICAgICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gICAgICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICAgICAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICBvbGRhID0gYTtcbiAgICAgICAgb2xkYiA9IGI7XG4gICAgICAgIG9sZGMgPSBjO1xuICAgICAgICBvbGRkID0gZDtcblxuICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgICAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICAgICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2EsIGIsIGMsIGRdXG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICAgICovXG4gICAgZnVuY3Rpb24gYmlubDJyc3RyIChpbnB1dCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICB2YXIgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiAoaSAlIDMyKSkgJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiByc3RyMmJpbmwgKGlucHV0KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIG91dHB1dFtpXSA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4ZmYpIDw8IChpICUgMzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cblxuICAgIC8qXG4gICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJzdHJNRDUgKHMpIHtcbiAgICAgIHJldHVybiBiaW5sMnJzdHIoYmlubE1ENShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpXG4gICAgfVxuXG4gICAgLypcbiAgICAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICAgICovXG4gICAgZnVuY3Rpb24gcnN0ckhNQUNNRDUgKGtleSwgZGF0YSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgYmtleSA9IHJzdHIyYmlubChrZXkpO1xuICAgICAgdmFyIGlwYWQgPSBbXTtcbiAgICAgIHZhciBvcGFkID0gW107XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoYmtleS5sZW5ndGggPiAxNikge1xuICAgICAgICBia2V5ID0gYmlubE1ENShia2V5LCBrZXkubGVuZ3RoICogOCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XG4gICAgICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1YzVjNWM1YztcbiAgICAgIH1cbiAgICAgIGhhc2ggPSBiaW5sTUQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gICAgICByZXR1cm4gYmlubDJyc3RyKGJpbmxNRDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpXG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgaGV4IHN0cmluZ1xuICAgICovXG4gICAgZnVuY3Rpb24gcnN0cjJoZXggKGlucHV0KSB7XG4gICAgICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgb3V0cHV0ICs9IGhleFRhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cbiAgICAvKlxuICAgICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04XG4gICAgKi9cbiAgICBmdW5jdGlvbiBzdHIycnN0clVURjggKGlucHV0KSB7XG4gICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSlcbiAgICB9XG5cbiAgICAvKlxuICAgICogVGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIHJhdyBvciBoZXggZW5jb2RlZCBzdHJpbmdzXG4gICAgKi9cbiAgICBmdW5jdGlvbiByYXdNRDUgKHMpIHtcbiAgICAgIHJldHVybiByc3RyTUQ1KHN0cjJyc3RyVVRGOChzKSlcbiAgICB9XG4gICAgZnVuY3Rpb24gaGV4TUQ1IChzKSB7XG4gICAgICByZXR1cm4gcnN0cjJoZXgocmF3TUQ1KHMpKVxuICAgIH1cbiAgICBmdW5jdGlvbiByYXdITUFDTUQ1IChrLCBkKSB7XG4gICAgICByZXR1cm4gcnN0ckhNQUNNRDUoc3RyMnJzdHJVVEY4KGspLCBzdHIycnN0clVURjgoZCkpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGhleEhNQUNNRDUgKGssIGQpIHtcbiAgICAgIHJldHVybiByc3RyMmhleChyYXdITUFDTUQ1KGssIGQpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1kNSAoc3RyaW5nLCBrZXksIHJhdykge1xuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgaWYgKCFyYXcpIHtcbiAgICAgICAgICByZXR1cm4gaGV4TUQ1KHN0cmluZylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3TUQ1KHN0cmluZylcbiAgICAgIH1cbiAgICAgIGlmICghcmF3KSB7XG4gICAgICAgIHJldHVybiBoZXhITUFDTUQ1KGtleSwgc3RyaW5nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhd0hNQUNNRDUoa2V5LCBzdHJpbmcpXG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IG1kNTtcbiAgICB9IGVsc2Uge1xuICAgICAgJC5tZDUgPSBtZDU7XG4gICAgfVxuICB9KShjb21tb25qc0dsb2JhbCk7XG4gIH0pO1xuXG4gIHZhciBzdHJpY3RVcmlFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgXHRcdHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH07XG5cbiAgLypcbiAgb2JqZWN0LWFzc2lnblxuICAoYykgU2luZHJlIFNvcmh1c1xuICBAbGljZW5zZSBNSVRcbiAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuICBmdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcbiAgXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICBcdH1cblxuICBcdHJldHVybiBPYmplY3QodmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcbiAgXHR0cnkge1xuICBcdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG4gIFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG4gIFx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gIFx0XHR0ZXN0MVs1XSA9ICdkZSc7XG4gIFx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG4gIFx0XHR2YXIgdGVzdDIgPSB7fTtcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICBcdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG4gIFx0XHR9XG4gIFx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuICBcdFx0XHRyZXR1cm4gdGVzdDJbbl07XG4gIFx0XHR9KTtcbiAgXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcbiAgXHRcdHZhciB0ZXN0MyA9IHt9O1xuICBcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG4gIFx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG4gIFx0XHR9KTtcbiAgXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuICBcdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgdmFyIG9iamVjdEFzc2lnbiA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICBcdHZhciBmcm9tO1xuICBcdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIFx0dmFyIHN5bWJvbHM7XG5cbiAgXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuICBcdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICBcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gIFx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG4gIFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcbiAgXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdG87XG4gIH07XG5cbiAgdmFyIHRva2VuID0gJyVbYS1mMC05XXsyfSc7XG4gIHZhciBzaW5nbGVNYXRjaGVyID0gbmV3IFJlZ0V4cCh0b2tlbiwgJ2dpJyk7XG4gIHZhciBtdWx0aU1hdGNoZXIgPSBuZXcgUmVnRXhwKCcoJyArIHRva2VuICsgJykrJywgJ2dpJyk7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ29tcG9uZW50cyhjb21wb25lbnRzLCBzcGxpdCkge1xuICBcdHRyeSB7XG4gIFx0XHQvLyBUcnkgdG8gZGVjb2RlIHRoZSBlbnRpcmUgc3RyaW5nIGZpcnN0XG4gIFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGNvbXBvbmVudHMuam9pbignJykpO1xuICBcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0Ly8gRG8gbm90aGluZ1xuICBcdH1cblxuICBcdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIGNvbXBvbmVudHM7XG4gIFx0fVxuXG4gIFx0c3BsaXQgPSBzcGxpdCB8fCAxO1xuXG4gIFx0Ly8gU3BsaXQgdGhlIGFycmF5IGluIDIgcGFydHNcbiAgXHR2YXIgbGVmdCA9IGNvbXBvbmVudHMuc2xpY2UoMCwgc3BsaXQpO1xuICBcdHZhciByaWdodCA9IGNvbXBvbmVudHMuc2xpY2Uoc3BsaXQpO1xuXG4gIFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgZGVjb2RlQ29tcG9uZW50cyhsZWZ0KSwgZGVjb2RlQ29tcG9uZW50cyhyaWdodCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIFx0dHJ5IHtcbiAgXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICBcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0dmFyIHRva2VucyA9IGlucHV0Lm1hdGNoKHNpbmdsZU1hdGNoZXIpO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRpbnB1dCA9IGRlY29kZUNvbXBvbmVudHModG9rZW5zLCBpKS5qb2luKCcnKTtcblxuICBcdFx0XHR0b2tlbnMgPSBpbnB1dC5tYXRjaChzaW5nbGVNYXRjaGVyKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGlucHV0O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGN1c3RvbURlY29kZVVSSUNvbXBvbmVudChpbnB1dCkge1xuICBcdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHRoZSByZXBsYWNlbWVudHMgYW5kIHByZWZpbGwgdGhlIG1hcCB3aXRoIHRoZSBgQk9NYFxuICBcdHZhciByZXBsYWNlTWFwID0ge1xuICBcdFx0JyVGRSVGRic6ICdcXHVGRkZEXFx1RkZGRCcsXG4gIFx0XHQnJUZGJUZFJzogJ1xcdUZGRkRcXHVGRkZEJ1xuICBcdH07XG5cbiAgXHR2YXIgbWF0Y2ggPSBtdWx0aU1hdGNoZXIuZXhlYyhpbnB1dCk7XG4gIFx0d2hpbGUgKG1hdGNoKSB7XG4gIFx0XHR0cnkge1xuICBcdFx0XHQvLyBEZWNvZGUgYXMgYmlnIGNodW5rcyBhcyBwb3NzaWJsZVxuICBcdFx0XHRyZXBsYWNlTWFwW21hdGNoWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFswXSk7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IGRlY29kZShtYXRjaFswXSk7XG5cbiAgXHRcdFx0aWYgKHJlc3VsdCAhPT0gbWF0Y2hbMF0pIHtcbiAgXHRcdFx0XHRyZXBsYWNlTWFwW21hdGNoWzBdXSA9IHJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRtYXRjaCA9IG11bHRpTWF0Y2hlci5leGVjKGlucHV0KTtcbiAgXHR9XG5cbiAgXHQvLyBBZGQgYCVDMmAgYXQgdGhlIGVuZCBvZiB0aGUgbWFwIHRvIG1ha2Ugc3VyZSBpdCBkb2VzIG5vdCByZXBsYWNlIHRoZSBjb21iaW5hdG9yIGJlZm9yZSBldmVyeXRoaW5nIGVsc2VcbiAgXHRyZXBsYWNlTWFwWyclQzInXSA9ICdcXHVGRkZEJztcblxuICBcdHZhciBlbnRyaWVzID0gT2JqZWN0LmtleXMocmVwbGFjZU1hcCk7XG5cbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgXHRcdC8vIFJlcGxhY2UgYWxsIGRlY29kZWQgY29tcG9uZW50c1xuICBcdFx0dmFyIGtleSA9IGVudHJpZXNbaV07XG4gIFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UobmV3IFJlZ0V4cChrZXksICdnJyksIHJlcGxhY2VNYXBba2V5XSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGlucHV0O1xuICB9XG5cbiAgdmFyIGRlY29kZVVyaUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbmNvZGVkVVJJKSB7XG4gIFx0aWYgKHR5cGVvZiBlbmNvZGVkVVJJICE9PSAnc3RyaW5nJykge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGVuY29kZWRVUklgIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2AsIGdvdCBgJyArIHR5cGVvZiBlbmNvZGVkVVJJICsgJ2AnKTtcbiAgXHR9XG5cbiAgXHR0cnkge1xuICBcdFx0ZW5jb2RlZFVSSSA9IGVuY29kZWRVUkkucmVwbGFjZSgvXFwrL2csICcgJyk7XG5cbiAgXHRcdC8vIFRyeSB0aGUgYnVpbHQgaW4gZGVjb2RlciBmaXJzdFxuICBcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkVVJJKTtcbiAgXHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdC8vIEZhbGxiYWNrIHRvIGEgbW9yZSBhZHZhbmNlZCBkZWNvZGVyXG4gIFx0XHRyZXR1cm4gY3VzdG9tRGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRVUkkpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0cykge1xuICBcdHN3aXRjaCAob3B0cy5hcnJheUZvcm1hdCkge1xuICBcdFx0Y2FzZSAnaW5kZXgnOlxuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gW1xuICBcdFx0XHRcdFx0ZW5jb2RlKGtleSwgb3B0cyksXG4gIFx0XHRcdFx0XHQnWycsXG4gIFx0XHRcdFx0XHRpbmRleCxcbiAgXHRcdFx0XHRcdCddJ1xuICBcdFx0XHRcdF0uam9pbignJykgOiBbXG4gIFx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcbiAgXHRcdFx0XHRcdCdbJyxcbiAgXHRcdFx0XHRcdGVuY29kZShpbmRleCwgb3B0cyksXG4gIFx0XHRcdFx0XHQnXT0nLFxuICBcdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxuICBcdFx0XHRcdF0uam9pbignJyk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdGNhc2UgJ2JyYWNrZXQnOlxuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgPyBlbmNvZGUoa2V5LCBvcHRzKSA6IFtcbiAgXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxuICBcdFx0XHRcdFx0J1tdPScsXG4gIFx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXG4gIFx0XHRcdFx0XS5qb2luKCcnKTtcbiAgXHRcdFx0fTtcblxuICBcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXG4gIFx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcbiAgXHRcdFx0XHRcdCc9JyxcbiAgXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcbiAgXHRcdFx0XHRdLmpvaW4oJycpO1xuICBcdFx0XHR9O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdHMpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0c3dpdGNoIChvcHRzLmFycmF5Rm9ybWF0KSB7XG4gIFx0XHRjYXNlICdpbmRleCc6XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcbiAgXHRcdFx0XHRyZXN1bHQgPSAvXFxbKFxcZCopXFxdJC8uZXhlYyhrZXkpO1xuXG4gIFx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW1xcZCpcXF0kLywgJycpO1xuXG4gIFx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcbiAgXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0ge307XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XVtyZXN1bHRbMV1dID0gdmFsdWU7XG4gIFx0XHRcdH07XG5cbiAgXHRcdGNhc2UgJ2JyYWNrZXQnOlxuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XG4gIFx0XHRcdFx0cmVzdWx0ID0gLyhcXFtcXF0pJC8uZXhlYyhrZXkpO1xuICBcdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXF0kLywgJycpO1xuXG4gIFx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcbiAgXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFt2YWx1ZV07XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdGRlZmF1bHQ6XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpIHtcbiAgXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG4gIFx0XHRcdH07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBvcHRzKSB7XG4gIFx0aWYgKG9wdHMuZW5jb2RlKSB7XG4gIFx0XHRyZXR1cm4gb3B0cy5zdHJpY3QgPyBzdHJpY3RVcmlFbmNvZGUodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XG4gIFx0aWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXQuc29ydCgpO1xuICBcdH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICBcdFx0cmV0dXJuIGtleXNTb3J0ZXIoT2JqZWN0LmtleXMoaW5wdXQpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHRyZXR1cm4gaW5wdXRba2V5XTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3Qoc3RyKSB7XG4gIFx0dmFyIHF1ZXJ5U3RhcnQgPSBzdHIuaW5kZXhPZignPycpO1xuICBcdGlmIChxdWVyeVN0YXJ0ID09PSAtMSkge1xuICBcdFx0cmV0dXJuICcnO1xuICBcdH1cbiAgXHRyZXR1cm4gc3RyLnNsaWNlKHF1ZXJ5U3RhcnQgKyAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0cykge1xuICBcdG9wdHMgPSBvYmplY3RBc3NpZ24oe2FycmF5Rm9ybWF0OiAnbm9uZSd9LCBvcHRzKTtcblxuICBcdHZhciBmb3JtYXR0ZXIgPSBwYXJzZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcblxuICBcdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcbiAgXHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9pc3N1ZXMvNDdcbiAgXHR2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICBcdFx0cmV0dXJuIHJldDtcbiAgXHR9XG5cbiAgXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sICcnKTtcblxuICBcdGlmICghc3RyKSB7XG4gIFx0XHRyZXR1cm4gcmV0O1xuICBcdH1cblxuICBcdHN0ci5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gIFx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICBcdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuICBcdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gIFx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuICBcdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcbiAgXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVyaUNvbXBvbmVudCh2YWwpO1xuXG4gIFx0XHRmb3JtYXR0ZXIoZGVjb2RlVXJpQ29tcG9uZW50KGtleSksIHZhbCwgcmV0KTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gIFx0XHR2YXIgdmFsID0gcmV0W2tleV07XG4gIFx0XHRpZiAoQm9vbGVhbih2YWwpICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgXHRcdFx0Ly8gU29ydCBvYmplY3Qga2V5cywgbm90IHZhbHVlc1xuICBcdFx0XHRyZXN1bHRba2V5XSA9IGtleXNTb3J0ZXIodmFsKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdFtrZXldID0gdmFsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG5cbiAgdmFyIGV4dHJhY3RfMSA9IGV4dHJhY3Q7XG4gIHZhciBwYXJzZV8xID0gcGFyc2U7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgXHR2YXIgZGVmYXVsdHMgPSB7XG4gIFx0XHRlbmNvZGU6IHRydWUsXG4gIFx0XHRzdHJpY3Q6IHRydWUsXG4gIFx0XHRhcnJheUZvcm1hdDogJ25vbmUnXG4gIFx0fTtcblxuICBcdG9wdHMgPSBvYmplY3RBc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuXG4gIFx0aWYgKG9wdHMuc29ydCA9PT0gZmFsc2UpIHtcbiAgXHRcdG9wdHMuc29ydCA9IGZ1bmN0aW9uICgpIHt9O1xuICBcdH1cblxuICBcdHZhciBmb3JtYXR0ZXIgPSBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0cyk7XG5cbiAgXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KG9wdHMuc29ydCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuICBcdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiAnJztcbiAgXHRcdH1cblxuICBcdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuICBcdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0cyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG4gIFx0XHRcdHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcbiAgXHRcdFx0XHRpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzdWx0LnB1c2goZm9ybWF0dGVyKGtleSwgdmFsMiwgcmVzdWx0Lmxlbmd0aCkpO1xuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJyYnKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbCwgb3B0cyk7XG4gIFx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuICBcdH0pLmpvaW4oJyYnKSA6ICcnO1xuICB9O1xuXG4gIHZhciBwYXJzZVVybCA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgXHRyZXR1cm4ge1xuICBcdFx0dXJsOiBzdHIuc3BsaXQoJz8nKVswXSB8fCAnJyxcbiAgXHRcdHF1ZXJ5OiBwYXJzZShleHRyYWN0KHN0ciksIG9wdHMpXG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcXVlcnlTdHJpbmcgPSB7XG4gIFx0ZXh0cmFjdDogZXh0cmFjdF8xLFxuICBcdHBhcnNlOiBwYXJzZV8xLFxuICBcdHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuICBcdHBhcnNlVXJsOiBwYXJzZVVybFxuICB9O1xuXG4gIC8qXG4gICAqIFNpbXBsZSBBSkFYIHJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuXG4gIHZhciBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdCh1cmwsIGRhdGEpIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICB9O1xuXG4gIFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgaXNJRSA9IHdpbmRvdy5YRG9tYWluUmVxdWVzdCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGlmIChpc0lFKSB7XG4gICAgICB2YXIgeGRyID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgeGRyLm9wZW4oJ1BPU1QnLCB0aGlzLnVybCwgdHJ1ZSk7XG5cbiAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuXG4gICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RhdHVzIGNvZGUgbm90IGF2YWlsYWJsZSBmcm9tIHhkciwgdHJ5IHN0cmluZyBtYXRjaGluZyBvbiByZXNwb25zZVRleHRcbiAgICAgICAgaWYgKHhkci5yZXNwb25zZVRleHQgPT09ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnKSB7XG4gICAgICAgICAgY2FsbGJhY2soNDEzLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayg1MDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHhkci5zZW5kKHF1ZXJ5U3RyaW5nLnN0cmluZ2lmeSh0aGlzLmRhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB0aGlzLnVybCwgdHJ1ZSk7XG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCcpO1xuICAgICAgeGhyLnNlbmQocXVlcnlTdHJpbmcuc3RyaW5naWZ5KHRoaXMuZGF0YSkpO1xuICAgIH0gLy9sb2coJ3NlbnQgcmVxdWVzdCB0byAnICsgdGhpcy51cmwgKyAnIHdpdGggZGF0YSAnICsgZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5U3RyaW5nKHRoaXMuZGF0YSkpKTtcblxuICB9O1xuXG4gIC8qXG4gICAqIFdyYXBwZXIgZm9yIGxvZ2dpbmcgUmV2ZW51ZSBkYXRhLiBSZXZlbnVlIG9iamVjdHMgZ2V0IHBhc3NlZCB0byBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyIHRvIHNlbmQgdG8gQW1wbGl0dWRlIHNlcnZlcnMuXG4gICAqIE5vdGU6IHByaWNlIGlzIHRoZSBvbmx5IHJlcXVpcmVkIGZpZWxkLiBJZiBxdWFudGl0eSBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGRlZmF1bHRzIHRvIDEuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXZlbnVlIEFQSSAtIGluc3RhbmNlIGNvbnN0cnVjdG9yLiBSZXZlbnVlIG9iamVjdHMgYXJlIGEgd3JhcHBlciBmb3IgcmV2ZW51ZSBkYXRhLlxuICAgKiBFYWNoIG1ldGhvZCB1cGRhdGVzIGEgcmV2ZW51ZSBwcm9wZXJ0eSBpbiB0aGUgUmV2ZW51ZSBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LFxuICAgKiBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBOb3RlOiBwcmljZSBpcyBhIHJlcXVpcmVkIGZpZWxkIHRvIGxvZyByZXZlbnVlIGV2ZW50cy5cbiAgICogSWYgcXVhbnRpdHkgaXMgbm90IHNwZWNpZmllZCB0aGVuIGRlZmF1bHRzIHRvIDEuXG4gICAqIFNlZSBbUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0I3RyYWNraW5nLXJldmVudWV9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IGxvZ2dpbmcgUmV2ZW51ZS5cbiAgICogQGNvbnN0cnVjdG9yIFJldmVudWVcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpO1xuICAgKi9cblxuICB2YXIgUmV2ZW51ZSA9IGZ1bmN0aW9uIFJldmVudWUoKSB7XG4gICAgLy8gcmVxdWlyZWQgZmllbGRzXG4gICAgdGhpcy5fcHJpY2UgPSBudWxsOyAvLyBvcHRpb25hbCBmaWVsZHNcblxuICAgIHRoaXMuX3Byb2R1Y3RJZCA9IG51bGw7XG4gICAgdGhpcy5fcXVhbnRpdHkgPSAxO1xuICAgIHRoaXMuX3JldmVudWVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciB0aGUgcHJvZHVjdCBpZGVudGlmZXIuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb2R1Y3RJZCAtIFRoZSB2YWx1ZSBmb3IgdGhlIHByb2R1Y3QgaWRlbnRpZmllci4gRW1wdHkgYW5kIGludmFsaWQgc3RyaW5ncyBhcmUgaWdub3JlZC5cbiAgICogQHJldHVybiB7UmV2ZW51ZX0gUmV0dXJucyB0aGUgc2FtZSBSZXZlbnVlIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIHJldmVudWUgPSBuZXcgYW1wbGl0dWRlLlJldmVudWUoKS5zZXRQcm9kdWN0SWQoJ3Byb2R1Y3RJZGVudGlmaWVyJykuc2V0UHJpY2UoMTAuOTkpO1xuICAgKiBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyKHJldmVudWUpO1xuICAgKi9cblxuXG4gIFJldmVudWUucHJvdG90eXBlLnNldFByb2R1Y3RJZCA9IGZ1bmN0aW9uIHNldFByb2R1Y3RJZChwcm9kdWN0SWQpIHtcbiAgICBpZiAodHlwZShwcm9kdWN0SWQpICE9PSAnc3RyaW5nJykge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIGZvciBwcm9kdWN0SWQ6ICcgKyB0eXBlKHByb2R1Y3RJZCkgKyAnLCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHByb2R1Y3RJZCkpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCBlbXB0eSBwcm9kdWN0SWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJvZHVjdElkID0gcHJvZHVjdElkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIHRoZSBxdWFudGl0eS4gTm90ZSByZXZlbnVlIGFtb3VudCBpcyBjYWxjdWxhdGVkIGFzIHByaWNlICogcXVhbnRpdHkuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1YW50aXR5IC0gSW50ZWdlciB2YWx1ZSBmb3IgdGhlIHF1YW50aXR5LiBJZiBub3Qgc2V0LCBxdWFudGl0eSBkZWZhdWx0cyB0byAxLlxuICAgKiBAcmV0dXJuIHtSZXZlbnVlfSBSZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpLnNldFByb2R1Y3RJZCgncHJvZHVjdElkZW50aWZpZXInKS5zZXRQcmljZSgxMC45OSkuc2V0UXVhbnRpdHkoNSk7XG4gICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICAqL1xuXG5cbiAgUmV2ZW51ZS5wcm90b3R5cGUuc2V0UXVhbnRpdHkgPSBmdW5jdGlvbiBzZXRRdWFudGl0eShxdWFudGl0eSkge1xuICAgIGlmICh0eXBlKHF1YW50aXR5KSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgcXVhbnRpdHk6ICcgKyB0eXBlKHF1YW50aXR5KSArICcsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVhbnRpdHkgPSBwYXJzZUludChxdWFudGl0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgdGhlIHByaWNlLiBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGZvciBhbGwgcmV2ZW51ZSBiZWluZyBsb2dnZWQuXG4gICAqIE5vdGUgcmV2ZW51ZSBhbW91bnQgaXMgY2FsY3VsYXRlZCBhcyBwcmljZSAqIHF1YW50aXR5LlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmljZSAtIERvdWJsZSB2YWx1ZSBmb3IgdGhlIHF1YW50aXR5LlxuICAgKiBAcmV0dXJuIHtSZXZlbnVlfSBSZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpLnNldFByb2R1Y3RJZCgncHJvZHVjdElkZW50aWZpZXInKS5zZXRQcmljZSgxMC45OSk7XG4gICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICAqL1xuXG5cbiAgUmV2ZW51ZS5wcm90b3R5cGUuc2V0UHJpY2UgPSBmdW5jdGlvbiBzZXRQcmljZShwcmljZSkge1xuICAgIGlmICh0eXBlKHByaWNlKSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgcHJpY2U6ICcgKyB0eXBlKHByaWNlKSArICcsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJpY2UgPSBwcmljZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciB0aGUgcmV2ZW51ZVR5cGUgKGZvciBleGFtcGxlIHB1cmNoYXNlLCBjb3N0LCB0YXgsIHJlZnVuZCwgZXRjKS5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmV2ZW51ZVR5cGUgLSBSZXZlbnVlVHlwZSB0byBkZXNpZ25hdGUuXG4gICAqIEByZXR1cm4ge1JldmVudWV9IFJldHVybnMgdGhlIHNhbWUgUmV2ZW51ZSBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBjaGFpbiBtdWx0aXBsZSBtZXRob2QgY2FsbHMgdG9nZXRoZXIuXG4gICAqIEBleGFtcGxlIHZhciByZXZlbnVlID0gbmV3IGFtcGxpdHVkZS5SZXZlbnVlKCkuc2V0UHJvZHVjdElkKCdwcm9kdWN0SWRlbnRpZmllcicpLnNldFByaWNlKDEwLjk5KS5zZXRSZXZlbnVlVHlwZSgncHVyY2hhc2UnKTtcbiAgICogYW1wbGl0dWRlLmxvZ1JldmVudWVWMihyZXZlbnVlKTtcbiAgICovXG5cblxuICBSZXZlbnVlLnByb3RvdHlwZS5zZXRSZXZlbnVlVHlwZSA9IGZ1bmN0aW9uIHNldFJldmVudWVUeXBlKHJldmVudWVUeXBlKSB7XG4gICAgaWYgKHR5cGUocmV2ZW51ZVR5cGUpICE9PSAnc3RyaW5nJykge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIGZvciByZXZlbnVlVHlwZTogJyArIHR5cGUocmV2ZW51ZVR5cGUpICsgJywgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXZlbnVlVHlwZSA9IHJldmVudWVUeXBlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogU2V0IGV2ZW50IHByb3BlcnRpZXMgZm9yIHRoZSByZXZlbnVlIGV2ZW50LlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFByb3BlcnRpZXMgLSBSZXZlbnVlIGV2ZW50IHByb3BlcnRpZXMgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtSZXZlbnVlfSBSZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgZXZlbnRfcHJvcGVydGllcyA9IHsnY2l0eSc6ICdTYW4gRnJhbmNpc2NvJ307XG4gICAqIHZhciByZXZlbnVlID0gbmV3IGFtcGxpdHVkZS5SZXZlbnVlKCkuc2V0UHJvZHVjdElkKCdwcm9kdWN0SWRlbnRpZmllcicpLnNldFByaWNlKDEwLjk5KS5zZXRFdmVudFByb3BlcnRpZXMoZXZlbnRfcHJvcGVydGllcyk7XG4gICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICovXG5cblxuICBSZXZlbnVlLnByb3RvdHlwZS5zZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiBzZXRFdmVudFByb3BlcnRpZXMoZXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHR5cGUoZXZlbnRQcm9wZXJ0aWVzKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgZXZlbnRQcm9wZXJ0aWVzOiAnICsgdHlwZShldmVudFByb3BlcnRpZXMpICsgJywgZXhwZWN0aW5nIG9iamVjdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKGV2ZW50UHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJldmVudWUucHJvdG90eXBlLl9pc1ZhbGlkUmV2ZW51ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkUmV2ZW51ZSgpIHtcbiAgICBpZiAodHlwZSh0aGlzLl9wcmljZSkgIT09ICdudW1iZXInKSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoJ0ludmFsaWQgcmV2ZW51ZSwgbmVlZCB0byBzZXQgcHJpY2UgZmllbGQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUmV2ZW51ZS5wcm90b3R5cGUuX3RvSlNPTk9iamVjdCA9IGZ1bmN0aW9uIF90b0pTT05PYmplY3QoKSB7XG4gICAgdmFyIG9iaiA9IHR5cGUodGhpcy5fcHJvcGVydGllcykgPT09ICdvYmplY3QnID8gdGhpcy5fcHJvcGVydGllcyA6IHt9O1xuXG4gICAgaWYgKHRoaXMuX3Byb2R1Y3RJZCAhPT0gbnVsbCkge1xuICAgICAgb2JqW0NvbnN0YW50cy5SRVZFTlVFX1BST0RVQ1RfSURdID0gdGhpcy5fcHJvZHVjdElkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9xdWFudGl0eSAhPT0gbnVsbCkge1xuICAgICAgb2JqW0NvbnN0YW50cy5SRVZFTlVFX1FVQU5USVRZXSA9IHRoaXMuX3F1YW50aXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcmljZSAhPT0gbnVsbCkge1xuICAgICAgb2JqW0NvbnN0YW50cy5SRVZFTlVFX1BSSUNFXSA9IHRoaXMuX3ByaWNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXZlbnVlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgb2JqW0NvbnN0YW50cy5SRVZFTlVFX1JFVkVOVUVfVFlQRV0gPSB0aGlzLl9yZXZlbnVlVHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHZhciB1YVBhcnNlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgLyohXG4gICAqIFVBUGFyc2VyLmpzIHYwLjcuMjFcbiAgICogTGlnaHR3ZWlnaHQgSmF2YVNjcmlwdC1iYXNlZCBVc2VyLUFnZW50IHN0cmluZyBwYXJzZXJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhaXNhbG1hbi91YS1wYXJzZXItanNcbiAgICpcbiAgICogQ29weXJpZ2h0IMKpIDIwMTItMjAxOSBGYWlzYWwgU2FsbWFuIDxmQGZhaXNhbG1hbi5jb20+XG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gICAqL1xuXG4gIChmdW5jdGlvbiAod2luZG93LCB1bmRlZmluZWQkMSkge1xuXG4gICAgICAvLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gQ29uc3RhbnRzXG4gICAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgICAgdmFyIExJQlZFUlNJT04gID0gJzAuNy4yMScsXG4gICAgICAgICAgRU1QVFkgICAgICAgPSAnJyxcbiAgICAgICAgICBVTktOT1dOICAgICA9ICc/JyxcbiAgICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgICAgT0JKX1RZUEUgICAgPSAnb2JqZWN0JyxcbiAgICAgICAgICBTVFJfVFlQRSAgICA9ICdzdHJpbmcnLFxuICAgICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgIE1PREVMICAgICAgID0gJ21vZGVsJyxcbiAgICAgICAgICBOQU1FICAgICAgICA9ICduYW1lJyxcbiAgICAgICAgICBUWVBFICAgICAgICA9ICd0eXBlJyxcbiAgICAgICAgICBWRU5ET1IgICAgICA9ICd2ZW5kb3InLFxuICAgICAgICAgIFZFUlNJT04gICAgID0gJ3ZlcnNpb24nLFxuICAgICAgICAgIEFSQ0hJVEVDVFVSRT0gJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgICAgQ09OU09MRSAgICAgPSAnY29uc29sZScsXG4gICAgICAgICAgTU9CSUxFICAgICAgPSAnbW9iaWxlJyxcbiAgICAgICAgICBUQUJMRVQgICAgICA9ICd0YWJsZXQnLFxuICAgICAgICAgIFNNQVJUVFYgICAgID0gJ3NtYXJ0dHYnLFxuICAgICAgICAgIFdFQVJBQkxFICAgID0gJ3dlYXJhYmxlJyxcbiAgICAgICAgICBFTUJFRERFRCAgICA9ICdlbWJlZGRlZCc7XG5cblxuICAgICAgLy8vLy8vLy8vLy9cbiAgICAgIC8vIEhlbHBlclxuICAgICAgLy8vLy8vLy8vL1xuXG5cbiAgICAgIHZhciB1dGlsID0ge1xuICAgICAgICAgIGV4dGVuZCA6IGZ1bmN0aW9uIChyZWdleGVzLCBleHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgIHZhciBtZXJnZWRSZWdleGVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcmVnZXhlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbaV0gJiYgZXh0ZW5zaW9uc1tpXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkUmVnZXhlc1tpXSA9IGV4dGVuc2lvbnNbaV0uY29uY2F0KHJlZ2V4ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZWdleGVzW2ldID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkUmVnZXhlcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhcyA6IGZ1bmN0aW9uIChzdHIxLCBzdHIyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0cjEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG93ZXJpemUgOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1ham9yIDogZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCcnKS5zcGxpdChcIi5cIilbMF0gOiB1bmRlZmluZWQkMTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyaW0gOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuXG4gICAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAgIC8vIE1hcCBoZWxwZXJcbiAgICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuICAgICAgdmFyIG1hcHBlciA9IHtcblxuICAgICAgICAgIHJneCA6IGZ1bmN0aW9uICh1YSwgYXJyYXlzKSB7XG5cbiAgICAgICAgICAgICAgdmFyIGkgPSAwLCBqLCBrLCBwLCBxLCBtYXRjaGVzLCBtYXRjaDtcblxuICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIHJlZ2V4ZXMgbWFwc1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGFycmF5cy5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJyYXlzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFycmF5c1tpICsgMV07ICAgLy8gb2RkIHNlcXVlbmNlICgxLDMsNSwuLilcbiAgICAgICAgICAgICAgICAgIGogPSBrID0gMDtcblxuICAgICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCByZWdleC5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleFtqKytdLmV4ZWModWEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEhbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1srK2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcSA9PT0gT0JKX1RZUEUgJiYgcS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09IEZVTkNfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIG1vZGlmaWVkIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBnaXZlbiB2YWx1ZSwgaWdub3JlIHJlZ2V4IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PT0gRlVOQ19UWVBFICYmICEocVsxXS5leGVjICYmIHFbMV0udGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gKHVzdWFsbHkgc3RyaW5nIG1hcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pIDogdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbM10uY2FsbCh0aGlzLCBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pKSA6IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdHIgOiBmdW5jdGlvbiAoc3RyLCBtYXApIHtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW2ldID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmhhcyhtYXBbaV1bal0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQkMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaGFzKG1hcFtpXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQkMSA6IGk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gU3RyaW5nIG1hcFxuICAgICAgLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgICB2YXIgbWFwcyA9IHtcblxuICAgICAgICAgIGJyb3dzZXIgOiB7XG4gICAgICAgICAgICAgIG9sZHNhZmFyaSA6IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgJzEuMCcgICA6ICcvOCcsXG4gICAgICAgICAgICAgICAgICAgICAgJzEuMicgICA6ICcvMScsXG4gICAgICAgICAgICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAgICAgICAgICAgJzIuMCcgICA6ICcvNDEyJyxcbiAgICAgICAgICAgICAgICAgICAgICAnMi4wLjInIDogJy80MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAgICAgICAgICAgJzIuMC40JyA6ICcvNDE5JyxcbiAgICAgICAgICAgICAgICAgICAgICAnPycgICAgIDogJy8nXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGV2aWNlIDoge1xuICAgICAgICAgICAgICBhbWF6b24gOiB7XG4gICAgICAgICAgICAgICAgICBtb2RlbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAnRmlyZSBQaG9uZScgOiBbJ1NEJywgJ0tGJ11cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3ByaW50IDoge1xuICAgICAgICAgICAgICAgICAgbW9kZWwgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgJ0V2byBTaGlmdCA0RycgOiAnNzM3M0tUJ1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHZlbmRvciA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAnSFRDJyAgICAgICA6ICdBUEEnLFxuICAgICAgICAgICAgICAgICAgICAgICdTcHJpbnQnICAgIDogJ1NwcmludCdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvcyA6IHtcbiAgICAgICAgICAgICAgd2luZG93cyA6IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgJ01FJyAgICAgICAgOiAnNC45MCcsXG4gICAgICAgICAgICAgICAgICAgICAgJ05UIDMuMTEnICAgOiAnTlQzLjUxJyxcbiAgICAgICAgICAgICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgJzIwMDAnICAgICAgOiAnTlQgNS4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAnWFAnICAgICAgICA6IFsnTlQgNS4xJywgJ05UIDUuMiddLFxuICAgICAgICAgICAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgJzcnICAgICAgICAgOiAnTlQgNi4xJyxcbiAgICAgICAgICAgICAgICAgICAgICAnOCcgICAgICAgICA6ICdOVCA2LjInLFxuICAgICAgICAgICAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG4gICAgICAgICAgICAgICAgICAgICAgJzEwJyAgICAgICAgOiBbJ05UIDYuNCcsICdOVCAxMC4wJ10sXG4gICAgICAgICAgICAgICAgICAgICAgJ1JUJyAgICAgICAgOiAnQVJNJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuXG4gICAgICAvLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gUmVnZXggbWFwXG4gICAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgICAgdmFyIHJlZ2V4ZXMgPSB7XG5cbiAgICAgICAgICBicm93c2VyIDogW1tcblxuICAgICAgICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgICAgICAgLyhvcGVyYVxcc21pbmkpXFwvKFtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgTWluaVxuICAgICAgICAgICAgICAvKG9wZXJhXFxzW21vYmlsZXRhYl0rKS4rdmVyc2lvblxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNb2JpL1RhYmxldFxuICAgICAgICAgICAgICAvKG9wZXJhKS4rdmVyc2lvblxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhID4gOS44MFxuICAgICAgICAgICAgICAvKG9wZXJhKVtcXC9cXHNdKyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSA8IDkuODBcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhvcGlvcylbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhIE1pbmknXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvXFxzKG9wcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBXZWJraXRcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvLyBNaXhlZFxuICAgICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTHVuYXNjYXBlL01heHRob24vTmV0ZnJvbnQvSmFzbWluZS9CbGF6ZXJcbiAgICAgICAgICAgICAgLy8gVHJpZGVudCBiYXNlZFxuICAgICAgICAgICAgICAvKGF2YW50XFxzfGllbW9iaWxlfHNsaW0pKD86YnJvd3Nlcik/W1xcL1xcc10/KFtcXHdcXC5dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdmFudC9JRU1vYmlsZS9TbGltQnJvd3NlclxuICAgICAgICAgICAgICAvKGJpZHVicm93c2VyfGJhaWR1YnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAvLyBCYWlkdSBCcm93c2VyXG4gICAgICAgICAgICAgIC8oPzptc3xcXCgpKGllKVxccyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgICAgICAgLy8gV2Via2l0L0tIVE1MIGJhc2VkXG4gICAgICAgICAgICAgIC8ocmVrb25xKVxcLyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVrb25xXG4gICAgICAgICAgICAgIC8oY2hyb21pdW18ZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpfGlyaWRpdW18cGhhbnRvbWpzfGJvd3NlcnxxdWFya3xxdXB6aWxsYXxmYWxrb24pXFwvKFtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS9GbG9jay9Sb2NrTWVsdC9NaWRvcmkvRXBpcGhhbnkvU2lsay9Ta3lmaXJlL0JvbHQvSXJvbi9JcmlkaXVtL1BoYW50b21KUy9Cb3dzZXIvUXVwWmlsbGEvRmFsa29uXG4gICAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oa29ucXVlcm9yKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ucXVlcm9yXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0tvbnF1ZXJvciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8odHJpZGVudCkuK3J2WzpcXHNdKFtcXHdcXC5dKykuK2xpa2VcXHNnZWNrby9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnSUUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvKGVkZ2V8ZWRnaW9zfGVkZ2F8ZWRnKVxcLygoXFxkKyk/W1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgRWRnZVxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdFZGdlJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyh5YWJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZYW5kZXhcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnWWFuZGV4J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhBdmFzdClcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdmFzdCBTZWN1cmUgQnJvd3NlclxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdBdmFzdCBTZWN1cmUgQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oQVZHKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVZHIFNlY3VyZSBCcm93c2VyXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0FWRyBTZWN1cmUgQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8ocHVmZmluKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVmZmluXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1B1ZmZpbiddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oZm9jdXMpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBGb2N1c1xuICAgICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IEZvY3VzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhvcHQpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBUb3VjaFxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSBUb3VjaCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oKD86W1xcc1xcL10pdWM/XFxzP2Jyb3dzZXJ8KD86anVjLispdWN3ZWIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgIC8vIFVDQnJvd3NlclxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdVQ0Jyb3dzZXInXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvKGNvbW9kb19kcmFnb24pXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbW9kbyBEcmFnb25cbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8od2luZG93c3dlY2hhdCBxYmNvcmUpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2VDaGF0IERlc2t0b3AgZm9yIFdpbmRvd3MgQnVpbHQtaW4gQnJvd3NlclxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdXZUNoYXQoV2luKSBEZXNrdG9wJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhtaWNyb21lc3NlbmdlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZUNoYXRcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnV2VDaGF0J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhicmF2ZSlcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCcmF2ZSBicm93c2VyXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0JyYXZlJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhxcWJyb3dzZXJsaXRlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUUJyb3dzZXJMaXRlXG4gICAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oUVEpXFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVEsIGFrYSBTaG91UVxuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvbT8ocXFicm93c2VyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUUJyb3dzZXJcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhiYWlkdWJveGFwcClbXFwvXFxzXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFpZHUgQXBwXG4gICAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oMjM0NUV4cGxvcmVyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIzNDUgQnJvd3NlclxuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvKE1ldGFTcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3VHb3VCcm93c2VyXG4gICAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAgIC8oTEJCUk9XU0VSKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGllQmFvIEJyb3dzZXJcbiAgICAgICAgICAgICAgXSwgW05BTUVdLCBbXG5cbiAgICAgICAgICAgICAgL3hpYW9taVxcL21pdWlicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01JVUkgQnJvd3NlciddXSwgW1xuXG4gICAgICAgICAgICAgIC87ZmJhdlxcLyhbXFx3XFwuXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFjZWJvb2sgQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZhY2Vib29rJ11dLCBbXG5cbiAgICAgICAgICAgICAgL3NhZmFyaVxccyhsaW5lKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBBcHAgZm9yIGlPU1xuICAgICAgICAgICAgICAvYW5kcm9pZC4rKGxpbmUpXFwvKFtcXHdcXC5dKylcXC9pYWIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIEFwcCBmb3IgQW5kcm9pZFxuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvaGVhZGxlc3NjaHJvbWUoPzpcXC8oW1xcd1xcLl0rKXxcXHMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgSGVhZGxlc3NcbiAgICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ2hyb21lIEhlYWRsZXNzJ11dLCBbXG5cbiAgICAgICAgICAgICAgL1xcc3d2XFwpLisoY2hyb21lKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBXZWJWaWV3XG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKykvLCAnJDEgV2ViVmlldyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oKD86b2N1bHVzfHNhbXN1bmcpYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKyg/Omd8dXMpKSguKykvLCAnJDEgJDInXSwgVkVSU0lPTl0sIFsgICAgICAgICAgICAgICAgLy8gT2N1bHVzIC8gU2Ftc3VuZyBCcm93c2VyXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKVxccysoPzptb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkqL2kgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlclxuICAgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdBbmRyb2lkIEJyb3dzZXInXV0sIFtcblxuICAgICAgICAgICAgICAvKHNhaWxmaXNoYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhaWxmaXNoIEJyb3dzZXJcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnU2FpbGZpc2ggQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oY2hyb21lfG9tbml3ZWJ8YXJvcmF8W3RpemVub2thXXs1fVxccz9icm93c2VyKVxcL3Y/KFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG4gICAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oZG9sZmluKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9scGhpblxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdEb2xwaGluJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLyhxaWh1fHFoYnJvd3NlcnxxaWhvb2Jyb3dzZXJ8MzYwYnJvd3NlcikvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzNjBcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnMzYwIEJyb3dzZXInXV0sIFtcblxuICAgICAgICAgICAgICAvKCg/OmFuZHJvaWQuKyljcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZC9pT1NcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21lIE1vYmlsZSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oY29hc3QpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgQ29hc3RcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEgQ29hc3QnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvZnhpb3NcXC8oW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZm9yIGlPU1xuICAgICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdGaXJlZm94J11dLCBbXG5cbiAgICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rP21vYmlsZVxcL1xcdytcXHMoc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01vYmlsZSBTYWZhcmknXV0sIFtcblxuICAgICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgJiBTYWZhcmkgTW9iaWxlXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgW1xuXG4gICAgICAgICAgICAgIC93ZWJraXQuKz8oZ3NhKVxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgIC8vIEdvb2dsZSBTZWFyY2ggQXBwbGlhbmNlIG9uIGlPU1xuICAgICAgICAgICAgICBdLCBbW05BTUUsICdHU0EnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvd2Via2l0Lis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPCAzLjBcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLmJyb3dzZXIub2xkc2FmYXJpLnZlcnNpb25dXSwgW1xuXG4gICAgICAgICAgICAgIC8od2Via2l0fGtodG1sKVxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLy8gR2Vja28gYmFzZWRcbiAgICAgICAgICAgICAgLyhuYXZpZ2F0b3J8bmV0c2NhcGUpXFwvKFtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRzY2FwZVxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdOZXRzY2FwZSddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG4gICAgICAgICAgICAgIC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW9cXHNicm93c2VyfG1pbmltb3xjb25rZXJvcilbXFwvXFxzXT8oW1xcd1xcLlxcK10rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEljZURyYWdvbi9JY2V3ZWFzZWwvQ2FtaW5vL0NoaW1lcmEvRmVubmVjL01hZW1vL01pbmltby9Db25rZXJvclxuICAgICAgICAgICAgICAvKGZpcmVmb3h8c2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peHxwYWxlbW9vbnxiYXNpbGlza3x3YXRlcmZveClcXC8oW1xcd1xcLi1dKykkL2ksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94L1NlYU1vbmtleS9LLU1lbGVvbi9JY2VDYXQvSWNlQXBlL0ZpcmViaXJkL1Bob2VuaXhcbiAgICAgICAgICAgICAgLyhtb3ppbGxhKVxcLyhbXFx3XFwuXSspLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ppbGxhXG5cbiAgICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgICAgLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvbGFyaXMvTHlueC9EaWxsby9pQ2FiL0RvcmlzL0FtYXlhL3czbS9OZXRTdXJmL1NsZWlwbmlyXG4gICAgICAgICAgICAgIC8obGlua3MpXFxzXFwoKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmtzXG4gICAgICAgICAgICAgIC8oZ29icm93c2VyKVxcLz8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29Ccm93c2VyXG4gICAgICAgICAgICAgIC8oaWNlXFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl9dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElDRSBCcm93c2VyXG4gICAgICAgICAgICAgIC8obW9zYWljKVtcXC9cXHNdKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vc2FpY1xuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cbiAgICAgICAgICBdLFxuXG4gICAgICAgICAgY3B1IDogW1tcblxuICAgICAgICAgICAgICAvKD86KGFtZHx4KD86KD86ODZ8NjQpW18tXSk/fHdvd3x3aW4pNjQpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAvLyBBTUQ2NFxuICAgICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbXG5cbiAgICAgICAgICAgICAgLyhpYTMyKD89OykpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTMyIChxdWlja3RpbWUpXG4gICAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCB1dGlsLmxvd2VyaXplXV0sIFtcblxuICAgICAgICAgICAgICAvKCg/OmlbMzQ2XXx4KTg2KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTMyXG4gICAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgICAgICAgIC8vIFBvY2tldFBDIG1pc3Rha2VubHkgaWRlbnRpZmllZCBhcyBQb3dlclBDXG4gICAgICAgICAgICAgIC93aW5kb3dzXFxzKGNlfG1vYmlsZSk7XFxzcHBjOy9pXG4gICAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtJ11dLCBbXG5cbiAgICAgICAgICAgICAgLygoPzpwcGN8cG93ZXJwYykoPzo2NCk/KSg/Olxcc21hY3w7fFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvd2VyUENcbiAgICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIC9vd2VyLywgJycsIHV0aWwubG93ZXJpemVdXSwgW1xuXG4gICAgICAgICAgICAgIC8oc3VuNFxcdylbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTUEFSQ1xuICAgICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ3NwYXJjJ11dLCBbXG5cbiAgICAgICAgICAgICAgLygoPzphdnIzMnxpYTY0KD89OykpfDY4ayg/PVxcKSl8YXJtKD86NjR8KD89dlxcZCtbO2xdKSl8KD89YXRtZWxcXHMpYXZyfCg/OmlyaXh8bWlwc3xzcGFyYykoPzo2NCk/KD89Oyl8cGEtcmlzYykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBNjQsIDY4SywgQVJNLzY0LCBBVlIvMzIsIElSSVgvNjQsIE1JUFMvNjQsIFNQQVJDLzY0LCBQQS1SSVNDXG4gICAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCB1dGlsLmxvd2VyaXplXV1cbiAgICAgICAgICBdLFxuXG4gICAgICAgICAgZGV2aWNlIDogW1tcblxuICAgICAgICAgICAgICAvXFwoKGlwYWR8cGxheWJvb2spO1tcXHdcXHNcXCksOy1dKyhyaW18YXBwbGUpL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkL1BsYXlCb29rXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYXBwbGVjb3JlbWVkaWFcXC9bXFx3XFwuXSsgXFwoKGlwYWQpLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FwcGxlJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC8oYXBwbGVcXHN7MCwxfXR2KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIFRWXG4gICAgICAgICAgICAgIF0sIFtbTU9ERUwsICdBcHBsZSBUViddLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAgIC8oYXJjaG9zKVxccyhnYW1lcGFkMj8pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyY2hvc1xuICAgICAgICAgICAgICAvKGhwKS4rKHRvdWNocGFkKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhQIFRvdWNoUGFkXG4gICAgICAgICAgICAgIC8oaHApLisodGFibGV0KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVGFibGV0XG4gICAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAgIC9cXHMobm9vaylbXFx3XFxzXStidWlsZFxcLyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb29rXG4gICAgICAgICAgICAgIC8oZGVsbClcXHMoc3RyZWFba3ByXFxzXFxkXSpbXFxka29dKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgU3RyZWFrXG4gICAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvKGtmW0Etel0rKVxcc2J1aWxkXFwvLitzaWxrXFwvL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZSBGaXJlIEhEXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgICAgLyhzZHxrZilbMDM0OWhpam9yc3R1d10rXFxzYnVpbGRcXC8uK3NpbGtcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFBob25lXG4gICAgICAgICAgICAgIF0sIFtbTU9ERUwsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLmFtYXpvbi5tb2RlbF0sIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgIC9hbmRyb2lkLithZnQoW2Jtc10pXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgVFZcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgICAvXFwoKGlwW2hvbmVkfFxcc1xcdypdKyk7LisoYXBwbGUpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQb2QvaVBob25lXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgICAgL1xcKChpcFtob25lZHxcXHNcXHcqXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcHBsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvKGJsYWNrYmVycnkpW1xccy1dPyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgICAvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzfGRlbGx8bWVpenV8bW90b3JvbGF8cG9seXRyb24pW1xcc18tXT8oW1xcdy1dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZW5RL1BhbG0vU29ueS1Fcmljc3Nvbi9BY2VyL0FzdXMvRGVsbC9NZWl6dS9Nb3Rvcm9sYS9Qb2x5dHJvblxuICAgICAgICAgICAgICAvKGhwKVxccyhbXFx3XFxzXStcXHcpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBpUEFRXG4gICAgICAgICAgICAgIC8oYXN1cyktPyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdXNcbiAgICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgICAvXFwoYmIxMDtcXHMoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQmxhY2tCZXJyeSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VzIFRhYmxldHNcbiAgICAgICAgICAgICAgL2FuZHJvaWQuKyh0cmFuc2ZvW3ByaW1lXFxzXXs0LDEwfVxcc1xcdyt8ZWVlcGN8c2xpZGVyXFxzXFx3K3xuZXh1cyA3fHBhZGZvbmV8cDAwYykvaVxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBc3VzJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC8oc29ueSlcXHModGFibGV0XFxzW3BzXSlcXHNidWlsZFxcLy9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb255XG4gICAgICAgICAgICAgIC8oc29ueSk/KD86c2dwLispXFxzYnVpbGRcXC8vaVxuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NvbnknXSwgW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgICAgL2FuZHJvaWQuK1xccyhbYy1nXVxcZHs0fXxzb1stbF1cXHcrKSg/PVxcc2J1aWxkXFwvfFxcKS4rY2hyb21lXFwvKD8hWzEtNl17MCwxfVxcZFxcLikpL2lcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU29ueSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvXFxzKG91eWEpXFxzL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V5YVxuICAgICAgICAgICAgICAvKG5pbnRlbmRvKVxccyhbd2lkczN1XSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kb1xuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIENPTlNPTEVdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHNoaWVsZClcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOdmlkaWFcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgICAvKHBsYXlzdGF0aW9uXFxzWzM0cG9ydGFibGV2aV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGF5c3RhdGlvblxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgICAvKHNwcmludFxccyhcXHcrKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW50IFBob25lc1xuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2Uuc3ByaW50LnZlbmRvcl0sIFtNT0RFTCwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2Uuc3ByaW50Lm1vZGVsXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgLyhodGMpWztfXFxzLV0rKFtcXHdcXHNdKyg/PVxcKXxcXHNidWlsZCl8XFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgICAgLyh6dGUpLShcXHcqKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFXG4gICAgICAgICAgICAgIC8oYWxjYXRlbHxnZWVrc3Bob25lfG5leGlhbnxwYW5hc29uaWN8KD89O1xccylzb255KVtfXFxzLV0/KFtcXHctXSopL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtNT0RFTCwgL18vZywgJyAnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgLyhuZXh1c1xcczkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE5leHVzIDlcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSFRDJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9kXFwvaHVhd2VpKFtcXHdcXHMtXSspWztcXCldL2ksXG4gICAgICAgICAgICAgIC8obmV4dXNcXHM2cHx2b2ctbDI5fGFuZS1seDF8ZW1sLWwyOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh1YXdlaVxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIdWF3ZWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKyhiYWgyPy1hP1tsd11cXGR7Mn0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVhd2VpIE1lZGlhUGFkXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0h1YXdlaSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvKG1pY3Jvc29mdCk7XFxzKGx1bWlhW1xcc1xcd10rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBMdW1pYVxuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgL1tcXHNcXCg7XSh4Ym94KD86XFxzb25lKT8pW1xcc1xcKTtdL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94XG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01pY3Jvc29mdCddLCBbVFlQRSwgQ09OU09MRV1dLCBbXG4gICAgICAgICAgICAgIC8oa2luXFwuW29uZXR3XXszfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBLaW5cbiAgICAgICAgICAgICAgXSwgW1tNT0RFTCwgL1xcLi9nLCAnICddLCBbVkVORE9SLCAnTWljcm9zb2Z0J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW90b3JvbGFcbiAgICAgICAgICAgICAgL1xccyhtaWxlc3RvbmV8ZHJvaWQoPzpbMi00eF18XFxzKD86YmlvbmljfHgyfHByb3xyYXpyKSk/Oj8oXFxzNGcpPylbXFx3XFxzXStidWlsZFxcLy9pLFxuICAgICAgICAgICAgICAvbW90W1xccy1dPyhcXHcqKS9pLFxuICAgICAgICAgICAgICAvKFhUXFxkezMsNH0pIGJ1aWxkXFwvL2ksXG4gICAgICAgICAgICAgIC8obmV4dXNcXHM2KS9pXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01vdG9yb2xhJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgICAvYW5kcm9pZC4rXFxzKG16NjBcXGR8eG9vbVtcXHMyXXswLDJ9KVxcc2J1aWxkXFwvL2lcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2hiYnR2XFwvXFxkK1xcLlxcZCtcXC5cXGQrXFxzK1xcKFtcXHdcXHNdKjtcXHMqKFxcd1teO10qKTsoW147XSopL2kgICAgICAgICAgICAvLyBIYmJUViBkZXZpY2VzXG4gICAgICAgICAgICAgIF0sIFtbVkVORE9SLCB1dGlsLnRyaW1dLCBbTU9ERUwsIHV0aWwudHJpbV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgICAvaGJidHYuK21hcGxlOyhcXGQrKS9pXG4gICAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9eLywgJ1NtYXJ0VFYnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAgIC9cXChkdHZbXFwpO10uKyhhcXVvcykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFycFxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaGFycCddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKygoc2NoLWlbODldMFxcZHxzaHctbTM4MHN8Z3QtcFxcZHs0fXxndC1uXFxkK3xzZ2gtdDhbNTZdOXxuZXh1cyAxMCkpL2ksXG4gICAgICAgICAgICAgIC8oKFNNLVRcXHcrKSkvaVxuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgWyAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmdcbiAgICAgICAgICAgICAgL3NtYXJ0LXR2Lisoc2Ftc3VuZykvaVxuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgU01BUlRUVl0sIE1PREVMXSwgW1xuICAgICAgICAgICAgICAvKChzW2NncF1oLVxcdyt8Z3QtXFx3K3xnYWxheHlcXHNuZXh1c3xzbS1cXHdbXFx3XFxkXSspKS9pLFxuICAgICAgICAgICAgICAvKHNhbVtzdW5nXSopW1xccy1dKihcXHcrLT9bXFx3LV0qKS9pLFxuICAgICAgICAgICAgICAvc2VjLSgoc2doXFx3KykpL2lcbiAgICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdTYW1zdW5nJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvc2llLShcXHcqKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaWVtZW5zXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NpZW1lbnMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgLyhtYWVtb3xub2tpYSkuKihuOTAwfGx1bWlhXFxzXFxkKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5va2lhXG4gICAgICAgICAgICAgIC8obm9raWEpW1xcc18tXT8oW1xcdy1dKikvaVxuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ05va2lhJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZFt4XFxkXFwuXFxzO10rXFxzKFthYl1bMS03XVxcLT9bMDE3OGFdXFxkXFxkPykvaSAgICAgICAgICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FjZXInXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKyhbdmxda1xcLT9cXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMRyBUYWJsZXRcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAgIC9hbmRyb2lkXFxzM1xcLltcXHNcXHc7LV17MTB9KGxnPyktKFswNmN2OV17Myw0fSkvaSAgICAgICAgICAgICAgICAgICAgIC8vIExHIFRhYmxldFxuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0xHJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgICAgLyhsZykgbmV0Y2FzdFxcLnR2L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEcgU21hcnRUVlxuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgICAvKG5leHVzXFxzWzQ1XSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMR1xuICAgICAgICAgICAgICAvbGdbZTtcXHNcXC8tXSsoXFx3KikvaSxcbiAgICAgICAgICAgICAgL2FuZHJvaWQuK2xnKFxcLT9bXFxkXFx3XSspXFxzK2J1aWxkL2lcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgLyhsZW5vdm8pXFxzPyhzKD86NTAwMHw2MDAwKSg/OltcXHctXSspfHRhYig/OltcXHNcXHddKykpL2kgICAgICAgICAgICAgLy8gTGVub3ZvIHRhYmxldHNcbiAgICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgICAvYW5kcm9pZC4rKGlkZWF0YWJbYS16MC05XFwtXFxzXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xlbm92byddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgICAgLyhsZW5vdm8pW19cXHMtXT8oW1xcdy1dKykvaVxuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgL2xpbnV4Oy4rKChqb2xsYSkpOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xsYVxuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgLygocGViYmxlKSlhcHBcXC9bXFxkXFwuXStcXHMvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGViYmxlXG4gICAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKG9wcG8pXFxzPyhbXFx3XFxzXSspXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPUFBPXG4gICAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvY3JrZXkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWVjYXN0XG4gICAgICAgICAgICAgIF0sIFtbTU9ERUwsICdDaHJvbWVjYXN0J10sIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGdsYXNzKVxcc1xcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIEdsYXNzXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dvb2dsZSddLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHBpeGVsIGMpW1xccyldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWwgQ1xuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMocGl4ZWwoIFsyM10pPyggeGwpPylbXFxzKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbFxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoXFx3KylcXHMrYnVpbGRcXC9obVxcMS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgICAvYW5kcm9pZC4rKGhtW1xcc1xcLV9dKm5vdGU/W1xcc19dKig/OlxcZFxcdyk/KVxccytidWlsZC9pLCAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWlcbiAgICAgICAgICAgICAgL2FuZHJvaWQuKyhtaVtcXHNcXC1fXSooPzphXFxkfG9uZXxvbmVbXFxzX11wbHVzfG5vdGUgbHRlKT9bXFxzX10qKD86XFxkP1xcdz8pW1xcc19dKig/OnBsdXMpPylcXHMrYnVpbGQvaSwgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIE1pXG4gICAgICAgICAgICAgIC9hbmRyb2lkLisocmVkbWlbXFxzXFwtX10qKD86bm90ZSk/KD86W1xcc19dKltcXHdcXHNdKykpXFxzK2J1aWxkL2kgICAgICAgLy8gUmVkbWkgUGhvbmVzXG4gICAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsICdYaWFvbWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgIC9hbmRyb2lkLisobWlbXFxzXFwtX10qKD86cGFkKSg/OltcXHNfXSpbXFx3XFxzXSspKVxccytidWlsZC9pICAgICAgICAgICAgLy8gTWkgUGFkIHRhYmxldHNcbiAgICAgICAgICAgICAgXSxbW01PREVMLCAvXy9nLCAnICddLCBbVkVORE9SLCAnWGlhb21pJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhtWzEtNV1cXHNub3RlKVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1laXp1XG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01laXp1J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgICAvKG16KS0oW1xcdy1dezIsfSkvaVxuICAgICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ01laXp1J10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rYTAwMCgxKVxccytidWlsZC9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmVQbHVzXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitvbmVwbHVzXFxzKGFcXGR7NH0pW1xccyldL2lcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnT25lUGx1cyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihSQ1RbXFxkXFx3XSspXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkNBIFRhYmxldHNcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUkNBJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL1xcc10rKFZlbnVlW1xcZFxcc117Miw3fSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxsIFZlbnVlIFRhYmxldHNcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRGVsbCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihRW1R8TV1bXFxkXFx3XSspXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaXpvbiBUYWJsZXRcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVmVyaXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhCYXJuZXNbJlxcc10rTm9ibGVcXHMrfEJOW1JUXSkoVj8uKilcXHMrYnVpbGQvaSAgICAgLy8gQmFybmVzICYgTm9ibGUgVGFibGV0XG4gICAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnQmFybmVzICYgTm9ibGUnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMrKFRNXFxkezN9LipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXJuZXMgJiBOb2JsZSBUYWJsZXRcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnVWaXNpb24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoazg4KVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURSBLIFNlcmllcyBUYWJsZXRcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWlRFJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKGdlblxcZHszfSlcXHMrYnVpbGQuKjQ5aC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIEdFTiBNb2JpbGVcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU3dpc3MnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooenVyXFxkezN9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpc3MgWlVSIFRhYmxldFxuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKigoWmVraSk/VEIuKlxcYilcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaZWtpIFRhYmxldHNcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWmVraSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvKGFuZHJvaWQpLitbO1xcL11cXHMrKFtZUl1cXGR7Mn0pXFxzK2J1aWxkL2ksXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMrKERyYWdvbltcXC1cXHNdK1RvdWNoXFxzK3xEVCkoXFx3ezV9KVxcc2J1aWxkL2kgICAgICAgIC8vIERyYWdvbiBUb3VjaCBUYWJsZXRcbiAgICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdEcmFnb24gVG91Y2gnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKE5TLT9cXHd7MCw5fSlcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSW5zaWduaWEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooKE5YfE5leHQpLT9cXHd7MCw5fSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgLy8gTmV4dEJvb2sgVGFibGV0c1xuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOZXh0Qm9vayddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihYdHJlbWVcXF8pPyhWKDFbMDQ1XXwyWzAxNV18MzB8NDB8NjB8N1swNV18OTApKVxccytidWlsZC9pXG4gICAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnVm9pY2UnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgWyAgICAgICAgICAgICAgICAgICAgLy8gVm9pY2UgWHRyZW1lIFBob25lc1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExWVEVMXFwtKT8oVjFbMTJdKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgLy8gTHZUZWwgUGhvbmVzXG4gICAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTHZUZWwnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKFBILTEpXFxzL2lcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRXNzZW50aWFsJ10sIFtUWVBFLCBNT0JJTEVdXSwgWyAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWwgUEgtMVxuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFYoMTAwTUR8NzAwTkF8NzAxMXw5MTdHKS4qXFxiKVxccytidWlsZC9pICAgICAgICAgIC8vIEVudml6ZW4gVGFibGV0c1xuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdFbnZpemVuJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExlW1xcc1xcLV0rUGFuKVtcXHNcXC1dKyhcXHd7MSw5fSlcXHMrYnVpbGQvaSAgICAgICAgICAvLyBMZSBQYW4gVGFibGV0c1xuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooVHJpb1tcXHNcXC1dKi4qKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hY2hTcGVlZCBUYWJsZXRzXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01hY2hTcGVlZCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihUcmluaXR5KVtcXC1cXHNdKihUXFxkezN9KVxccytidWlsZC9pICAgICAgICAgICAgICAgIC8vIFRyaW5pdHkgVGFibGV0c1xuICAgICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccypUVV8oMTQ5MSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RvciBUYWJsZXRzXG4gICAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JvdG9yJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAgIC9hbmRyb2lkLisoS1MoLispKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFtYXpvbiBLaW5kbGUgVGFibGV0c1xuICAgICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgICAgL2FuZHJvaWQuKyhHaWdhc2V0KVtcXHNcXC1dKyhRXFx3ezEsOX0pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgLy8gR2lnYXNldCBUYWJsZXRzXG4gICAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgICAvXFxzKHRhYmxldHx0YWIpWztcXC9dL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgICAgICAgIC9cXHMobW9iaWxlKSg/Ols7XFwvXXxcXHNzYWZhcmkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgTW9iaWxlXG4gICAgICAgICAgICAgIF0sIFtbVFlQRSwgdXRpbC5sb3dlcml6ZV0sIFZFTkRPUiwgTU9ERUxdLCBbXG5cbiAgICAgICAgICAgICAgL1tcXHNcXC9cXChdKHNtYXJ0LT90dilbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU21hcnRUVlxuICAgICAgICAgICAgICBdLCBbW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAgIC8oYW5kcm9pZFtcXHdcXC5cXHNcXC1dezAsOX0pOy4rYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgQW5kcm9pZCBEZXZpY2VcbiAgICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuICAgICAgICAgIF0sXG5cbiAgICAgICAgICBlbmdpbmUgOiBbW1xuXG4gICAgICAgICAgICAgIC93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VIVE1MXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0VkZ2VIVE1MJ11dLCBbXG5cbiAgICAgICAgICAgICAgL3dlYmtpdFxcLzUzN1xcLjM2LitjaHJvbWVcXC8oPyEyNykoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsaW5rXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0JsaW5rJ11dLCBbXG5cbiAgICAgICAgICAgICAgLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzdG9cbiAgICAgICAgICAgICAgLyh3ZWJraXR8dHJpZGVudHxuZXRmcm9udHxuZXRzdXJmfGFtYXlhfGx5bnh8dzNtfGdvYW5uYSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2ViS2l0L1RyaWRlbnQvTmV0RnJvbnQvTmV0U3VyZi9BbWF5YS9MeW54L3czbS9Hb2FubmFcbiAgICAgICAgICAgICAgLyhraHRtbHx0YXNtYW58bGlua3MpW1xcL1xcc11cXCg/KFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtIVE1ML1Rhc21hbi9MaW5rc1xuICAgICAgICAgICAgICAvKGljYWIpW1xcL1xcc10oWzIzXVxcLltcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaUNhYlxuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgICAvcnZcXDooW1xcd1xcLl17MSw5fSkuKyhnZWNrbykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvXG4gICAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXVxuICAgICAgICAgIF0sXG5cbiAgICAgICAgICBvcyA6IFtbXG5cbiAgICAgICAgICAgICAgLy8gV2luZG93cyBiYXNlZFxuICAgICAgICAgICAgICAvbWljcm9zb2Z0XFxzKHdpbmRvd3MpXFxzKHZpc3RhfHhwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyAoaVR1bmVzKVxuICAgICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgICAgLyh3aW5kb3dzKVxcc250XFxzNlxcLjI7XFxzKGFybSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBSVFxuICAgICAgICAgICAgICAvKHdpbmRvd3NcXHNwaG9uZSg/Olxcc29zKSopW1xcc1xcL10/KFtcXGRcXC5cXHNcXHddKikvaSwgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBQaG9uZVxuICAgICAgICAgICAgICAvKHdpbmRvd3NcXHNtb2JpbGV8d2luZG93cylbXFxzXFwvXT8oW250Y2VcXGRcXC5cXHNdK1xcdykvaVxuICAgICAgICAgICAgICBdLCBbW05BTUUsIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy5uYW1lXSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcbiAgICAgICAgICAgICAgLyh3aW4oPz0zfDl8bil8d2luXFxzOXhcXHMpKFtudFxcZFxcLl0rKS9pXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dpbmRvd3MnXSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcblxuICAgICAgICAgICAgICAvLyBNb2JpbGUvRW1iZWRkZWQgT1NcbiAgICAgICAgICAgICAgL1xcKChiYikoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdCbGFja0JlcnJ5J10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcbiAgICAgICAgICAgICAgLyh0aXplbnxrYWlvcylbXFwvXFxzXShbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW4vS2FpT1NcbiAgICAgICAgICAgICAgLyhhbmRyb2lkfHdlYm9zfHBhbG1cXHNvc3xxbnh8YmFkYXxyaW1cXHN0YWJsZXRcXHNvc3xtZWVnb3xzYWlsZmlzaHxjb250aWtpKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZC9XZWJPUy9QYWxtL1FOWC9CYWRhL1JJTS9NZWVHby9Db250aWtpL1NhaWxmaXNoIE9TXG4gICAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgICAvKHN5bWJpYW5cXHM/b3N8c3ltYm9zfHM2MCg/PTspKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgLy8gU3ltYmlhblxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdTeW1iaWFuJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuICAgICAgICAgICAgICBdLCBbTkFNRV0sIFtcbiAgICAgICAgICAgICAgL21vemlsbGEuK1xcKG1vYmlsZTsuK2dlY2tvLitmaXJlZm94L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBPU1xuICAgICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IE9TJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLy8gQ29uc29sZVxuICAgICAgICAgICAgICAvKG5pbnRlbmRvfHBsYXlzdGF0aW9uKVxccyhbd2lkczM0cG9ydGFibGV2dV0rKS9pLCAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kby9QbGF5c3RhdGlvblxuXG4gICAgICAgICAgICAgIC8vIEdOVS9MaW51eCBiYXNlZFxuICAgICAgICAgICAgICAvKG1pbnQpW1xcL1xcc1xcKF0/KFxcdyopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaW50XG4gICAgICAgICAgICAgIC8obWFnZWlhfHZlY3RvcmxpbnV4KVs7XFxzXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hZ2VpYS9WZWN0b3JMaW51eFxuICAgICAgICAgICAgICAvKGpvbGl8W2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298KD89XFxzKWFyY2h8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZGhhdHx6ZW53YWxrfGxpbnB1cylbXFwvXFxzLV0/KD8hY2hyb20pKFtcXHdcXC4tXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9saS9VYnVudHUvRGViaWFuL1NVU0UvR2VudG9vL0FyY2gvU2xhY2t3YXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmVkb3JhL01hbmRyaXZhL0NlbnRPUy9QQ0xpbnV4T1MvUmVkSGF0L1plbndhbGsvTGlucHVzXG4gICAgICAgICAgICAgIC8oaHVyZHxsaW51eClcXHM/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVyZC9MaW51eFxuICAgICAgICAgICAgICAvKGdudSlcXHM/KFtcXHdcXC5dKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdOVVxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdMaW51eCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAgIC8oY3JvcylcXHNbXFx3XStcXHMoW1xcd1xcLl0rXFx3KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0gT1NcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21pdW0gT1MnXSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgICAgLyhzdW5vcylcXHM/KFtcXHdcXC5cXGRdKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgICBdLCBbW05BTUUsICdTb2xhcmlzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgICAgLy8gQlNEIGJhc2VkXG4gICAgICAgICAgICAgIC9cXHMoW2ZyZW50b3BjLV17MCw0fWJzZHxkcmFnb25mbHkpXFxzPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAgIC8vIEZyZWVCU0QvTmV0QlNEL09wZW5CU0QvUEMtQlNEL0RyYWdvbkZseVxuICAgICAgICAgICAgICBdLCBbW05BTUUsICdMaW51eCddLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgICAgLyhpcGhvbmUpKD86Lipvc1xccyooW1xcd10qKVxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pICAgICAgICAgICAgICAgICAgLy8gaU9TXG4gICAgICAgICAgICAgIF0sIFtbTkFNRSwgJ2lQaG9uZSddLCBbVkVSU0lPTiwgL18vZywgJy4nXV0sIFtcblxuICAgICAgICAgICAgICAvKGlwYWQpKD86Lipvc1xccyooW1xcd10qKVxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pICAgICAgICAgICAgICAgICAgICAvLyBpT1NcbiAgICAgICAgICAgICAgXSwgW1tOQU1FLCAnaVBhZCddLCBbVkVSU0lPTiwgL18vZywgJy4nXV0sIFtcblxuICAgICAgICAgICAgICAvKGhhaWt1KVxccyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFpa3VcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgICAvY2ZuZXR3b3JrXFwvLitkYXJ3aW4vaSxcbiAgICAgICAgICAgICAgL2lwW2hvbmVhZF17Miw0fSg/Oi4qb3NcXHMoW1xcd10rKVxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pICAgICAgICAgICAgIC8vIGlPU1xuICAgICAgICAgICAgICBdLCBbW1ZFUlNJT04sIC9fL2csICcuJ10sIFtOQU1FLCAnaU9TJ11dLCBbXG5cbiAgICAgICAgICAgICAgLyhtYWNcXHNvc1xcc3gpXFxzPyhbXFx3XFxzXFwuXSopL2ksXG4gICAgICAgICAgICAgIC8obWFjaW50b3NofG1hYyg/PV9wb3dlcnBjKVxccykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hYyBPU1xuICAgICAgICAgICAgICBdLCBbW05BTUUsICdNYWMnXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbXG5cbiAgICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgICAgLygoPzpvcGVuKT9zb2xhcmlzKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgICAvKGFpeClcXHMoKFxcZCkoPz1cXC58XFwpfFxccylbXFx3XFwuXSkqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBSVhcbiAgICAgICAgICAgICAgLyhwbGFuXFxzOXxtaW5peHxiZW9zfG9zXFwvMnxhbWlnYW9zfG1vcnBob3N8cmlzY1xcc29zfG9wZW52bXN8ZnVjaHNpYSkvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFuOS9NaW5peC9CZU9TL09TMi9BbWlnYU9TL01vcnBoT1MvUklTQ09TL09wZW5WTVMvRnVjaHNpYVxuICAgICAgICAgICAgICAvKHVuaXgpXFxzPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVOSVhcbiAgICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dXG4gICAgICAgICAgXVxuICAgICAgfTtcblxuXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gQ29uc3RydWN0b3JcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy9cbiAgICAgIHZhciBVQVBhcnNlciA9IGZ1bmN0aW9uICh1YXN0cmluZywgZXh0ZW5zaW9ucykge1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB1YXN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IHVhc3RyaW5nO1xuICAgICAgICAgICAgICB1YXN0cmluZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVQVBhcnNlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVQVBhcnNlcih1YXN0cmluZywgZXh0ZW5zaW9ucykuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHVhID0gdWFzdHJpbmcgfHwgKCh3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IEVNUFRZKTtcbiAgICAgICAgICB2YXIgcmd4bWFwID0gZXh0ZW5zaW9ucyA/IHV0aWwuZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIDogcmVnZXhlcztcblxuICAgICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSB7IG5hbWU6IHVuZGVmaW5lZCQxLCB2ZXJzaW9uOiB1bmRlZmluZWQkMSB9O1xuICAgICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoYnJvd3NlciwgdWEsIHJneG1hcC5icm93c2VyKTtcbiAgICAgICAgICAgICAgYnJvd3Nlci5tYWpvciA9IHV0aWwubWFqb3IoYnJvd3Nlci52ZXJzaW9uKTsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZ2V0Q1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgY3B1ID0geyBhcmNoaXRlY3R1cmU6IHVuZGVmaW5lZCQxIH07XG4gICAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChjcHUsIHVhLCByZ3htYXAuY3B1KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNwdTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZ2V0RGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgZGV2aWNlID0geyB2ZW5kb3I6IHVuZGVmaW5lZCQxLCBtb2RlbDogdW5kZWZpbmVkJDEsIHR5cGU6IHVuZGVmaW5lZCQxIH07XG4gICAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChkZXZpY2UsIHVhLCByZ3htYXAuZGV2aWNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRldmljZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZ2V0RW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgZW5naW5lID0geyBuYW1lOiB1bmRlZmluZWQkMSwgdmVyc2lvbjogdW5kZWZpbmVkJDEgfTtcbiAgICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGVuZ2luZSwgdWEsIHJneG1hcC5lbmdpbmUpO1xuICAgICAgICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5nZXRPUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG9zID0geyBuYW1lOiB1bmRlZmluZWQkMSwgdmVyc2lvbjogdW5kZWZpbmVkJDEgfTtcbiAgICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKG9zLCB1YSwgcmd4bWFwLm9zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5nZXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB1YSAgICAgIDogdGhpcy5nZXRVQSgpLFxuICAgICAgICAgICAgICAgICAgYnJvd3NlciA6IHRoaXMuZ2V0QnJvd3NlcigpLFxuICAgICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgICBvcyAgICAgIDogdGhpcy5nZXRPUygpLFxuICAgICAgICAgICAgICAgICAgZGV2aWNlICA6IHRoaXMuZ2V0RGV2aWNlKCksXG4gICAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVhO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRVQSA9IGZ1bmN0aW9uICh1YXN0cmluZykge1xuICAgICAgICAgICAgICB1YSA9IHVhc3RyaW5nO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgVUFQYXJzZXIuVkVSU0lPTiA9IExJQlZFUlNJT047XG4gICAgICBVQVBhcnNlci5CUk9XU0VSID0ge1xuICAgICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICAgIE1BSk9SICAgOiBNQUpPUiwgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgICB9O1xuICAgICAgVUFQYXJzZXIuQ1BVID0ge1xuICAgICAgICAgIEFSQ0hJVEVDVFVSRSA6IEFSQ0hJVEVDVFVSRVxuICAgICAgfTtcbiAgICAgIFVBUGFyc2VyLkRFVklDRSA9IHtcbiAgICAgICAgICBNT0RFTCAgIDogTU9ERUwsXG4gICAgICAgICAgVkVORE9SICA6IFZFTkRPUixcbiAgICAgICAgICBUWVBFICAgIDogVFlQRSxcbiAgICAgICAgICBDT05TT0xFIDogQ09OU09MRSxcbiAgICAgICAgICBNT0JJTEUgIDogTU9CSUxFLFxuICAgICAgICAgIFNNQVJUVFYgOiBTTUFSVFRWLFxuICAgICAgICAgIFRBQkxFVCAgOiBUQUJMRVQsXG4gICAgICAgICAgV0VBUkFCTEU6IFdFQVJBQkxFLFxuICAgICAgICAgIEVNQkVEREVEOiBFTUJFRERFRFxuICAgICAgfTtcbiAgICAgIFVBUGFyc2VyLkVOR0lORSA9IHtcbiAgICAgICAgICBOQU1FICAgIDogTkFNRSxcbiAgICAgICAgICBWRVJTSU9OIDogVkVSU0lPTlxuICAgICAgfTtcbiAgICAgIFVBUGFyc2VyLk9TID0ge1xuICAgICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgICB9O1xuXG4gICAgICAvLy8vLy8vLy8vL1xuICAgICAgLy8gRXhwb3J0XG4gICAgICAvLy8vLy8vLy8vXG5cblxuICAgICAgLy8gY2hlY2sganMgZW52aXJvbm1lbnRcbiAgICAgIHtcbiAgICAgICAgICAvLyBub2RlanMgZW52XG4gICAgICAgICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFVBUGFyc2VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGpRdWVyeS9aZXB0byBzcGVjaWZpYyAob3B0aW9uYWwpXG4gICAgICAvLyBOb3RlOlxuICAgICAgLy8gICBJbiBBTUQgZW52IHRoZSBnbG9iYWwgc2NvcGUgc2hvdWxkIGJlIGtlcHQgY2xlYW4sIGJ1dCBqUXVlcnkgaXMgYW4gZXhjZXB0aW9uLlxuICAgICAgLy8gICBqUXVlcnkgYWx3YXlzIGV4cG9ydHMgdG8gZ2xvYmFsIHNjb3BlLCB1bmxlc3MgalF1ZXJ5Lm5vQ29uZmxpY3QodHJ1ZSkgaXMgdXNlZCxcbiAgICAgIC8vICAgYW5kIHdlIHNob3VsZCBjYXRjaCB0aGF0LlxuICAgICAgdmFyICQgPSB3aW5kb3cgJiYgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvKTtcbiAgICAgIGlmICgkICYmICEkLnVhKSB7XG4gICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgICAgICAgICQudWEgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgJC51YS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgICQudWEuc2V0ID0gZnVuY3Rpb24gKHVhc3RyaW5nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zZXRVQSh1YXN0cmluZyk7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAkLnVhW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICB9KSh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IGNvbW1vbmpzR2xvYmFsKTtcbiAgfSk7XG4gIHZhciB1YVBhcnNlcl8xID0gdWFQYXJzZXIuVUFQYXJzZXI7XG5cbiAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlLCBsYXhicmVhazogdHJ1ZSAqL1xuXG4gIC8qKlxuICAgKiBTb3VyY2U6IFtqZWQncyBnaXN0XXtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS85ODI4ODN9LlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIHY0IFVVSUQgb2YgdGhlIGZvcm0geHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4LFxuICAgKiB3aGVyZSBlYWNoIHggaXMgcmVwbGFjZWQgd2l0aCBhIHJhbmRvbSBoZXhhZGVjaW1hbCBkaWdpdCBmcm9tIDAgdG8gZiwgYW5kXG4gICAqIHkgaXMgcmVwbGFjZWQgd2l0aCBhIHJhbmRvbSBoZXhhZGVjaW1hbCBkaWdpdCBmcm9tIDggdG8gYi5cbiAgICogVXNlZCB0byBnZW5lcmF0ZSBVVUlEcyBmb3IgZGV2aWNlSWRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHV1aWQgPSBmdW5jdGlvbiB1dWlkKGEpIHtcbiAgICByZXR1cm4gYSAvLyBpZiB0aGUgcGxhY2Vob2xkZXIgd2FzIHBhc3NlZCwgcmV0dXJuXG4gICAgPyAoIC8vIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgICBhIF4gLy8gdW5sZXNzIGIgaXMgOCxcbiAgICBNYXRoLnJhbmRvbSgpIC8vIGluIHdoaWNoIGNhc2VcbiAgICAqIDE2IC8vIGEgcmFuZG9tIG51bWJlciBmcm9tXG4gICAgPj4gYSAvIDQgLy8gOCB0byAxMVxuICAgICkudG9TdHJpbmcoMTYpIC8vIGluIGhleGFkZWNpbWFsXG4gICAgOiAoIC8vIG9yIG90aGVyd2lzZSBhIGNvbmNhdGVuYXRlZCBzdHJpbmc6XG4gICAgWzFlN10gKyAvLyAxMDAwMDAwMCArXG4gICAgLTFlMyArIC8vIC0xMDAwICtcbiAgICAtNGUzICsgLy8gLTQwMDAgK1xuICAgIC04ZTMgKyAvLyAtODAwMDAwMDAgK1xuICAgIC0xZTExIC8vIC0xMDAwMDAwMDAwMDAsXG4gICAgKS5yZXBsYWNlKCAvLyByZXBsYWNpbmdcbiAgICAvWzAxOF0vZywgLy8gemVyb2VzLCBvbmVzLCBhbmQgZWlnaHRzIHdpdGhcbiAgICB1dWlkIC8vIHJhbmRvbSBoZXggZGlnaXRzXG4gICAgKTtcbiAgfTtcblxuICAvLyBBIFVSTCBzYWZlIHZhcmlhdGlvbiBvbiB0aGUgdGhlIGxpc3Qgb2YgQmFzZTY0IGNoYXJhY3RlcnMgXG4gIHZhciBiYXNlNjRDaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJztcblxuICB2YXIgYmFzZTY0SWQgPSBmdW5jdGlvbiBiYXNlNjRJZCgpIHtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIyOyArK2kpIHtcbiAgICAgIHN0ciArPSBiYXNlNjRDaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHZhciB2ZXJzaW9uID0gXCI3LjAuMFwiO1xuXG4gIHZhciBnZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIGdldExhbmd1YWdlKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgKG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSkgfHwgJyc7XG4gIH07XG5cbiAgdmFyIGxhbmd1YWdlID0ge1xuICAgIGdldExhbmd1YWdlOiBnZXRMYW5ndWFnZVxuICB9O1xuXG4gIHZhciBwbGF0Zm9ybSA9ICdXZWInO1xuXG4gIHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXBpRW5kcG9pbnQ6ICdhcGkuYW1wbGl0dWRlLmNvbScsXG4gICAgYmF0Y2hFdmVudHM6IGZhbHNlLFxuICAgIGNvb2tpZUV4cGlyYXRpb246IDM2NSAqIDEwLFxuICAgIGNvb2tpZU5hbWU6ICdhbXBsaXR1ZGVfaWQnLFxuICAgIC8vIHRoaXMgaXMgYSBkZXByZWNhdGVkIG9wdGlvblxuICAgIHNhbWVTaXRlQ29va2llOiAnTm9uZScsXG4gICAgY29va2llRm9yY2VVcGdyYWRlOiBmYWxzZSxcbiAgICBkZWZlckluaXRpYWxpemF0aW9uOiBmYWxzZSxcbiAgICBkaXNhYmxlQ29va2llczogZmFsc2UsXG4gICAgZGV2aWNlSWRGcm9tVXJsUGFyYW06IGZhbHNlLFxuICAgIGRvbWFpbjogJycsXG4gICAgZXZlbnRVcGxvYWRQZXJpb2RNaWxsaXM6IDMwICogMTAwMCxcbiAgICAvLyAzMHNcbiAgICBldmVudFVwbG9hZFRocmVzaG9sZDogMzAsXG4gICAgZm9yY2VIdHRwczogdHJ1ZSxcbiAgICBpbmNsdWRlR2NsaWQ6IGZhbHNlLFxuICAgIGluY2x1ZGVSZWZlcnJlcjogZmFsc2UsXG4gICAgaW5jbHVkZVV0bTogZmFsc2UsXG4gICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLmdldExhbmd1YWdlKCksXG4gICAgbG9nTGV2ZWw6ICdXQVJOJyxcbiAgICBvcHRPdXQ6IGZhbHNlLFxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoKSB7fSxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gICAgc2F2ZWRNYXhDb3VudDogMTAwMCxcbiAgICBzYXZlRXZlbnRzOiB0cnVlLFxuICAgIHNhdmVQYXJhbXNSZWZlcnJlck9uY2VQZXJTZXNzaW9uOiB0cnVlLFxuICAgIHNlY3VyZUNvb2tpZTogZmFsc2UsXG4gICAgc2Vzc2lvblRpbWVvdXQ6IDMwICogNjAgKiAxMDAwLFxuICAgIHRyYWNraW5nT3B0aW9uczoge1xuICAgICAgY2l0eTogdHJ1ZSxcbiAgICAgIGNvdW50cnk6IHRydWUsXG4gICAgICBjYXJyaWVyOiB0cnVlLFxuICAgICAgZGV2aWNlX21hbnVmYWN0dXJlcjogdHJ1ZSxcbiAgICAgIGRldmljZV9tb2RlbDogdHJ1ZSxcbiAgICAgIGRtYTogdHJ1ZSxcbiAgICAgIGlwX2FkZHJlc3M6IHRydWUsXG4gICAgICBsYW5ndWFnZTogdHJ1ZSxcbiAgICAgIG9zX25hbWU6IHRydWUsXG4gICAgICBvc192ZXJzaW9uOiB0cnVlLFxuICAgICAgcGxhdGZvcm06IHRydWUsXG4gICAgICByZWdpb246IHRydWUsXG4gICAgICB2ZXJzaW9uX25hbWU6IHRydWVcbiAgICB9LFxuICAgIHVuc2V0UGFyYW1zUmVmZXJyZXJPbk5ld1Nlc3Npb246IGZhbHNlLFxuICAgIHVuc2VudEtleTogJ2FtcGxpdHVkZV91bnNlbnQnLFxuICAgIHVuc2VudElkZW50aWZ5S2V5OiAnYW1wbGl0dWRlX3Vuc2VudF9pZGVudGlmeScsXG4gICAgdXBsb2FkQmF0Y2hTaXplOiAxMDBcbiAgfTtcblxuICB2YXIgQXN5bmNTdG9yYWdlO1xuICB2YXIgRGV2aWNlSW5mbztcbiAgLyoqXG4gICAqIEFtcGxpdHVkZUNsaWVudCBTREsgQVBJIC0gaW5zdGFuY2UgY29uc3RydWN0b3IuXG4gICAqIFRoZSBBbXBsaXR1ZGUgY2xhc3MgaGFuZGxlcyBjcmVhdGlvbiBvZiBjbGllbnQgaW5zdGFuY2VzLCBhbGwgeW91IG5lZWQgdG8gZG8gaXMgY2FsbCBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKVxuICAgKiBAY29uc3RydWN0b3IgQW1wbGl0dWRlQ2xpZW50XG4gICAqIEBwdWJsaWNcbiAgICogQGV4YW1wbGUgdmFyIGFtcGxpdHVkZUNsaWVudCA9IG5ldyBBbXBsaXR1ZGVDbGllbnQoKTtcbiAgICovXG5cblxuICB2YXIgQW1wbGl0dWRlQ2xpZW50ID0gZnVuY3Rpb24gQW1wbGl0dWRlQ2xpZW50KGluc3RhbmNlTmFtZSkge1xuICAgIHRoaXMuX2luc3RhbmNlTmFtZSA9IHV0aWxzLmlzRW1wdHlTdHJpbmcoaW5zdGFuY2VOYW1lKSA/IENvbnN0YW50cy5ERUZBVUxUX0lOU1RBTkNFIDogaW5zdGFuY2VOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5fdW5zZW50RXZlbnRzID0gW107XG4gICAgdGhpcy5fdW5zZW50SWRlbnRpZnlzID0gW107XG4gICAgdGhpcy5fdWEgPSBuZXcgdWFQYXJzZXIobmF2aWdhdG9yLnVzZXJBZ2VudCkuZ2V0UmVzdWx0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9PUFRJT05TLCB7XG4gICAgICB0cmFja2luZ09wdGlvbnM6IF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfT1BUSU9OUy50cmFja2luZ09wdGlvbnMpXG4gICAgfSk7XG4gICAgdGhpcy5jb29raWVTdG9yYWdlID0gbmV3IGNvb2tpZVN0b3JhZ2UoKS5nZXRTdG9yYWdlKCk7XG4gICAgdGhpcy5fcSA9IFtdOyAvLyBxdWV1ZSBmb3IgcHJveGllZCBmdW5jdGlvbnMgYmVmb3JlIHNjcmlwdCBsb2FkXG5cbiAgICB0aGlzLl9zZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGhpcy5fb25Jbml0ID0gW107IC8vIGV2ZW50IG1ldGEgZGF0YVxuXG4gICAgdGhpcy5fZXZlbnRJZCA9IDA7XG4gICAgdGhpcy5faWRlbnRpZnlJZCA9IDA7XG4gICAgdGhpcy5fbGFzdEV2ZW50VGltZSA9IG51bGw7XG4gICAgdGhpcy5fbmV3U2Vzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuX3NlcXVlbmNlTnVtYmVyID0gMDtcbiAgICB0aGlzLl9zZXNzaW9uSWQgPSBudWxsO1xuICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBudWxsO1xuICB9O1xuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuSWRlbnRpZnkgPSBJZGVudGlmeTtcbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5SZXZlbnVlID0gUmV2ZW51ZTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBBbXBsaXR1ZGUgSmF2YXNjcmlwdCBTREsgd2l0aCB5b3VyIGFwaUtleSBhbmQgYW55IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlZm9yZSBhbnkgb3RoZXIgbWV0aG9kcyBjYW4gYmUgY2FsbGVkLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXkgLSBUaGUgQVBJIGtleSBmb3IgeW91ciBhcHAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRfdXNlcklkIC0gKG9wdGlvbmFsKSBBbiBpZGVudGlmaWVyIGZvciB0aGlzIHVzZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRfY29uZmlnIC0gKG9wdGlvbmFsKSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIFNlZSBbUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0I2NvbmZpZ3VyYXRpb24tb3B0aW9uc30gZm9yIGxpc3Qgb2Ygb3B0aW9ucyBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdF9jYWxsYmFjayAtIChvcHRpb25hbCkgUHJvdmlkZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZS5cbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmluaXQoJ0FQSV9LRVknLCAnVVNFUl9JRCcsIHtpbmNsdWRlUmVmZXJyZXI6IHRydWUsIGluY2x1ZGVVdG06IHRydWV9LCBmdW5jdGlvbigpIHsgYWxlcnQoJ2luaXQgY29tcGxldGUnKTsgfSk7XG4gICAqL1xuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoYXBpS2V5LCBvcHRfdXNlcklkLCBvcHRfY29uZmlnLCBvcHRfY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGUoYXBpS2V5KSAhPT0gJ3N0cmluZycgfHwgdXRpbHMuaXNFbXB0eVN0cmluZyhhcGlLZXkpKSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoJ0ludmFsaWQgYXBpS2V5LiBQbGVhc2UgcmUtaW5pdGlhbGl6ZSB3aXRoIGEgdmFsaWQgYXBpS2V5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIF9wYXJzZUNvbmZpZyh0aGlzLm9wdGlvbnMsIG9wdF9jb25maWcpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvb2tpZU5hbWUgIT09IERFRkFVTFRfT1BUSU9OUy5jb29raWVOYW1lKSB7XG4gICAgICAgIHV0aWxzLmxvZy53YXJuKCdUaGUgY29va2llTmFtZSBvcHRpb24gaXMgZGVwcmVjYXRlZC4gV2Ugd2lsbCBiZSBpZ25vcmluZyBpdCBmb3IgbmV3ZXIgY29va2llcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgdGhpcy5fc3RvcmFnZVN1ZmZpeCA9ICdfJyArIGFwaUtleSArICh0aGlzLl9pbnN0YW5jZU5hbWUgPT09IENvbnN0YW50cy5ERUZBVUxUX0lOU1RBTkNFID8gJycgOiAnXycgKyB0aGlzLl9pbnN0YW5jZU5hbWUpO1xuICAgICAgdGhpcy5fc3RvcmFnZVN1ZmZpeFY1ID0gYXBpS2V5LnNsaWNlKDAsIDYpO1xuICAgICAgdGhpcy5fb2xkQ29va2llbmFtZSA9IHRoaXMub3B0aW9ucy5jb29raWVOYW1lICsgdGhpcy5fc3RvcmFnZVN1ZmZpeDtcbiAgICAgIHRoaXMuX3Vuc2VudEtleSA9IHRoaXMub3B0aW9ucy51bnNlbnRLZXkgKyB0aGlzLl9zdG9yYWdlU3VmZml4O1xuICAgICAgdGhpcy5fdW5zZW50SWRlbnRpZnlLZXkgPSB0aGlzLm9wdGlvbnMudW5zZW50SWRlbnRpZnlLZXkgKyB0aGlzLl9zdG9yYWdlU3VmZml4O1xuICAgICAgdGhpcy5fY29va2llTmFtZSA9IENvbnN0YW50cy5DT09LSUVfUFJFRklYICsgJ18nICsgdGhpcy5fc3RvcmFnZVN1ZmZpeFY1O1xuICAgICAgdGhpcy5jb29raWVTdG9yYWdlLm9wdGlvbnMoe1xuICAgICAgICBleHBpcmF0aW9uRGF5czogdGhpcy5vcHRpb25zLmNvb2tpZUV4cGlyYXRpb24sXG4gICAgICAgIGRvbWFpbjogdGhpcy5vcHRpb25zLmRvbWFpbixcbiAgICAgICAgc2VjdXJlOiB0aGlzLm9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICBzYW1lU2l0ZTogdGhpcy5vcHRpb25zLnNhbWVTaXRlQ29va2llXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21ldGFkYXRhU3RvcmFnZSA9IG5ldyBNZXRhZGF0YVN0b3JhZ2Uoe1xuICAgICAgICBzdG9yYWdlS2V5OiB0aGlzLl9jb29raWVOYW1lLFxuICAgICAgICBkaXNhYmxlQ29va2llczogdGhpcy5vcHRpb25zLmRpc2FibGVDb29raWVzLFxuICAgICAgICBleHBpcmF0aW9uRGF5czogdGhpcy5vcHRpb25zLmNvb2tpZUV4cGlyYXRpb24sXG4gICAgICAgIGRvbWFpbjogdGhpcy5vcHRpb25zLmRvbWFpbixcbiAgICAgICAgc2VjdXJlOiB0aGlzLm9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICBzYW1lU2l0ZTogdGhpcy5vcHRpb25zLnNhbWVTaXRlQ29va2llXG4gICAgICB9KTtcbiAgICAgIHZhciBoYXNPbGRDb29raWUgPSAhIXRoaXMuY29va2llU3RvcmFnZS5nZXQodGhpcy5fb2xkQ29va2llbmFtZSk7XG4gICAgICB2YXIgaGFzTmV3Q29va2llID0gISF0aGlzLl9tZXRhZGF0YVN0b3JhZ2UubG9hZCgpO1xuICAgICAgdGhpcy5fdXNlT2xkQ29va2llID0gIWhhc05ld0Nvb2tpZSAmJiBoYXNPbGRDb29raWUgJiYgIXRoaXMub3B0aW9ucy5jb29raWVGb3JjZVVwZ3JhZGU7XG4gICAgICB2YXIgaGFzQ29va2llID0gaGFzTmV3Q29va2llIHx8IGhhc09sZENvb2tpZTtcbiAgICAgIHRoaXMub3B0aW9ucy5kb21haW4gPSB0aGlzLmNvb2tpZVN0b3JhZ2Uub3B0aW9ucygpLmRvbWFpbjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWZlckluaXRpYWxpemF0aW9uICYmICFoYXNDb29raWUpIHtcbiAgICAgICAgdGhpcy5fZGVmZXJJbml0aWFsaXphdGlvbihhcGlLZXksIG9wdF91c2VySWQsIG9wdF9jb25maWcsIG9wdF9jYWxsYmFjayk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSh0aGlzLm9wdGlvbnMubG9nTGV2ZWwpID09PSAnc3RyaW5nJykge1xuICAgICAgICB1dGlscy5zZXRMb2dMZXZlbCh0aGlzLm9wdGlvbnMubG9nTGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhY2tpbmdPcHRpb25zID0gX2dlbmVyYXRlQXBpUHJvcGVydGllc1RyYWNraW5nQ29uZmlnKHRoaXMpO1xuXG4gICAgICB0aGlzLl9hcGlQcm9wZXJ0aWVzVHJhY2tpbmdPcHRpb25zID0gT2JqZWN0LmtleXModHJhY2tpbmdPcHRpb25zKS5sZW5ndGggPiAwID8ge1xuICAgICAgICB0cmFja2luZ19vcHRpb25zOiB0cmFja2luZ09wdGlvbnNcbiAgICAgIH0gOiB7fTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb29raWVGb3JjZVVwZ3JhZGUgJiYgaGFzT2xkQ29va2llKSB7XG4gICAgICAgIGlmICghaGFzTmV3Q29va2llKSB7XG4gICAgICAgICAgX3VwZ3JhZGVDb29raWVEYXRhKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb29raWVTdG9yYWdlLnJlbW92ZSh0aGlzLl9vbGRDb29raWVuYW1lKTtcbiAgICAgIH1cblxuICAgICAgX2xvYWRDb29raWVEYXRhKHRoaXMpO1xuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVhZFN0b3JhZ2UgPSB0cnVlO1xuXG4gICAgICB2YXIgaW5pdEZyb21TdG9yYWdlID0gZnVuY3Rpb24gaW5pdEZyb21TdG9yYWdlKGRldmljZUlkKSB7XG4gICAgICAgIC8vIGxvYWQgZGV2aWNlSWQgYW5kIHVzZXJJZCBmcm9tIGlucHV0LCBvciB0cnkgdG8gZmV0Y2ggZXhpc3RpbmcgdmFsdWUgZnJvbSBjb29raWVcbiAgICAgICAgX3RoaXMub3B0aW9ucy5kZXZpY2VJZCA9IHR5cGUob3B0X2NvbmZpZykgPT09ICdvYmplY3QnICYmIHR5cGUob3B0X2NvbmZpZy5kZXZpY2VJZCkgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc0VtcHR5U3RyaW5nKG9wdF9jb25maWcuZGV2aWNlSWQpICYmIG9wdF9jb25maWcuZGV2aWNlSWQgfHwgX3RoaXMub3B0aW9ucy5kZXZpY2VJZEZyb21VcmxQYXJhbSAmJiBfdGhpcy5fZ2V0RGV2aWNlSWRGcm9tVXJsUGFyYW0oX3RoaXMuX2dldFVybFBhcmFtcygpKSB8fCBfdGhpcy5vcHRpb25zLmRldmljZUlkIHx8IGRldmljZUlkIHx8IGJhc2U2NElkKCk7XG4gICAgICAgIF90aGlzLm9wdGlvbnMudXNlcklkID0gdHlwZShvcHRfdXNlcklkKSA9PT0gJ3N0cmluZycgJiYgIXV0aWxzLmlzRW1wdHlTdHJpbmcob3B0X3VzZXJJZCkgJiYgb3B0X3VzZXJJZCB8fCB0eXBlKG9wdF91c2VySWQpID09PSAnbnVtYmVyJyAmJiBvcHRfdXNlcklkLnRvU3RyaW5nKCkgfHwgX3RoaXMub3B0aW9ucy51c2VySWQgfHwgbnVsbDtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmICghX3RoaXMuX3Nlc3Npb25JZCB8fCAhX3RoaXMuX2xhc3RFdmVudFRpbWUgfHwgbm93IC0gX3RoaXMuX2xhc3RFdmVudFRpbWUgPiBfdGhpcy5vcHRpb25zLnNlc3Npb25UaW1lb3V0KSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudW5zZXRQYXJhbXNSZWZlcnJlck9uTmV3U2Vzc2lvbikge1xuICAgICAgICAgICAgX3RoaXMuX3Vuc2V0VVRNUGFyYW1zKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuX25ld1Nlc3Npb24gPSB0cnVlO1xuICAgICAgICAgIF90aGlzLl9zZXNzaW9uSWQgPSBub3c7IC8vIG9ubHkgY2FwdHVyZSBVVE0gcGFyYW1zIGFuZCByZWZlcnJlciBpZiBuZXcgc2Vzc2lvblxuXG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2F2ZVBhcmFtc1JlZmVycmVyT25jZVBlclNlc3Npb24pIHtcbiAgICAgICAgICAgIF90aGlzLl90cmFja1BhcmFtc0FuZFJlZmVycmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnNhdmVQYXJhbXNSZWZlcnJlck9uY2VQZXJTZXNzaW9uKSB7XG4gICAgICAgICAgX3RoaXMuX3RyYWNrUGFyYW1zQW5kUmVmZXJyZXIoKTtcbiAgICAgICAgfSAvLyBsb2FkIHVuc2VudCBldmVudHMgYW5kIGlkZW50aWZpZXMgYmVmb3JlIGFueSBhdHRlbXB0IHRvIGxvZyBuZXcgb25lc1xuXG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2F2ZUV2ZW50cykge1xuICAgICAgICAgIF92YWxpZGF0ZVVuc2VudEV2ZW50UXVldWUoX3RoaXMuX3Vuc2VudEV2ZW50cyk7XG5cbiAgICAgICAgICBfdmFsaWRhdGVVbnNlbnRFdmVudFF1ZXVlKF90aGlzLl91bnNlbnRJZGVudGlmeXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2xhc3RFdmVudFRpbWUgPSBub3c7XG5cbiAgICAgICAgX3NhdmVDb29raWVEYXRhKF90aGlzKTtcblxuICAgICAgICBfdGhpcy5fcGVuZGluZ1JlYWRTdG9yYWdlID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuX3NlbmRFdmVudHNJZlJlYWR5KCk7IC8vIHRyeSBzZW5kaW5nIHVuc2VudCBldmVudHNcblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuX29uSW5pdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF90aGlzLl9vbkluaXRbaV0oX3RoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX29uSW5pdCA9IFtdO1xuICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICBpZiAoQXN5bmNTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuX21pZ3JhdGVVbnNlbnRFdmVudHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFByb21pc2UuYWxsKFtBc3luY1N0b3JhZ2UuZ2V0SXRlbShfdGhpcy5fc3RvcmFnZVN1ZmZpeCksIEFzeW5jU3RvcmFnZS5nZXRJdGVtKF90aGlzLm9wdGlvbnMudW5zZW50S2V5ICsgX3RoaXMuX3N0b3JhZ2VTdWZmaXgpLCBBc3luY1N0b3JhZ2UuZ2V0SXRlbShfdGhpcy5vcHRpb25zLnVuc2VudElkZW50aWZ5S2V5ICsgX3RoaXMuX3N0b3JhZ2VTdWZmaXgpXSkudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzWzBdKSB7XG4gICAgICAgICAgICAgIHZhciBjb29raWVEYXRhID0gSlNPTi5wYXJzZSh2YWx1ZXNbMF0pO1xuXG4gICAgICAgICAgICAgIGlmIChjb29raWVEYXRhKSB7XG4gICAgICAgICAgICAgICAgX2xvYWRDb29raWVEYXRhUHJvcHMoX3RoaXMsIGNvb2tpZURhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnNhdmVFdmVudHMpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3Vuc2VudEV2ZW50cyA9IF90aGlzLl9wYXJzZVNhdmVkVW5zZW50RXZlbnRzU3RyaW5nKHZhbHVlc1sxXSkubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KS5jb25jYXQoX3RoaXMuX3Vuc2VudEV2ZW50cyk7XG4gICAgICAgICAgICAgIF90aGlzLl91bnNlbnRJZGVudGlmeXMgPSBfdGhpcy5fcGFyc2VTYXZlZFVuc2VudEV2ZW50c1N0cmluZyh2YWx1ZXNbMl0pLm1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSkuY29uY2F0KF90aGlzLl91bnNlbnRJZGVudGlmeXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRGV2aWNlSW5mbykge1xuICAgICAgICAgICAgICBQcm9taXNlLmFsbChbRGV2aWNlSW5mby5nZXRDYXJyaWVyKCksIERldmljZUluZm8uZ2V0TW9kZWwoKSwgRGV2aWNlSW5mby5nZXRNYW51ZmFjdHVyZXIoKSwgRGV2aWNlSW5mby5nZXRWZXJzaW9uKCksIERldmljZUluZm8uZ2V0VW5pcXVlSWQoKV0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIF90aGlzLmRldmljZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICBjYXJyaWVyOiB2YWx1ZXNbMF0sXG4gICAgICAgICAgICAgICAgICBtb2RlbDogdmFsdWVzWzFdLFxuICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiB2YWx1ZXNbMl0sXG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2YWx1ZXNbM11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluaXRGcm9tU3RvcmFnZSh2YWx1ZXNbNF0pO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMucnVuUXVldWVkRnVuY3Rpb25zKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBvcHRfY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluaXRGcm9tU3RvcmFnZSgpO1xuXG4gICAgICAgICAgICAgIF90aGlzLnJ1blF1ZXVlZEZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZUV2ZW50cykge1xuICAgICAgICAgIHRoaXMuX3Vuc2VudEV2ZW50cyA9IHRoaXMuX2xvYWRTYXZlZFVuc2VudEV2ZW50cyh0aGlzLm9wdGlvbnMudW5zZW50S2V5KS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuY29uY2F0KHRoaXMuX3Vuc2VudEV2ZW50cyk7XG4gICAgICAgICAgdGhpcy5fdW5zZW50SWRlbnRpZnlzID0gdGhpcy5fbG9hZFNhdmVkVW5zZW50RXZlbnRzKHRoaXMub3B0aW9ucy51bnNlbnRJZGVudGlmeUtleSkubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmNvbmNhdCh0aGlzLl91bnNlbnRJZGVudGlmeXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdEZyb21TdG9yYWdlKCk7XG4gICAgICAgIHRoaXMucnVuUXVldWVkRnVuY3Rpb25zKCk7XG5cbiAgICAgICAgaWYgKHR5cGUob3B0X2NhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdF9jYWxsYmFjayh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGVycik7XG4gICAgICB0aGlzLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgIH1cbiAgfTsgLy8gdmFsaWRhdGUgcHJvcGVydGllcyBmb3IgdW5zZW50IGV2ZW50c1xuXG5cbiAgdmFyIF92YWxpZGF0ZVVuc2VudEV2ZW50UXVldWUgPSBmdW5jdGlvbiBfdmFsaWRhdGVVbnNlbnRFdmVudFF1ZXVlKHF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVzZXJQcm9wZXJ0aWVzID0gcXVldWVbaV0uZXZlbnQudXNlcl9wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHF1ZXVlW2ldLmV2ZW50LmV2ZW50X3Byb3BlcnRpZXM7XG4gICAgICB2YXIgZ3JvdXBzID0gcXVldWVbaV0uZXZlbnQuZ3JvdXBzO1xuICAgICAgcXVldWVbaV0uZXZlbnQudXNlcl9wcm9wZXJ0aWVzID0gdXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKTtcbiAgICAgIHF1ZXVlW2ldLmV2ZW50LmV2ZW50X3Byb3BlcnRpZXMgPSB1dGlscy52YWxpZGF0ZVByb3BlcnRpZXMoZXZlbnRQcm9wZXJ0aWVzKTtcbiAgICAgIHF1ZXVlW2ldLmV2ZW50Lmdyb3VwcyA9IHV0aWxzLnZhbGlkYXRlR3JvdXBzKGdyb3Vwcyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9taWdyYXRlVW5zZW50RXZlbnRzID0gZnVuY3Rpb24gX21pZ3JhdGVVbnNlbnRFdmVudHMoY2IpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIFByb21pc2UuYWxsKFtBc3luY1N0b3JhZ2UuZ2V0SXRlbSh0aGlzLm9wdGlvbnMudW5zZW50S2V5KSwgQXN5bmNTdG9yYWdlLmdldEl0ZW0odGhpcy5vcHRpb25zLnVuc2VudElkZW50aWZ5S2V5KV0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNhdmVFdmVudHMpIHtcbiAgICAgICAgdmFyIHVuc2VudEV2ZW50c1N0cmluZyA9IHZhbHVlc1swXTtcbiAgICAgICAgdmFyIHVuc2VudElkZW50aWZ5S2V5ID0gdmFsdWVzWzFdO1xuICAgICAgICB2YXIgaXRlbXNUb1NldCA9IFtdO1xuICAgICAgICB2YXIgaXRlbXNUb1JlbW92ZSA9IFtdO1xuXG4gICAgICAgIGlmICghIXVuc2VudEV2ZW50c1N0cmluZykge1xuICAgICAgICAgIGl0ZW1zVG9TZXQucHVzaChBc3luY1N0b3JhZ2Uuc2V0SXRlbShfdGhpczIub3B0aW9ucy51bnNlbnRLZXkgKyBfdGhpczIuX3N0b3JhZ2VTdWZmaXgsIEpTT04uc3RyaW5naWZ5KHVuc2VudEV2ZW50c1N0cmluZykpKTtcbiAgICAgICAgICBpdGVtc1RvUmVtb3ZlLnB1c2goQXN5bmNTdG9yYWdlLnJlbW92ZUl0ZW0oX3RoaXMyLm9wdGlvbnMudW5zZW50S2V5KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISF1bnNlbnRJZGVudGlmeUtleSkge1xuICAgICAgICAgIGl0ZW1zVG9TZXQucHVzaChBc3luY1N0b3JhZ2Uuc2V0SXRlbShfdGhpczIub3B0aW9ucy51bnNlbnRJZGVudGlmeUtleSArIF90aGlzMi5fc3RvcmFnZVN1ZmZpeCwgSlNPTi5zdHJpbmdpZnkodW5zZW50SWRlbnRpZnlLZXkpKSk7XG4gICAgICAgICAgaXRlbXNUb1JlbW92ZS5wdXNoKEFzeW5jU3RvcmFnZS5yZW1vdmVJdGVtKF90aGlzMi5vcHRpb25zLnVuc2VudElkZW50aWZ5S2V5KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXNUb1NldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoaXRlbXNUb1NldCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbihjYikuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgX3RoaXMyLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl90cmFja1BhcmFtc0FuZFJlZmVycmVyID0gZnVuY3Rpb24gX3RyYWNrUGFyYW1zQW5kUmVmZXJyZXIoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlVXRtKSB7XG4gICAgICB0aGlzLl9pbml0VXRtRGF0YSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZVJlZmVycmVyKSB7XG4gICAgICB0aGlzLl9zYXZlUmVmZXJyZXIodGhpcy5fZ2V0UmVmZXJyZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlR2NsaWQpIHtcbiAgICAgIHRoaXMuX3NhdmVHY2xpZCh0aGlzLl9nZXRVcmxQYXJhbXMoKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUGFyc2UgYW5kIHZhbGlkYXRlIHVzZXIgc3BlY2lmaWVkIGNvbmZpZyB2YWx1ZXMgYW5kIG92ZXJ3cml0ZSBleGlzdGluZyBvcHRpb24gdmFsdWVcbiAgICogREVGQVVMVF9PUFRJT05TIHByb3ZpZGVzIGxpc3Qgb2YgYWxsIGNvbmZpZyBrZXlzIHRoYXQgYXJlIG1vZGlmaWFibGUsIGFzIHdlbGwgYXMgZXhwZWN0ZWQgdHlwZXMgZm9yIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcob3B0aW9ucywgY29uZmlnKSB7XG4gICAgaWYgKHR5cGUoY29uZmlnKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHZhbGlkYXRlcyBjb25maWcgdmFsdWUgaXMgZGVmaW5lZCwgaXMgdGhlIGNvcnJlY3QgdHlwZSwgYW5kIHNvbWUgYWRkaXRpb25hbCB2YWx1ZSBzYW5pdHkgY2hlY2tzXG5cblxuICAgIHZhciBwYXJzZVZhbGlkYXRlQW5kTG9hZCA9IGZ1bmN0aW9uIHBhcnNlVmFsaWRhdGVBbmRMb2FkKGtleSkge1xuICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBza2lwIGJvZ3VzIGNvbmZpZyB2YWx1ZXNcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0VmFsdWUgPSBjb25maWdba2V5XTtcbiAgICAgIHZhciBleHBlY3RlZFR5cGUgPSB0eXBlKG9wdGlvbnNba2V5XSk7XG5cbiAgICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dChpbnB1dFZhbHVlLCBrZXkgKyAnIG9wdGlvbicsIGV4cGVjdGVkVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gISFpbnB1dFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc0VtcHR5U3RyaW5nKGlucHV0VmFsdWUpIHx8IGV4cGVjdGVkVHlwZSA9PT0gJ251bWJlcicgJiYgaW5wdXRWYWx1ZSA+IDApIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gaW5wdXRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBfcGFyc2VDb25maWcob3B0aW9uc1trZXldLCBpbnB1dFZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHBhcnNlVmFsaWRhdGVBbmRMb2FkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUnVuIGZ1bmN0aW9ucyBxdWV1ZWQgdXAgYnkgcHJveHkgbG9hZGluZyBzbmlwcGV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5ydW5RdWV1ZWRGdW5jdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcTtcbiAgICB0aGlzLl9xID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzW3F1ZXVlW2ldWzBdXTtcblxuICAgICAgaWYgKHR5cGUoZm4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIHF1ZXVlW2ldLnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IHRoZSBhcGlLZXkgaXMgc2V0IGJlZm9yZSBjYWxsaW5nIGEgZnVuY3Rpb24uIExvZ3MgYSB3YXJuaW5nIG1lc3NhZ2UgaWYgbm90IHNldC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9hcGlLZXlTZXQgPSBmdW5jdGlvbiBfYXBpS2V5U2V0KG1ldGhvZE5hbWUpIHtcbiAgICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyh0aGlzLm9wdGlvbnMuYXBpS2V5KSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdJbnZhbGlkIGFwaUtleS4gUGxlYXNlIHNldCBhIHZhbGlkIGFwaUtleSB3aXRoIGluaXQoKSBiZWZvcmUgY2FsbGluZyAnICsgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIHNhdmVkIGV2ZW50cyBmcm9tIGxvY2FsU3RvcmFnZS4gSlNPTiBkZXNlcmlhbGl6ZXMgZXZlbnQgYXJyYXkuIEhhbmRsZXMgY2FzZSB3aGVyZSBzdHJpbmcgaXMgY29ycnVwdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2xvYWRTYXZlZFVuc2VudEV2ZW50cyA9IGZ1bmN0aW9uIF9sb2FkU2F2ZWRVbnNlbnRFdmVudHModW5zZW50S2V5KSB7XG4gICAgdmFyIHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nID0gdGhpcy5fZ2V0RnJvbVN0b3JhZ2UobG9jYWxTdG9yYWdlJDEsIHVuc2VudEtleSk7XG5cbiAgICB2YXIgdW5zZW50RXZlbnRzID0gdGhpcy5fcGFyc2VTYXZlZFVuc2VudEV2ZW50c1N0cmluZyhzYXZlZFVuc2VudEV2ZW50c1N0cmluZywgdW5zZW50S2V5KTtcblxuICAgIHRoaXMuX3NldEluU3RvcmFnZShsb2NhbFN0b3JhZ2UkMSwgdW5zZW50S2V5LCBKU09OLnN0cmluZ2lmeSh1bnNlbnRFdmVudHMpKTtcblxuICAgIHJldHVybiB1bnNlbnRFdmVudHM7XG4gIH07XG4gIC8qKlxuICAgKiBMb2FkIHNhdmVkIGV2ZW50cyBmcm9tIGxvY2FsU3RvcmFnZS4gSlNPTiBkZXNlcmlhbGl6ZXMgZXZlbnQgYXJyYXkuIEhhbmRsZXMgY2FzZSB3aGVyZSBzdHJpbmcgaXMgY29ycnVwdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3BhcnNlU2F2ZWRVbnNlbnRFdmVudHNTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VTYXZlZFVuc2VudEV2ZW50c1N0cmluZyhzYXZlZFVuc2VudEV2ZW50c1N0cmluZywgdW5zZW50S2V5KSB7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoc2F2ZWRVbnNlbnRFdmVudHNTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gW107IC8vIG5ldyBhcHAsIGRvZXMgbm90IGhhdmUgYW55IHNhdmVkIGV2ZW50c1xuICAgIH1cblxuICAgIGlmICh0eXBlKHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBldmVudHMgPSBKU09OLnBhcnNlKHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nKTtcblxuICAgICAgICBpZiAodHlwZShldmVudHMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGNhc2Ugd2hlcmUgSlNPTiBkdW1waW5nIG9mIHVuc2VudCBldmVudHMgaXMgY29ycnVwdGVkXG4gICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB1dGlscy5sb2cuZXJyb3IoJ1VuYWJsZSB0byBsb2FkICcgKyB1bnNlbnRLZXkgKyAnIGV2ZW50cy4gUmVzdGFydCB3aXRoIGEgbmV3IGVtcHR5IHF1ZXVlLicpO1xuICAgIHJldHVybiBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIG5ldyBzZXNzaW9uIHdhcyBjcmVhdGVkIGR1cmluZyBpbml0aWFsaXphdGlvbiwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBuZXcgc2Vzc2lvbiB3YXMgY3JlYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5pc05ld1Nlc3Npb24gPSBmdW5jdGlvbiBpc05ld1Nlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ld1Nlc3Npb247XG4gIH07XG4gIC8qKlxuICAgKiBTdG9yZSBjYWxsYmFja3MgdG8gY2FsbCBhZnRlciBpbml0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5vbkluaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25Jbml0LnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybiB7bnVtYmVyfSBJZCBvZiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuZ2V0U2Vzc2lvbklkID0gZnVuY3Rpb24gZ2V0U2Vzc2lvbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uSWQ7XG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBldmVudElkIGFuZCByZXR1cm5zIGl0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubmV4dEV2ZW50SWQgPSBmdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgICB0aGlzLl9ldmVudElkKys7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SWQ7XG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBpZGVudGlmeUlkIGFuZCByZXR1cm5zIGl0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubmV4dElkZW50aWZ5SWQgPSBmdW5jdGlvbiBuZXh0SWRlbnRpZnlJZCgpIHtcbiAgICB0aGlzLl9pZGVudGlmeUlkKys7XG4gICAgcmV0dXJuIHRoaXMuX2lkZW50aWZ5SWQ7XG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBzZXF1ZW5jZU51bWJlciBhbmQgcmV0dXJucyBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLm5leHRTZXF1ZW5jZU51bWJlciA9IGZ1bmN0aW9uIG5leHRTZXF1ZW5jZU51bWJlcigpIHtcbiAgICB0aGlzLl9zZXF1ZW5jZU51bWJlcisrO1xuICAgIHJldHVybiB0aGlzLl9zZXF1ZW5jZU51bWJlcjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdGFsIGNvdW50IG9mIHVuc2VudCBldmVudHMgYW5kIGlkZW50aWZ5c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3Vuc2VudENvdW50ID0gZnVuY3Rpb24gX3Vuc2VudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl91bnNlbnRFdmVudHMubGVuZ3RoICsgdGhpcy5fdW5zZW50SWRlbnRpZnlzLmxlbmd0aDtcbiAgfTtcbiAgLyoqXG4gICAqIFNlbmQgZXZlbnRzIGlmIHJlYWR5LiBSZXR1cm5zIHRydWUgaWYgZXZlbnRzIGFyZSBzZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3NlbmRFdmVudHNJZlJlYWR5ID0gZnVuY3Rpb24gX3NlbmRFdmVudHNJZlJlYWR5KCkge1xuICAgIGlmICh0aGlzLl91bnNlbnRDb3VudCgpID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpZiBiYXRjaGluZyBkaXNhYmxlZCwgc2VuZCBhbnkgdW5zZW50IGV2ZW50cyBpbW1lZGlhdGVseVxuXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5iYXRjaEV2ZW50cykge1xuICAgICAgdGhpcy5zZW5kRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGlmIGJhdGNoaW5nIGVuYWJsZWQsIGNoZWNrIGlmIG1pbiB0aHJlc2hvbGQgbWV0IGZvciBiYXRjaCBzaXplXG5cblxuICAgIGlmICh0aGlzLl91bnNlbnRDb3VudCgpID49IHRoaXMub3B0aW9ucy5ldmVudFVwbG9hZFRocmVzaG9sZCkge1xuICAgICAgdGhpcy5zZW5kRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIG90aGVyd2lzZSBzY2hlZHVsZSBhbiB1cGxvYWQgYWZ0ZXIgMzBzXG5cblxuICAgIGlmICghdGhpcy5fdXBkYXRlU2NoZWR1bGVkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2Ugb25seSBzY2hlZHVsZSAxIHVwbG9hZFxuICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kRXZlbnRzKCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMub3B0aW9ucy5ldmVudFVwbG9hZFBlcmlvZE1pbGxpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBhbiB1cGxvYWQgd2FzIHNjaGVkdWxlZCwgbm8gZXZlbnRzIHdlcmUgdXBsb2FkZWRcbiAgfTtcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCB2YWx1ZXMgZnJvbSBzdG9yYWdlXG4gICAqIFN0b3JhZ2UgYXJndW1lbnQgYWxsb3dzIGZvciBsb2NhbFN0b3Jhb2dlIGFuZCBzZXNzaW9uU3RvcmFvZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9nZXRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIF9nZXRGcm9tU3RvcmFnZShzdG9yYWdlLCBrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKGtleSArIHRoaXMuX3N0b3JhZ2VTdWZmaXgpO1xuICB9O1xuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHNldCB2YWx1ZXMgaW4gc3RvcmFnZVxuICAgKiBTdG9yYWdlIGFyZ3VtZW50IGFsbG93cyBmb3IgbG9jYWxTdG9yYW9nZSBhbmQgc2Vzc2lvblN0b3Jhb2dlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fc2V0SW5TdG9yYWdlID0gZnVuY3Rpb24gX3NldEluU3RvcmFnZShzdG9yYWdlLCBrZXksIHZhbHVlKSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKGtleSArIHRoaXMuX3N0b3JhZ2VTdWZmaXgsIHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEZldGNoZXMgZGV2aWNlSWQsIHVzZXJJZCwgZXZlbnQgbWV0YSBkYXRhIGZyb20gYW1wbGl0dWRlIGNvb2tpZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHZhciBfbG9hZENvb2tpZURhdGEgPSBmdW5jdGlvbiBfbG9hZENvb2tpZURhdGEoc2NvcGUpIHtcbiAgICBpZiAoIXNjb3BlLl91c2VPbGRDb29raWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IHNjb3BlLl9tZXRhZGF0YVN0b3JhZ2UubG9hZCgpO1xuXG4gICAgICBpZiAodHlwZShwcm9wcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIF9sb2FkQ29va2llRGF0YVByb3BzKHNjb3BlLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGNvb2tpZURhdGEgPSBzY29wZS5jb29raWVTdG9yYWdlLmdldChzY29wZS5fb2xkQ29va2llbmFtZSk7XG5cbiAgICBpZiAodHlwZShjb29raWVEYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIF9sb2FkQ29va2llRGF0YVByb3BzKHNjb3BlLCBjb29raWVEYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29va2llRGF0YSk7XG4gIH07XG5cbiAgdmFyIF91cGdyYWRlQ29va2llRGF0YSA9IGZ1bmN0aW9uIF91cGdyYWRlQ29va2llRGF0YShzY29wZSkge1xuICAgIHZhciBjb29raWVEYXRhID0gc2NvcGUuY29va2llU3RvcmFnZS5nZXQoc2NvcGUuX29sZENvb2tpZW5hbWUpO1xuXG4gICAgaWYgKHR5cGUoY29va2llRGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBfbG9hZENvb2tpZURhdGFQcm9wcyhzY29wZSwgY29va2llRGF0YSk7XG5cbiAgICAgIF9zYXZlQ29va2llRGF0YShzY29wZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfbG9hZENvb2tpZURhdGFQcm9wcyA9IGZ1bmN0aW9uIF9sb2FkQ29va2llRGF0YVByb3BzKHNjb3BlLCBjb29raWVEYXRhKSB7XG4gICAgaWYgKGNvb2tpZURhdGEuZGV2aWNlSWQpIHtcbiAgICAgIHNjb3BlLm9wdGlvbnMuZGV2aWNlSWQgPSBjb29raWVEYXRhLmRldmljZUlkO1xuICAgIH1cblxuICAgIGlmIChjb29raWVEYXRhLnVzZXJJZCkge1xuICAgICAgc2NvcGUub3B0aW9ucy51c2VySWQgPSBjb29raWVEYXRhLnVzZXJJZDtcbiAgICB9XG5cbiAgICBpZiAoY29va2llRGF0YS5vcHRPdXQgIT09IG51bGwgJiYgY29va2llRGF0YS5vcHRPdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRG8gbm90IGNsb2JiZXIgY29uZmlnIG9wdCBvdXQgdmFsdWUgaWYgY29va2llRGF0YSBoYXMgb3B0T3V0IGFzIGZhbHNlXG4gICAgICBpZiAoY29va2llRGF0YS5vcHRPdXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMub3B0T3V0ID0gY29va2llRGF0YS5vcHRPdXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZURhdGEuc2Vzc2lvbklkKSB7XG4gICAgICBzY29wZS5fc2Vzc2lvbklkID0gcGFyc2VJbnQoY29va2llRGF0YS5zZXNzaW9uSWQsIDEwKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llRGF0YS5sYXN0RXZlbnRUaW1lKSB7XG4gICAgICBzY29wZS5fbGFzdEV2ZW50VGltZSA9IHBhcnNlSW50KGNvb2tpZURhdGEubGFzdEV2ZW50VGltZSwgMTApO1xuICAgIH1cblxuICAgIGlmIChjb29raWVEYXRhLmV2ZW50SWQpIHtcbiAgICAgIHNjb3BlLl9ldmVudElkID0gcGFyc2VJbnQoY29va2llRGF0YS5ldmVudElkLCAxMCk7XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZURhdGEuaWRlbnRpZnlJZCkge1xuICAgICAgc2NvcGUuX2lkZW50aWZ5SWQgPSBwYXJzZUludChjb29raWVEYXRhLmlkZW50aWZ5SWQsIDEwKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llRGF0YS5zZXF1ZW5jZU51bWJlcikge1xuICAgICAgc2NvcGUuX3NlcXVlbmNlTnVtYmVyID0gcGFyc2VJbnQoY29va2llRGF0YS5zZXF1ZW5jZU51bWJlciwgMTApO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNhdmVzIGRldmljZUlkLCB1c2VySWQsIGV2ZW50IG1ldGEgZGF0YSB0byBhbXBsaXR1ZGUgY29va2llXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgdmFyIF9zYXZlQ29va2llRGF0YSA9IGZ1bmN0aW9uIF9zYXZlQ29va2llRGF0YShzY29wZSkge1xuICAgIHZhciBjb29raWVEYXRhID0ge1xuICAgICAgZGV2aWNlSWQ6IHNjb3BlLm9wdGlvbnMuZGV2aWNlSWQsXG4gICAgICB1c2VySWQ6IHNjb3BlLm9wdGlvbnMudXNlcklkLFxuICAgICAgb3B0T3V0OiBzY29wZS5vcHRpb25zLm9wdE91dCxcbiAgICAgIHNlc3Npb25JZDogc2NvcGUuX3Nlc3Npb25JZCxcbiAgICAgIGxhc3RFdmVudFRpbWU6IHNjb3BlLl9sYXN0RXZlbnRUaW1lLFxuICAgICAgZXZlbnRJZDogc2NvcGUuX2V2ZW50SWQsXG4gICAgICBpZGVudGlmeUlkOiBzY29wZS5faWRlbnRpZnlJZCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiBzY29wZS5fc2VxdWVuY2VOdW1iZXJcbiAgICB9O1xuXG4gICAgaWYgKEFzeW5jU3RvcmFnZSkge1xuICAgICAgQXN5bmNTdG9yYWdlLnNldEl0ZW0oc2NvcGUuX3N0b3JhZ2VTdWZmaXgsIEpTT04uc3RyaW5naWZ5KGNvb2tpZURhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUuX3VzZU9sZENvb2tpZSkge1xuICAgICAgc2NvcGUuY29va2llU3RvcmFnZS5zZXQoc2NvcGUub3B0aW9ucy5jb29raWVOYW1lICsgc2NvcGUuX3N0b3JhZ2VTdWZmaXgsIGNvb2tpZURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NvcGUuX21ldGFkYXRhU3RvcmFnZS5zYXZlKGNvb2tpZURhdGEpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIHRoZSB1dG0gcHJvcGVydGllcyBvdXQgb2YgY29va2llcyBhbmQgcXVlcnkgZm9yIGFkZGluZyB0byB1c2VyIHByb3BlcnRpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5faW5pdFV0bURhdGEgPSBmdW5jdGlvbiBfaW5pdFV0bURhdGEocXVlcnlQYXJhbXMsIGNvb2tpZVBhcmFtcykge1xuICAgIHF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXMgfHwgdGhpcy5fZ2V0VXJsUGFyYW1zKCk7XG4gICAgY29va2llUGFyYW1zID0gY29va2llUGFyYW1zIHx8IHRoaXMuY29va2llU3RvcmFnZS5nZXQoJ19fdXRteicpO1xuICAgIHZhciB1dG1Qcm9wZXJ0aWVzID0gZ2V0VXRtRGF0YShjb29raWVQYXJhbXMsIHF1ZXJ5UGFyYW1zKTtcblxuICAgIF9zZW5kUGFyYW1zUmVmZXJyZXJVc2VyUHJvcGVydGllcyh0aGlzLCB1dG1Qcm9wZXJ0aWVzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFVuc2V0IHRoZSB1dG0gcGFyYW1zIGZyb20gdGhlIEFtcGxpdHVkZSBpbnN0YW5jZSBhbmQgdXBkYXRlIHRoZSBpZGVudGlmeS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl91bnNldFVUTVBhcmFtcyA9IGZ1bmN0aW9uIF91bnNldFVUTVBhcmFtcygpIHtcbiAgICB2YXIgaWRlbnRpZnkgPSBuZXcgSWRlbnRpZnkoKTtcbiAgICBpZGVudGlmeS51bnNldChDb25zdGFudHMuUkVGRVJSRVIpO1xuICAgIGlkZW50aWZ5LnVuc2V0KENvbnN0YW50cy5VVE1fU09VUkNFKTtcbiAgICBpZGVudGlmeS51bnNldChDb25zdGFudHMuVVRNX01FRElVTSk7XG4gICAgaWRlbnRpZnkudW5zZXQoQ29uc3RhbnRzLlVUTV9DQU1QQUlHTik7XG4gICAgaWRlbnRpZnkudW5zZXQoQ29uc3RhbnRzLlVUTV9URVJNKTtcbiAgICBpZGVudGlmeS51bnNldChDb25zdGFudHMuVVRNX0NPTlRFTlQpO1xuICAgIHRoaXMuaWRlbnRpZnkoaWRlbnRpZnkpO1xuICB9O1xuICAvKipcbiAgICogVGhlIGNhbGxpbmcgZnVuY3Rpb24gc2hvdWxkIGRldGVybWluZSB3aGVuIGl0IGlzIGFwcHJvcHJpYXRlIHRvIHNlbmQgdGhlc2UgdXNlciBwcm9wZXJ0aWVzLiBUaGlzIGZ1bmN0aW9uXG4gICAqIHdpbGwgbm8gbG9uZ2VyIGNvbnRhaW4gYW55IHNlc3Npb24gc3RvcmFnZSBjaGVja2luZyBsb2dpYy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICB2YXIgX3NlbmRQYXJhbXNSZWZlcnJlclVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX3NlbmRQYXJhbXNSZWZlcnJlclVzZXJQcm9wZXJ0aWVzKHNjb3BlLCB1c2VyUHJvcGVydGllcykge1xuICAgIGlmICh0eXBlKHVzZXJQcm9wZXJ0aWVzKSAhPT0gJ29iamVjdCcgfHwgT2JqZWN0LmtleXModXNlclByb3BlcnRpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2V0T25jZSB0aGUgaW5pdGlhbCB1c2VyIHByb3BlcnRpZXNcblxuXG4gICAgdmFyIGlkZW50aWZ5ID0gbmV3IElkZW50aWZ5KCk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdXNlclByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh1c2VyUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlkZW50aWZ5LnNldE9uY2UoJ2luaXRpYWxfJyArIGtleSwgdXNlclByb3BlcnRpZXNba2V5XSk7XG4gICAgICAgIGlkZW50aWZ5LnNldChrZXksIHVzZXJQcm9wZXJ0aWVzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjb3BlLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fZ2V0UmVmZXJyZXIgPSBmdW5jdGlvbiBfZ2V0UmVmZXJyZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnJlZmVycmVyO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9nZXRVcmxQYXJhbXMgPSBmdW5jdGlvbiBfZ2V0VXJsUGFyYW1zKCkge1xuICAgIHJldHVybiBsb2NhdGlvbi5zZWFyY2g7XG4gIH07XG4gIC8qKlxuICAgKiBUcnkgdG8gZmV0Y2ggR29vZ2xlIEdjbGlkIGZyb20gdXJsIHBhcmFtcy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9zYXZlR2NsaWQgPSBmdW5jdGlvbiBfc2F2ZUdjbGlkKHVybFBhcmFtcykge1xuICAgIHZhciBnY2xpZCA9IHV0aWxzLmdldFF1ZXJ5UGFyYW0oJ2djbGlkJywgdXJsUGFyYW1zKTtcblxuICAgIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKGdjbGlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnY2xpZFByb3BlcnRpZXMgPSB7XG4gICAgICAnZ2NsaWQnOiBnY2xpZFxuICAgIH07XG5cbiAgICBfc2VuZFBhcmFtc1JlZmVycmVyVXNlclByb3BlcnRpZXModGhpcywgZ2NsaWRQcm9wZXJ0aWVzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRyeSB0byBmZXRjaCBBbXBsaXR1ZGUgZGV2aWNlIGlkIGZyb20gdXJsIHBhcmFtcy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9nZXREZXZpY2VJZEZyb21VcmxQYXJhbSA9IGZ1bmN0aW9uIF9nZXREZXZpY2VJZEZyb21VcmxQYXJhbSh1cmxQYXJhbXMpIHtcbiAgICByZXR1cm4gdXRpbHMuZ2V0UXVlcnlQYXJhbShDb25zdGFudHMuQU1QX0RFVklDRV9JRF9QQVJBTSwgdXJsUGFyYW1zKTtcbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBkb21haW4gZnJvbSByZWZlcnJlciBpbmZvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fZ2V0UmVmZXJyaW5nRG9tYWluID0gZnVuY3Rpb24gX2dldFJlZmVycmluZ0RvbWFpbihyZWZlcnJlcikge1xuICAgIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHJlZmVycmVyKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gcmVmZXJyZXIuc3BsaXQoJy8nKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMykge1xuICAgICAgcmV0dXJuIHBhcnRzWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICAvKipcbiAgICogRmV0Y2ggdGhlIHJlZmVycmVyIGluZm9ybWF0aW9uLCBwYXJzZSB0aGUgZG9tYWluIGFuZCBzZW5kLlxuICAgKiBTaW5jZSB1c2VyIHByb3BlcnRpZXMgYXJlIHByb3BhZ2F0ZWQgb24gdGhlIHNlcnZlciwgb25seSBzZW5kIG9uY2UgcGVyIHNlc3Npb24sIGRvbid0IG5lZWQgdG8gc2VuZCB3aXRoIGV2ZXJ5IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fc2F2ZVJlZmVycmVyID0gZnVuY3Rpb24gX3NhdmVSZWZlcnJlcihyZWZlcnJlcikge1xuICAgIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHJlZmVycmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWZlcnJlckluZm8gPSB7XG4gICAgICAncmVmZXJyZXInOiByZWZlcnJlcixcbiAgICAgICdyZWZlcnJpbmdfZG9tYWluJzogdGhpcy5fZ2V0UmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKVxuICAgIH07XG5cbiAgICBfc2VuZFBhcmFtc1JlZmVycmVyVXNlclByb3BlcnRpZXModGhpcywgcmVmZXJyZXJJbmZvKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNhdmVzIHVuc2VudCBldmVudHMgYW5kIGlkZW50aWZpZXMgdG8gbG9jYWxTdG9yYWdlLiBKU09OIHN0cmluZ2lmaWVzIGV2ZW50IHF1ZXVlcyBiZWZvcmUgc2F2aW5nLlxuICAgKiBOb3RlOiB0aGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGV2ZXJ5IHRpbWUgZXZlbnRzIGFyZSBsb2dnZWQsIHVubGVzcyB5b3UgZXhwbGljaXRseSBzZXQgb3B0aW9uIHNhdmVFdmVudHMgdG8gZmFsc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zYXZlRXZlbnRzID0gZnVuY3Rpb24gc2F2ZUV2ZW50cygpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWRVbnNlbnRFdmVudHMgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl91bnNlbnRFdmVudHMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBldmVudCA9IF9yZWYuZXZlbnQ7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKEFzeW5jU3RvcmFnZSkge1xuICAgICAgICBBc3luY1N0b3JhZ2Uuc2V0SXRlbSh0aGlzLm9wdGlvbnMudW5zZW50S2V5ICsgdGhpcy5fc3RvcmFnZVN1ZmZpeCwgc2VyaWFsaXplZFVuc2VudEV2ZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRJblN0b3JhZ2UobG9jYWxTdG9yYWdlJDEsIHRoaXMub3B0aW9ucy51bnNlbnRLZXksIHNlcmlhbGl6ZWRVbnNlbnRFdmVudHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWRJZGVudGlmeXMgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl91bnNlbnRJZGVudGlmeXMubWFwKGZ1bmN0aW9uICh1bnNlbnRJZGVudGlmeSkge1xuICAgICAgICByZXR1cm4gdW5zZW50SWRlbnRpZnkuZXZlbnQ7XG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChBc3luY1N0b3JhZ2UpIHtcbiAgICAgICAgQXN5bmNTdG9yYWdlLnNldEl0ZW0odGhpcy5vcHRpb25zLnVuc2VudElkZW50aWZ5S2V5ICsgdGhpcy5fc3RvcmFnZVN1ZmZpeCwgc2VyaWFsaXplZElkZW50aWZ5cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRJblN0b3JhZ2UobG9jYWxTdG9yYWdlJDEsIHRoaXMub3B0aW9ucy51bnNlbnRJZGVudGlmeUtleSwgc2VyaWFsaXplZElkZW50aWZ5cyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b21lciBkb21haW4gZm9yIHRoZSBhbXBsaXR1ZGUgY29va2llLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gc3VwcG9ydCBjcm9zcy1zdWJkb21haW4gdHJhY2tpbmcuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbiB0byBzZXQuXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5zZXREb21haW4oJy5hbXBsaXR1ZGUuY29tJyk7XG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXREb21haW4gPSBmdW5jdGlvbiBzZXREb21haW4oZG9tYWluKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnc2V0RG9tYWluJ10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoZG9tYWluLCAnZG9tYWluJywgJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29va2llU3RvcmFnZS5vcHRpb25zKHtcbiAgICAgICAgZXhwaXJhdGlvbkRheXM6IHRoaXMub3B0aW9ucy5jb29raWVFeHBpcmF0aW9uLFxuICAgICAgICBzZWN1cmU6IHRoaXMub3B0aW9ucy5zZWN1cmVDb29raWUsXG4gICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICBzYW1lU2l0ZTogdGhpcy5vcHRpb25zLnNhbWVTaXRlQ29va2llXG4gICAgICB9KTtcbiAgICAgIHRoaXMub3B0aW9ucy5kb21haW4gPSB0aGlzLmNvb2tpZVN0b3JhZ2Uub3B0aW9ucygpLmRvbWFpbjtcblxuICAgICAgX2xvYWRDb29raWVEYXRhKHRoaXMpO1xuXG4gICAgICBfc2F2ZUNvb2tpZURhdGEodGhpcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gaWRlbnRpZmllciB0byBzZXQuIENhbiBiZSBudWxsLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQuc2V0VXNlcklkKCdqb2VAZ21haWwuY29tJyk7XG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRVc2VySWQgPSBmdW5jdGlvbiBzZXRVc2VySWQodXNlcklkKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnc2V0VXNlcklkJ10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJJZCA9IHVzZXJJZCAhPT0gdW5kZWZpbmVkICYmIHVzZXJJZCAhPT0gbnVsbCAmJiAnJyArIHVzZXJJZCB8fCBudWxsO1xuXG4gICAgICBfc2F2ZUNvb2tpZURhdGEodGhpcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFkZCB1c2VyIHRvIGEgZ3JvdXAgb3IgZ3JvdXBzLiBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgZ3JvdXBUeXBlIGFuZCBncm91cE5hbWUocykuXG4gICAqIEZvciBleGFtcGxlIHlvdSBjYW4gZ3JvdXAgcGVvcGxlIGJ5IHRoZWlyIG9yZ2FuaXphdGlvbi5cbiAgICogSW4gdGhhdCBjYXNlIGdyb3VwVHlwZSBpcyBcIm9yZ0lkXCIgYW5kIGdyb3VwTmFtZSB3b3VsZCBiZSB0aGUgYWN0dWFsIElEKHMpLlxuICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdG8gaW5kaWNhdGUgYSB1c2VyIGluIG11bHRpcGxlIGdydXVwcy5cbiAgICogWW91IGNhbiBhbHNvIGNhbGwgc2V0R3JvdXAgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgZ3JvdXBUeXBlcyB0byB0cmFjayBtdWx0aXBsZSB0eXBlcyBvZiBncm91cHMgKHVwIHRvIDUgcGVyIGFwcCkuXG4gICAqIE5vdGU6IHRoaXMgd2lsbCBhbHNvIHNldCBncm91cFR5cGU6IGdyb3VwTmFtZSBhcyBhIHVzZXIgcHJvcGVydHkuXG4gICAqIFNlZSB0aGUgW1NESyBSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjc2V0dGluZy1ncm91cHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cFR5cGUgLSB0aGUgZ3JvdXAgdHlwZSAoZXg6IG9yZ0lkKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xsaXN0fSBncm91cE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZ3JvdXAgKGV4OiAxNSksIG9yIGEgbGlzdCBvZiBuYW1lcyBvZiB0aGUgZ3JvdXBzXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5zZXRHcm91cCgnb3JnSWQnLCAxNSk7IC8vIHRoaXMgYWRkcyB0aGUgY3VycmVudCB1c2VyIHRvIG9yZ0lkIDE1LlxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuc2V0R3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBUeXBlLCBncm91cE5hbWUpIHtcbiAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xLnB1c2goWydzZXRHcm91cCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ3NldEdyb3VwKCknKSB8fCAhdXRpbHMudmFsaWRhdGVJbnB1dChncm91cFR5cGUsICdncm91cFR5cGUnLCAnc3RyaW5nJykgfHwgdXRpbHMuaXNFbXB0eVN0cmluZyhncm91cFR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgIGdyb3Vwc1tncm91cFR5cGVdID0gZ3JvdXBOYW1lO1xuICAgIHZhciBpZGVudGlmeSA9IG5ldyBJZGVudGlmeSgpLnNldChncm91cFR5cGUsIGdyb3VwTmFtZSk7XG5cbiAgICB0aGlzLl9sb2dFdmVudChDb25zdGFudHMuSURFTlRJRllfRVZFTlQsIG51bGwsIG51bGwsIGlkZW50aWZ5LnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucywgZ3JvdXBzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBvcHQgY3VycmVudCB1c2VyIG91dCBvZiB0cmFja2luZy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAtIGlmIHRydWUgdGhlbiBubyBldmVudHMgd2lsbCBiZSBsb2dnZWQgb3Igc2VudC5cbiAgICogQGV4YW1wbGU6IGFtcGxpdHVkZS5zZXRPcHRPdXQodHJ1ZSk7XG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRPcHRPdXQgPSBmdW5jdGlvbiBzZXRPcHRPdXQoZW5hYmxlKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnc2V0T3B0T3V0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoZW5hYmxlLCAnZW5hYmxlJywgJ2Jvb2xlYW4nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLm9wdGlvbnMub3B0T3V0ID0gZW5hYmxlO1xuXG4gICAgICBfc2F2ZUNvb2tpZURhdGEodGhpcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfTtcblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldFNlc3Npb25JZCA9IGZ1bmN0aW9uIHNldFNlc3Npb25JZChzZXNzaW9uSWQpIHtcbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoc2Vzc2lvbklkLCAnc2Vzc2lvbklkJywgJ251bWJlcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHNlc3Npb25JZDtcblxuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5yZXNldFNlc3Npb25JZCA9IGZ1bmN0aW9uIHJlc2V0U2Vzc2lvbklkKCkge1xuICAgIHRoaXMuc2V0U2Vzc2lvbklkKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgfTtcbiAgLyoqXG4gICAgKiBSZWdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGV2aWNlSWQgZm9yIGN1cnJlbnQgdXNlci4gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91XG4gICAgKiBhcmUgZG9pbmcuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgc2V0VXNlcklkKG51bGwpYCB0byBhbm9ueW1pemUgdXNlcnMgYWZ0ZXIgdGhleSBsb2cgb3V0LlxuICAgICogV2l0aCBhIG51bGwgdXNlcklkIGFuZCBhIGNvbXBsZXRlbHkgbmV3IGRldmljZUlkLCB0aGUgY3VycmVudCB1c2VyIHdvdWxkIGFwcGVhciBhcyBhIGJyYW5kIG5ldyB1c2VyIGluIGRhc2hib2FyZC5cbiAgICAqIFRoaXMgdXNlcyBzcmMvdXVpZC5qcyB0byByZWdlbmVyYXRlIHRoZSBkZXZpY2VJZC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5yZWdlbmVyYXRlRGV2aWNlSWQgPSBmdW5jdGlvbiByZWdlbmVyYXRlRGV2aWNlSWQoKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsncmVnZW5lcmF0ZURldmljZUlkJ10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldERldmljZUlkKGJhc2U2NElkKCkpO1xuICB9O1xuICAvKipcbiAgICAqIFNldHMgYSBjdXN0b20gZGV2aWNlSWQgZm9yIGN1cnJlbnQgdXNlci4gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZ1xuICAgICogKGxpa2UgaWYgeW91IGhhdmUgeW91ciBvd24gc3lzdGVtIGZvciBtYW5hZ2luZyBkZXZpY2VJZHMpLiBNYWtlIHN1cmUgdGhlIGRldmljZUlkIHlvdSBzZXQgaXMgc3VmZmljaWVudGx5IHVuaXF1ZVxuICAgICogKHdlIHJlY29tbWVuZCBzb21ldGhpbmcgbGlrZSBhIFVVSUQgLSBzZWUgc3JjL3V1aWQuanMgZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGdlbmVyYXRlKSB0byBwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIG90aGVyIGRldmljZXMgaW4gb3VyIHN5c3RlbS5cbiAgICAqIEBwdWJsaWNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCAtIGN1c3RvbSBkZXZpY2VJZCBmb3IgY3VycmVudCB1c2VyLlxuICAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LnNldERldmljZUlkKCc0NWYwOTU0Zi1lYjc5LTQ0NjMtYWM4YS0yMzNhNmY0NWE4ZjAnKTtcbiAgICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnc2V0RGV2aWNlSWQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dChkZXZpY2VJZCwgJ2RldmljZUlkJywgJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghdXRpbHMuaXNFbXB0eVN0cmluZyhkZXZpY2VJZCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRldmljZUlkID0gJycgKyBkZXZpY2VJZDtcblxuICAgICAgICBfc2F2ZUNvb2tpZURhdGEodGhpcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdXNlciBwcm9wZXJ0aWVzIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAtIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgZm9yIHRoZSB1c2VyIHByb3BlcnRpZXMgdG8gc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IC0gREVQUkVDQVRFRCBvcHRfcmVwbGFjZTogaW4gZWFybGllciB2ZXJzaW9ucyBvZiB0aGUgSlMgU0RLIHRoZSB1c2VyIHByb3BlcnRpZXMgb2JqZWN0IHdhcyBrZXB0IGluXG4gICAqIG1lbW9yeSBhbmQgcmVwbGFjZSA9IHRydWUgd291bGQgcmVwbGFjZSB0aGUgb2JqZWN0IGluIG1lbW9yeS4gTm93IHRoZSBwcm9wZXJ0aWVzIGFyZSBubyBsb25nZXIgc3RvcmVkIGluIG1lbW9yeSwgc28gcmVwbGFjZSBpcyBkZXByZWNhdGVkLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQuc2V0VXNlclByb3BlcnRpZXMoeydnZW5kZXInOiAnZmVtYWxlJywgJ3NpZ25fdXBfY29tcGxldGUnOiB0cnVlfSlcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldFVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpIHtcbiAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xLnB1c2goWydzZXRVc2VyUHJvcGVydGllcyddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ3NldFVzZXJQcm9wZXJ0aWVzKCknKSB8fCAhdXRpbHMudmFsaWRhdGVJbnB1dCh1c2VyUHJvcGVydGllcywgJ3VzZXJQcm9wZXJ0aWVzJywgJ29iamVjdCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYW5pdGl6ZSB0aGUgdXNlclByb3BlcnRpZXMgZGljdCBiZWZvcmUgY29udmVydGluZyBpbnRvIGlkZW50aWZ5XG5cblxuICAgIHZhciBzYW5pdGl6ZWQgPSB1dGlscy50cnVuY2F0ZSh1dGlscy52YWxpZGF0ZVByb3BlcnRpZXModXNlclByb3BlcnRpZXMpKTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhzYW5pdGl6ZWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY29udmVydCB1c2VyUHJvcGVydGllcyBpbnRvIGFuIGlkZW50aWZ5IGNhbGxcblxuXG4gICAgdmFyIGlkZW50aWZ5ID0gbmV3IElkZW50aWZ5KCk7XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzYW5pdGl6ZWQpIHtcbiAgICAgIGlmIChzYW5pdGl6ZWQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIGlkZW50aWZ5LnNldChwcm9wZXJ0eSwgc2FuaXRpemVkW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pZGVudGlmeShpZGVudGlmeSk7XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2YgdGhlIHVzZXIgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gTm90ZTogY2xlYXJpbmcgdXNlciBwcm9wZXJ0aWVzIGlzIGlycmV2ZXJzaWJsZSFcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQuY2xlYXJVc2VyUHJvcGVydGllcygpO1xuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuY2xlYXJVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIGNsZWFyVXNlclByb3BlcnRpZXMoKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnY2xlYXJVc2VyUHJvcGVydGllcyddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ2NsZWFyVXNlclByb3BlcnRpZXMoKScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkZW50aWZ5ID0gbmV3IElkZW50aWZ5KCk7XG4gICAgaWRlbnRpZnkuY2xlYXJBbGwoKTtcbiAgICB0aGlzLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgfTtcbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3hpZWQgZnVuY3Rpb25zIG9uIHRoZSBwcm94aWVkIG9iamVjdCB0byBhbiBpbnN0YW5jZSBvZiB0aGUgcmVhbCBvYmplY3QuXG4gICAqIFVzZWQgdG8gY29udmVydCBwcm94aWVkIElkZW50aWZ5IGFuZCBSZXZlbnVlIG9iamVjdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgdmFyIF9jb252ZXJ0UHJveHlPYmplY3RUb1JlYWxPYmplY3QgPSBmdW5jdGlvbiBfY29udmVydFByb3h5T2JqZWN0VG9SZWFsT2JqZWN0KGluc3RhbmNlLCBwcm94eSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJveHkuX3EubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGluc3RhbmNlW3Byb3h5Ll9xW2ldWzBdXTtcblxuICAgICAgaWYgKHR5cGUoZm4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZuLmFwcGx5KGluc3RhbmNlLCBwcm94eS5fcVtpXS5zbGljZSgxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuICAvKipcbiAgICogU2VuZCBhbiBpZGVudGlmeSBjYWxsIGNvbnRhaW5pbmcgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zIHRvIEFtcGxpdHVkZSBzZXJ2ZXJzLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN1c2VyLXByb3BlcnRpZXMtYW5kLXVzZXItcHJvcGVydHktb3BlcmF0aW9uc31cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge0lkZW50aWZ5fSBpZGVudGlmeV9vYmogLSB0aGUgSWRlbnRpZnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9ucyB0byBzZW5kLlxuICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBpZGVudGlmeSBldmVudCBoYXMgYmVlbiBzZW50LlxuICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgaWRlbnRpZnkgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuc2V0KCdjb2xvcnMnLCBbJ3Jvc2UnLCAnZ29sZCddKS5hZGQoJ2thcm1hJywgMSkuc2V0T25jZSgnc2lnbl91cF9kYXRlJywgJzIwMTYtMDMtMzEnKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKGlkZW50aWZ5X29iaiwgb3B0X2NhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnaWRlbnRpZnknXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdpZGVudGlmeSgpJykpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnQVBJIGtleSBpcyBub3Qgc2V0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgaWRlbnRpZnkgaW5wdXQgaXMgYSBwcm94aWVkIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBhc3luYyBsb2FkaW5nIHNuaXBwZXQsIGNvbnZlcnQgaXQgaW50byBhbiBpZGVudGlmeSBvYmplY3RcblxuXG4gICAgaWYgKHR5cGUoaWRlbnRpZnlfb2JqKSA9PT0gJ29iamVjdCcgJiYgaWRlbnRpZnlfb2JqLmhhc093blByb3BlcnR5KCdfcScpKSB7XG4gICAgICBpZGVudGlmeV9vYmogPSBfY29udmVydFByb3h5T2JqZWN0VG9SZWFsT2JqZWN0KG5ldyBJZGVudGlmeSgpLCBpZGVudGlmeV9vYmopO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmeV9vYmogaW5zdGFuY2VvZiBJZGVudGlmeSkge1xuICAgICAgLy8gb25seSBzZW5kIGlmIHRoZXJlIGFyZSBvcGVyYXRpb25zXG4gICAgICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpZnlfb2JqLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nRXZlbnQoQ29uc3RhbnRzLklERU5USUZZX0VWRU5ULCBudWxsLCBudWxsLCBpZGVudGlmeV9vYmoudXNlclByb3BlcnRpZXNPcGVyYXRpb25zLCBudWxsLCBudWxsLCBudWxsLCBvcHRfY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUob3B0X2NhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICAgICAgcmVhc29uOiAnTm8gdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCBpZGVudGlmeSBpbnB1dCB0eXBlLiBFeHBlY3RlZCBJZGVudGlmeSBvYmplY3QgYnV0IHNhdyAnICsgdHlwZShpZGVudGlmeV9vYmopKTtcblxuICAgICAgaWYgKHR5cGUob3B0X2NhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRfY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcsIHtcbiAgICAgICAgICByZWFzb246ICdJbnZhbGlkIGlkZW50aWZ5IGlucHV0IHR5cGUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmdyb3VwSWRlbnRpZnkgPSBmdW5jdGlvbiAoZ3JvdXBfdHlwZSwgZ3JvdXBfbmFtZSwgaWRlbnRpZnlfb2JqLCBvcHRfY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xLnB1c2goWydncm91cElkZW50aWZ5J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2FwaUtleVNldCgnZ3JvdXBJZGVudGlmeSgpJykpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnQVBJIGtleSBpcyBub3Qgc2V0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dChncm91cF90eXBlLCAnZ3JvdXBfdHlwZScsICdzdHJpbmcnKSB8fCB1dGlscy5pc0VtcHR5U3RyaW5nKGdyb3VwX3R5cGUpKSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICAgIHJlYXNvbjogJ0ludmFsaWQgZ3JvdXAgdHlwZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBfbmFtZSA9PT0gbnVsbCB8fCBncm91cF9uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnSW52YWxpZCBncm91cCBuYW1lJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgaWRlbnRpZnkgaW5wdXQgaXMgYSBwcm94aWVkIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBhc3luYyBsb2FkaW5nIHNuaXBwZXQsIGNvbnZlcnQgaXQgaW50byBhbiBpZGVudGlmeSBvYmplY3RcblxuXG4gICAgaWYgKHR5cGUoaWRlbnRpZnlfb2JqKSA9PT0gJ29iamVjdCcgJiYgaWRlbnRpZnlfb2JqLmhhc093blByb3BlcnR5KCdfcScpKSB7XG4gICAgICBpZGVudGlmeV9vYmogPSBfY29udmVydFByb3h5T2JqZWN0VG9SZWFsT2JqZWN0KG5ldyBJZGVudGlmeSgpLCBpZGVudGlmeV9vYmopO1xuICAgIH1cblxuICAgIGlmIChpZGVudGlmeV9vYmogaW5zdGFuY2VvZiBJZGVudGlmeSkge1xuICAgICAgLy8gb25seSBzZW5kIGlmIHRoZXJlIGFyZSBvcGVyYXRpb25zXG4gICAgICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpZnlfb2JqLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nRXZlbnQoQ29uc3RhbnRzLkdST1VQX0lERU5USUZZX0VWRU5ULCBudWxsLCBudWxsLCBudWxsLCBfZGVmaW5lUHJvcGVydHkoe30sIGdyb3VwX3R5cGUsIGdyb3VwX25hbWUpLCBpZGVudGlmeV9vYmoudXNlclByb3BlcnRpZXNPcGVyYXRpb25zLCBudWxsLCBvcHRfY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUob3B0X2NhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICAgICAgcmVhc29uOiAnTm8gZ3JvdXAgcHJvcGVydHkgb3BlcmF0aW9ucydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoJ0ludmFsaWQgaWRlbnRpZnkgaW5wdXQgdHlwZS4gRXhwZWN0ZWQgSWRlbnRpZnkgb2JqZWN0IGJ1dCBzYXcgJyArIHR5cGUoaWRlbnRpZnlfb2JqKSk7XG5cbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnSW52YWxpZCBpZGVudGlmeSBpbnB1dCB0eXBlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgYSB2ZXJzaW9uTmFtZSBmb3IgeW91ciBhcHBsaWNhdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbk5hbWUgLSBUaGUgdmVyc2lvbiB0byBzZXQgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5zZXRWZXJzaW9uTmFtZSgnMS4xMi4zJyk7XG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRWZXJzaW9uTmFtZSA9IGZ1bmN0aW9uIHNldFZlcnNpb25OYW1lKHZlcnNpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnc2V0VmVyc2lvbk5hbWUnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dCh2ZXJzaW9uTmFtZSwgJ3ZlcnNpb25OYW1lJywgJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnZlcnNpb25OYW1lID0gdmVyc2lvbk5hbWU7XG4gIH07XG4gIC8qKlxuICAgKiBQcml2YXRlIGxvZ0V2ZW50IG1ldGhvZC4gS2VlcHMgYXBpUHJvcGVydGllcyBmcm9tIGJlaW5nIHB1YmxpY2x5IGV4cG9zZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fbG9nRXZlbnQgPSBmdW5jdGlvbiBfbG9nRXZlbnQoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIGFwaVByb3BlcnRpZXMsIHVzZXJQcm9wZXJ0aWVzLCBncm91cHMsIGdyb3VwUHJvcGVydGllcywgdGltZXN0YW1wLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWRDb29raWVEYXRhID0gXCJcIjtcblxuICAgIHtcbiAgICAgIGxvYWRlZENvb2tpZURhdGEgPSBfbG9hZENvb2tpZURhdGEodGhpcyk7IC8vIHJlbG9hZCBjb29raWUgYmVmb3JlIGVhY2ggbG9nIGV2ZW50IHRvIHN5bmMgZXZlbnQgbWV0YS1kYXRhIGJldHdlZW4gd2luZG93cyBhbmQgdGFic1xuICAgIH1cblxuICAgIGlmICghZXZlbnRUeXBlKSB7XG4gICAgICBpZiAodHlwZShjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcsIHtcbiAgICAgICAgICByZWFzb246ICdNaXNzaW5nIGV2ZW50VHlwZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wdE91dCkge1xuICAgICAgaWYgKHR5cGUoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnb3B0T3V0IGlzIHNldCB0byB0cnVlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgZXZlbnRJZDtcblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gQ29uc3RhbnRzLklERU5USUZZX0VWRU5UIHx8IGV2ZW50VHlwZSA9PT0gQ29uc3RhbnRzLkdST1VQX0lERU5USUZZX0VWRU5UKSB7XG4gICAgICAgIGV2ZW50SWQgPSB0aGlzLm5leHRJZGVudGlmeUlkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudElkID0gdGhpcy5uZXh0RXZlbnRJZCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VxdWVuY2VOdW1iZXIgPSB0aGlzLm5leHRTZXF1ZW5jZU51bWJlcigpO1xuICAgICAgdmFyIGV2ZW50VGltZSA9IHR5cGUodGltZXN0YW1wKSA9PT0gJ251bWJlcicgPyB0aW1lc3RhbXAgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgaWYgKCF0aGlzLl9zZXNzaW9uSWQgfHwgIXRoaXMuX2xhc3RFdmVudFRpbWUgfHwgZXZlbnRUaW1lIC0gdGhpcy5fbGFzdEV2ZW50VGltZSA+IHRoaXMub3B0aW9ucy5zZXNzaW9uVGltZW91dCkge1xuICAgICAgICB0aGlzLl9zZXNzaW9uSWQgPSBldmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhc3RFdmVudFRpbWUgPSBldmVudFRpbWU7XG5cbiAgICAgIHZhciBzYXZlZENvb2tpZURhdGEgPSBfc2F2ZUNvb2tpZURhdGEodGhpcyk7XG5cbiAgICAgIHZhciBvc05hbWUgPSB0aGlzLl91YS5icm93c2VyLm5hbWU7XG4gICAgICB2YXIgb3NWZXJzaW9uID0gdGhpcy5fdWEuYnJvd3Nlci5tYWpvcjtcbiAgICAgIHZhciBkZXZpY2VNb2RlbCA9IHRoaXMuX3VhLmRldmljZS5tb2RlbDtcbiAgICAgIHZhciBkZXZpY2VNYW51ZmFjdHVyZXIgPSB0aGlzLl91YS5kZXZpY2UudmVuZG9yO1xuICAgICAgdmFyIHZlcnNpb25OYW1lO1xuICAgICAgdmFyIGNhcnJpZXI7XG5cbiAgICAgIHVzZXJQcm9wZXJ0aWVzID0gdXNlclByb3BlcnRpZXMgfHwge307XG5cbiAgICAgIHZhciB0cmFja2luZ09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLl9hcGlQcm9wZXJ0aWVzVHJhY2tpbmdPcHRpb25zKTtcblxuICAgICAgYXBpUHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQoe30sIGFwaVByb3BlcnRpZXMgfHwge30sIHRyYWNraW5nT3B0aW9ucyk7XG4gICAgICBldmVudFByb3BlcnRpZXMgPSBldmVudFByb3BlcnRpZXMgfHwge307XG4gICAgICBncm91cHMgPSBncm91cHMgfHwge307XG4gICAgICBncm91cFByb3BlcnRpZXMgPSBncm91cFByb3BlcnRpZXMgfHwge307XG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIGRldmljZV9pZDogdGhpcy5vcHRpb25zLmRldmljZUlkLFxuICAgICAgICB1c2VyX2lkOiB0aGlzLm9wdGlvbnMudXNlcklkLFxuICAgICAgICB0aW1lc3RhbXA6IGV2ZW50VGltZSxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICAgIHNlc3Npb25faWQ6IHRoaXMuX3Nlc3Npb25JZCB8fCAtMSxcbiAgICAgICAgZXZlbnRfdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICB2ZXJzaW9uX25hbWU6IF9zaG91bGRUcmFja0ZpZWxkKHRoaXMsICd2ZXJzaW9uX25hbWUnKSA/IHRoaXMub3B0aW9ucy52ZXJzaW9uTmFtZSB8fCB2ZXJzaW9uTmFtZSB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgcGxhdGZvcm06IF9zaG91bGRUcmFja0ZpZWxkKHRoaXMsICdwbGF0Zm9ybScpID8gdGhpcy5vcHRpb25zLnBsYXRmb3JtIDogbnVsbCxcbiAgICAgICAgb3NfbmFtZTogX3Nob3VsZFRyYWNrRmllbGQodGhpcywgJ29zX25hbWUnKSA/IG9zTmFtZSB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgb3NfdmVyc2lvbjogX3Nob3VsZFRyYWNrRmllbGQodGhpcywgJ29zX3ZlcnNpb24nKSA/IG9zVmVyc2lvbiB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgZGV2aWNlX21vZGVsOiBfc2hvdWxkVHJhY2tGaWVsZCh0aGlzLCAnZGV2aWNlX21vZGVsJykgPyBkZXZpY2VNb2RlbCB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgZGV2aWNlX21hbnVmYWN0dXJlcjogX3Nob3VsZFRyYWNrRmllbGQodGhpcywgJ2RldmljZV9tYW51ZmFjdHVyZXInKSA/IGRldmljZU1hbnVmYWN0dXJlciB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgbGFuZ3VhZ2U6IF9zaG91bGRUcmFja0ZpZWxkKHRoaXMsICdsYW5ndWFnZScpID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlIDogbnVsbCxcbiAgICAgICAgY2FycmllcjogX3Nob3VsZFRyYWNrRmllbGQodGhpcywgJ2NhcnJpZXInKSA/IGNhcnJpZXIgfHwgbnVsbCA6IG51bGwsXG4gICAgICAgIGFwaV9wcm9wZXJ0aWVzOiBhcGlQcm9wZXJ0aWVzLFxuICAgICAgICBldmVudF9wcm9wZXJ0aWVzOiB1dGlscy50cnVuY2F0ZSh1dGlscy52YWxpZGF0ZVByb3BlcnRpZXMoZXZlbnRQcm9wZXJ0aWVzKSksXG4gICAgICAgIHVzZXJfcHJvcGVydGllczogX29iamVjdFNwcmVhZCh7fSwgdXRpbHMudHJ1bmNhdGUodXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKSksIHtcbiAgICAgICAgICAnY29va2llcyBkaXNhYmxlZCc6IHRoaXMuX21ldGFkYXRhU3RvcmFnZS5kaXNhYmxlQ29va2llU3RvcmFnZSxcbiAgICAgICAgICAnYmxhbmsgY29va2llJzogdGhpcy5fbWV0YWRhdGFTdG9yYWdlLmJsYW5rQ29va2llLFxuICAgICAgICAgICdjb29raWUgZXJyb3InOiB0aGlzLl9tZXRhZGF0YVN0b3JhZ2UuY29va2llRXJyb3IsXG4gICAgICAgICAgJ3VzZSBvbGQgY29va2llJzogdGhpcy5fdXNlT2xkQ29va2llLFxuICAgICAgICAgICdzYXZlZCBjb29raWUgZGF0YSc6IHNhdmVkQ29va2llRGF0YSxcbiAgICAgICAgICAnbG9hZGVkIGNvb2tpZSBkYXRhJzogbG9hZGVkQ29va2llRGF0YVxuICAgICAgICB9KSxcbiAgICAgICAgdXVpZDogdXVpZCgpLFxuICAgICAgICBsaWJyYXJ5OiB7XG4gICAgICAgICAgbmFtZTogJ2FtcGxpdHVkZS1qcycsXG4gICAgICAgICAgdmVyc2lvbjogdmVyc2lvblxuICAgICAgICB9LFxuICAgICAgICBzZXF1ZW5jZV9udW1iZXI6IHNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAvLyBmb3Igb3JkZXJpbmcgZXZlbnRzIGFuZCBpZGVudGlmeXNcbiAgICAgICAgZ3JvdXBzOiB1dGlscy50cnVuY2F0ZSh1dGlscy52YWxpZGF0ZUdyb3Vwcyhncm91cHMpKSxcbiAgICAgICAgZ3JvdXBfcHJvcGVydGllczogdXRpbHMudHJ1bmNhdGUodXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKGdyb3VwUHJvcGVydGllcykpLFxuICAgICAgICB1c2VyX2FnZW50OiB0aGlzLl91c2VyQWdlbnRcbiAgICAgIH07XG5cbiAgICAgIGlmIChldmVudFR5cGUgPT09IENvbnN0YW50cy5JREVOVElGWV9FVkVOVCB8fCBldmVudFR5cGUgPT09IENvbnN0YW50cy5HUk9VUF9JREVOVElGWV9FVkVOVCkge1xuICAgICAgICB0aGlzLl91bnNlbnRJZGVudGlmeXMucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9saW1pdEV2ZW50c1F1ZXVlZCh0aGlzLl91bnNlbnRJZGVudGlmeXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdW5zZW50RXZlbnRzLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fbGltaXRFdmVudHNRdWV1ZWQodGhpcy5fdW5zZW50RXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYXZlRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2F2ZUV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZW5kRXZlbnRzSWZSZWFkeShjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9zaG91bGRUcmFja0ZpZWxkID0gZnVuY3Rpb24gX3Nob3VsZFRyYWNrRmllbGQoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuICEhc2NvcGUub3B0aW9ucy50cmFja2luZ09wdGlvbnNbZmllbGRdO1xuICB9O1xuXG4gIHZhciBfZ2VuZXJhdGVBcGlQcm9wZXJ0aWVzVHJhY2tpbmdDb25maWcgPSBmdW5jdGlvbiBfZ2VuZXJhdGVBcGlQcm9wZXJ0aWVzVHJhY2tpbmdDb25maWcoc2NvcGUpIHtcbiAgICAvLyB0byBsaW1pdCBzaXplIG9mIGNvbmZpZyBwYXlsb2FkLCBvbmx5IHNlbmQgZmllbGRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG4gICAgdmFyIGZpZWxkcyA9IFsnY2l0eScsICdjb3VudHJ5JywgJ2RtYScsICdpcF9hZGRyZXNzJywgJ3JlZ2lvbiddO1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG5cbiAgICAgIGlmICghX3Nob3VsZFRyYWNrRmllbGQoc2NvcGUsIGZpZWxkKSkge1xuICAgICAgICBjb25maWdbZmllbGRdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBvbGQgZXZlbnRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgaWYgdG9vIG1hbnkgaGF2ZSBhY2N1bXVsYXRlZC4gRGVmYXVsdCBsaW1pdCBpcyAxMDAwIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9saW1pdEV2ZW50c1F1ZXVlZCA9IGZ1bmN0aW9uIF9saW1pdEV2ZW50c1F1ZXVlZChxdWV1ZSkge1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPiB0aGlzLm9wdGlvbnMuc2F2ZWRNYXhDb3VudCkge1xuICAgICAgcXVldWUuc3BsaWNlKDAsIHF1ZXVlLmxlbmd0aCAtIHRoaXMub3B0aW9ucy5zYXZlZE1heENvdW50KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgbG9nRXZlbnQgYW5kIGlkZW50aWZ5IGNhbGxzLiBJdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgZXZlbnQvaWRlbnRpZnkgaXMgdXBsb2FkZWQsXG4gICAqIGFuZCB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgdXBsb2FkIHJlcXVlc3QgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBjYWxsYmFjayBBbXBsaXR1ZGV+ZXZlbnRDYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzcG9uc2VDb2RlIC0gU2VydmVyIHJlc3BvbnNlIGNvZGUgZm9yIHRoZSBldmVudCAvIGlkZW50aWZ5IHVwbG9hZCByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VCb2R5IC0gU2VydmVyIHJlc3BvbnNlIGJvZHkgZm9yIHRoZSBldmVudCAvIGlkZW50aWZ5IHVwbG9hZCByZXF1ZXN0LlxuICAgKi9cblxuICAvKipcbiAgICogTG9nIGFuIGV2ZW50IHdpdGggZXZlbnRUeXBlIGFuZCBldmVudFByb3BlcnRpZXNcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gbmFtZSBvZiBldmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQcm9wZXJ0aWVzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtBbXBsaXR1ZGV+ZXZlbnRDYWxsYmFja30gb3B0X2NhbGxiYWNrIC0gKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgZXZlbnQgaXMgbG9nZ2VkLlxuICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQubG9nRXZlbnQoJ0NsaWNrZWQgSG9tZXBhZ2UgQnV0dG9uJywgeydmaW5pc2hlZF9mbG93JzogZmFsc2UsICdjbGlja3MnOiAxNX0pO1xuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiBsb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgb3B0X2NhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3Nob3VsZERlZmVyQ2FsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcS5wdXNoKFsnbG9nRXZlbnQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvZ0V2ZW50V2l0aFRpbWVzdGFtcChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgbnVsbCwgb3B0X2NhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqIExvZyBhbiBldmVudCB3aXRoIGV2ZW50VHlwZSBhbmQgZXZlbnRQcm9wZXJ0aWVzIGFuZCBhIGN1c3RvbSB0aW1lc3RhbXBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gbmFtZSBvZiBldmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQcm9wZXJ0aWVzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIChvcHRpb25hbCkgdGhlIGN1c3RvbSB0aW1lc3RhbXAgYXMgbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLlxuICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBldmVudCBpcyBsb2dnZWQuXG4gICAqIE5vdGU6IHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBhbmQgcmVzcG9uc2UgYm9keSBmcm9tIHRoZSBldmVudCB1cGxvYWQgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5sb2dFdmVudCgnQ2xpY2tlZCBIb21lcGFnZSBCdXR0b24nLCB7J2ZpbmlzaGVkX2Zsb3cnOiBmYWxzZSwgJ2NsaWNrcyc6IDE1fSk7XG4gICAqL1xuXG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5sb2dFdmVudFdpdGhUaW1lc3RhbXAgPSBmdW5jdGlvbiBsb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgdGltZXN0YW1wLCBvcHRfY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xLnB1c2goWydsb2dFdmVudFdpdGhUaW1lc3RhbXAnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdsb2dFdmVudCgpJykpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnQVBJIGtleSBub3Qgc2V0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dChldmVudFR5cGUsICdldmVudFR5cGUnLCAnc3RyaW5nJykpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnSW52YWxpZCB0eXBlIGZvciBldmVudFR5cGUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoZXZlbnRUeXBlKSkge1xuICAgICAgaWYgKHR5cGUob3B0X2NhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRfY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcsIHtcbiAgICAgICAgICByZWFzb246ICdNaXNzaW5nIGV2ZW50VHlwZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbG9nRXZlbnQoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIHRpbWVzdGFtcCwgb3B0X2NhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqIExvZyBhbiBldmVudCB3aXRoIGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBhbmQgZ3JvdXBzLiBVc2UgdGhpcyB0byBzZXQgZXZlbnQtbGV2ZWwgZ3JvdXBzLlxuICAgKiBOb3RlOiB0aGUgZ3JvdXAocykgc2V0IG9ubHkgYXBwbHkgZm9yIHRoZSBzcGVjaWZpYyBldmVudCB0eXBlIGJlaW5nIGxvZ2dlZCBhbmQgZG9lcyBub3QgcGVyc2lzdCBvbiB0aGUgdXNlclxuICAgKiAodW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBpdCB3aXRoIHNldEdyb3VwKS5cbiAgICogU2VlIHRoZSBbU0RLIFJlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNzZXR0aW5nLWdyb3Vwc30gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogYWJvdXQgZ3JvdXBzIGFuZCBDb3VudCBieSBEaXN0aW5jdCBvbiB0aGUgQW1wbGl0dWRlIHBsYXRmb3JtLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFByb3BlcnRpZXMgLSAob3B0aW9uYWwpIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgZm9yIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgZ3JvdXBUeXBlOiBncm91cE5hbWUgdmFsdWVzIGZvciB0aGUgZXZlbnQgYmVpbmcgbG9nZ2VkLlxuICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IG9wdF9jYWxsYmFjayAtIChvcHRpb25hbCkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGV2ZW50IGlzIGxvZ2dlZC5cbiAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmxvZ0V2ZW50V2l0aEdyb3VwcygnQ2xpY2tlZCBCdXR0b24nLCBudWxsLCB7J29yZ0lkJzogMjR9KTtcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmxvZ0V2ZW50V2l0aEdyb3VwcyA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgZ3JvdXBzLCBvcHRfY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xLnB1c2goWydsb2dFdmVudFdpdGhHcm91cHMnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdsb2dFdmVudFdpdGhHcm91cHMoKScpKSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICAgIHJlYXNvbjogJ0FQSSBrZXkgbm90IHNldCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoZXZlbnRUeXBlLCAnZXZlbnRUeXBlJywgJ3N0cmluZycpKSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICAgIHJlYXNvbjogJ0ludmFsaWQgdHlwZSBmb3IgZXZlbnRUeXBlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9sb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgbnVsbCwgbnVsbCwgZ3JvdXBzLCBudWxsLCBudWxsLCBvcHRfY2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICogVGVzdCB0aGF0IG4gaXMgYSBudW1iZXIgb3IgYSBudW1lcmljIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gIH07XG4gIC8qKlxuICAgKiBMb2cgcmV2ZW51ZSB3aXRoIFJldmVudWUgaW50ZXJmYWNlLiBUaGUgbmV3IHJldmVudWUgaW50ZXJmYWNlIGFsbG93cyBmb3IgbW9yZSByZXZlbnVlIGZpZWxkcyBsaWtlXG4gICAqIHJldmVudWVUeXBlIGFuZCBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN0cmFja2luZy1yZXZlbnVlfVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgUmV2ZW51ZSBpbnRlcmZhY2UgYW5kIGxvZ2dpbmcgcmV2ZW51ZS5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1JldmVudWV9IHJldmVudWVfb2JqIC0gdGhlIHJldmVudWUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJldmVudWUgZGF0YSBiZWluZyBsb2dnZWQuXG4gICAqIEBleGFtcGxlIHZhciByZXZlbnVlID0gbmV3IGFtcGxpdHVkZS5SZXZlbnVlKCkuc2V0UHJvZHVjdElkKCdwcm9kdWN0SWRlbnRpZmllcicpLnNldFByaWNlKDEwLjk5KTtcbiAgICogYW1wbGl0dWRlLmxvZ1JldmVudWVWMihyZXZlbnVlKTtcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmxvZ1JldmVudWVWMiA9IGZ1bmN0aW9uIGxvZ1JldmVudWVWMihyZXZlbnVlX29iaikge1xuICAgIGlmICh0aGlzLl9zaG91bGREZWZlckNhbGwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3EucHVzaChbJ2xvZ1JldmVudWVWMiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ2xvZ1JldmVudWVWMigpJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHJldmVudWUgaW5wdXQgaXMgYSBwcm94aWVkIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBhc3luYyBsb2FkaW5nIHNuaXBwZXQsIGNvbnZlcnQgaXQgaW50byBhbiByZXZlbnVlIG9iamVjdFxuXG5cbiAgICBpZiAodHlwZShyZXZlbnVlX29iaikgPT09ICdvYmplY3QnICYmIHJldmVudWVfb2JqLmhhc093blByb3BlcnR5KCdfcScpKSB7XG4gICAgICByZXZlbnVlX29iaiA9IF9jb252ZXJ0UHJveHlPYmplY3RUb1JlYWxPYmplY3QobmV3IFJldmVudWUoKSwgcmV2ZW51ZV9vYmopO1xuICAgIH1cblxuICAgIGlmIChyZXZlbnVlX29iaiBpbnN0YW5jZW9mIFJldmVudWUpIHtcbiAgICAgIC8vIG9ubHkgc2VuZCBpZiByZXZlbnVlIGlzIHZhbGlkXG4gICAgICBpZiAocmV2ZW51ZV9vYmogJiYgcmV2ZW51ZV9vYmouX2lzVmFsaWRSZXZlbnVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nRXZlbnQoQ29uc3RhbnRzLlJFVkVOVUVfRVZFTlQsIHJldmVudWVfb2JqLl90b0pTT05PYmplY3QoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCByZXZlbnVlIGlucHV0IHR5cGUuIEV4cGVjdGVkIFJldmVudWUgb2JqZWN0IGJ1dCBzYXcgJyArIHR5cGUocmV2ZW51ZV9vYmopKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIC8qKlxuICAgICAqIExvZyByZXZlbnVlIGV2ZW50IHdpdGggYSBwcmljZSwgcXVhbnRpdHksIGFuZCBwcm9kdWN0IGlkZW50aWZpZXIuIERFUFJFQ0FURUQgLSB1c2UgbG9nUmV2ZW51ZVYyXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByaWNlIC0gcHJpY2Ugb2YgcmV2ZW51ZSBldmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFudGl0eSAtIChvcHRpb25hbCkgcXVhbnRpdHkgb2YgcHJvZHVjdHMgaW4gcmV2ZW51ZSBldmVudC4gSWYgbm8gcXVhbnRpdHkgc3BlY2lmaWVkIGRlZmF1bHQgdG8gMS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZHVjdCAtIChvcHRpb25hbCkgcHJvZHVjdCBpZGVudGlmaWVyXG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmxvZ1JldmVudWUoMy45OSwgMSwgJ3Byb2R1Y3RfMTIzNCcpO1xuICAgICAqL1xuICAgIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubG9nUmV2ZW51ZSA9IGZ1bmN0aW9uIGxvZ1JldmVudWUocHJpY2UsIHF1YW50aXR5LCBwcm9kdWN0KSB7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkRGVmZXJDYWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3EucHVzaChbJ2xvZ1JldmVudWUnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgfSAvLyBUZXN0IHRoYXQgdGhlIHBhcmFtZXRlcnMgYXJlIG9mIHRoZSByaWdodCB0eXBlLlxuXG5cbiAgICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdsb2dSZXZlbnVlKCknKSB8fCAhX2lzTnVtYmVyKHByaWNlKSB8fCBxdWFudGl0eSAhPT0gdW5kZWZpbmVkICYmICFfaXNOdW1iZXIocXVhbnRpdHkpKSB7XG4gICAgICAgIC8vIHV0aWxzLmxvZygnUHJpY2UgYW5kIHF1YW50aXR5IGFyZ3VtZW50cyB0byBsb2dSZXZlbnVlIG11c3QgYmUgbnVtYmVycycpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9sb2dFdmVudChDb25zdGFudHMuUkVWRU5VRV9FVkVOVCwge30sIHtcbiAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0LFxuICAgICAgICBzcGVjaWFsOiAncmV2ZW51ZV9hbW91bnQnLFxuICAgICAgICBxdWFudGl0eTogcXVhbnRpdHkgfHwgMSxcbiAgICAgICAgcHJpY2U6IHByaWNlXG4gICAgICB9LCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnRzIGluIHN0b3JhZ2Ugd2l0aCBldmVudCBpZHMgdXAgdG8gYW5kIGluY2x1ZGluZyBtYXhFdmVudElkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQsIHN0YXR1cywgcmVzcG9uc2UpIHtcbiAgICBfcmVtb3ZlRXZlbnRzKHRoaXMsICdfdW5zZW50RXZlbnRzJywgbWF4RXZlbnRJZCwgc3RhdHVzLCByZXNwb25zZSk7XG5cbiAgICBfcmVtb3ZlRXZlbnRzKHRoaXMsICdfdW5zZW50SWRlbnRpZnlzJywgbWF4SWRlbnRpZnlJZCwgc3RhdHVzLCByZXNwb25zZSk7XG4gIH07XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50cyB1cCB0byBtYXhJZCBmcm9tIGEgc2luZ2xlIHF1ZXVlLlxuICAgKiBEb2VzIGEgdHJ1ZSBmaWx0ZXIgaW4gY2FzZSBldmVudHMgZ2V0IG91dCBvZiBvcmRlciBvciBvbGQgZXZlbnRzIGFyZSByZW1vdmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHZhciBfcmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50cyhzY29wZSwgZXZlbnRRdWV1ZSwgbWF4SWQsIHN0YXR1cywgcmVzcG9uc2UpIHtcbiAgICBpZiAobWF4SWQgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcmVkRXZlbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlW2V2ZW50UXVldWVdLmxlbmd0aCB8fCAwOyBpKyspIHtcbiAgICAgIHZhciB1bnNlbnRFdmVudCA9IHNjb3BlW2V2ZW50UXVldWVdW2ldO1xuXG4gICAgICBpZiAodW5zZW50RXZlbnQuZXZlbnQuZXZlbnRfaWQgPiBtYXhJZCkge1xuICAgICAgICBmaWx0ZXJlZEV2ZW50cy5wdXNoKHVuc2VudEV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1bnNlbnRFdmVudC5jYWxsYmFjaykge1xuICAgICAgICAgIHVuc2VudEV2ZW50LmNhbGxiYWNrKHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NvcGVbZXZlbnRRdWV1ZV0gPSBmaWx0ZXJlZEV2ZW50cztcbiAgfTtcbiAgLyoqXG4gICAqIFNlbmQgdW5zZW50IGV2ZW50cy4gTm90ZTogdGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBhZnRlciBldmVudHMgYXJlIGxvZ2dlZCBpZiBvcHRpb24gYmF0Y2hFdmVudHMgaXMgZmFsc2UuXG4gICAqIElmIGJhdGNoRXZlbnRzIGlzIHRydWUsIHRoZW4gZXZlbnRzIGFyZSBvbmx5IHNlbnQgd2hlbiBiYXRjaCBjcml0ZXJpYXMgYXJlIG1ldC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNlbmRFdmVudHMgPSBmdW5jdGlvbiBzZW5kRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdzZW5kRXZlbnRzKCknKSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudHMoSW5maW5pdHksIEluZmluaXR5LCAwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICByZWFzb246ICdBUEkga2V5IG5vdCBzZXQnXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wdE91dCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudHMoSW5maW5pdHksIEluZmluaXR5LCAwLCAnTm8gcmVxdWVzdCBzZW50Jywge1xuICAgICAgICByZWFzb246ICdPcHQgb3V0IGlzIHNldCB0byB0cnVlJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBIb3cgaXMgaXQgcG9zc2libGUgdG8gZ2V0IGludG8gdGhpcyBzdGF0ZT9cblxuXG4gICAgaWYgKHRoaXMuX3Vuc2VudENvdW50KCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG9ubHkgbWFrZSBvbmUgcmVxdWVzdCBhdCBhIHRpbWUuIHNlbmRFdmVudHMgd2lsbCBiZSBpbnZva2VkIGFnYWluIG9uY2VcbiAgICAvLyB0aGUgbGFzdCByZXF1ZXN0IGNvbXBsZXRlcy5cblxuXG4gICAgaWYgKHRoaXMuX3NlbmRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kaW5nID0gdHJ1ZTtcbiAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuZm9yY2VIdHRwcyA/ICdodHRwcycgOiAnaHR0cHM6JyA9PT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgICB2YXIgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIHRoaXMub3B0aW9ucy5hcGlFbmRwb2ludDsgLy8gZmV0Y2ggZXZlbnRzIHRvIHNlbmRcblxuICAgIHZhciBudW1FdmVudHMgPSBNYXRoLm1pbih0aGlzLl91bnNlbnRDb3VudCgpLCB0aGlzLm9wdGlvbnMudXBsb2FkQmF0Y2hTaXplKTtcblxuICAgIHZhciBtZXJnZWRFdmVudHMgPSB0aGlzLl9tZXJnZUV2ZW50c0FuZElkZW50aWZ5cyhudW1FdmVudHMpO1xuXG4gICAgdmFyIG1heEV2ZW50SWQgPSBtZXJnZWRFdmVudHMubWF4RXZlbnRJZDtcbiAgICB2YXIgbWF4SWRlbnRpZnlJZCA9IG1lcmdlZEV2ZW50cy5tYXhJZGVudGlmeUlkO1xuICAgIHZhciBldmVudHMgPSBKU09OLnN0cmluZ2lmeShtZXJnZWRFdmVudHMuZXZlbnRzVG9TZW5kLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBldmVudCA9IF9yZWYyLmV2ZW50O1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0pKTtcbiAgICB2YXIgdXBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xpZW50OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgZTogZXZlbnRzLFxuICAgICAgdjogQ29uc3RhbnRzLkFQSV9WRVJTSU9OLFxuICAgICAgdXBsb2FkX3RpbWU6IHVwbG9hZFRpbWUsXG4gICAgICBjaGVja3N1bTogbWQ1KENvbnN0YW50cy5BUElfVkVSU0lPTiArIHRoaXMub3B0aW9ucy5hcGlLZXkgKyBldmVudHMgKyB1cGxvYWRUaW1lKVxuICAgIH07XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICBuZXcgUmVxdWVzdCh1cmwsIGRhdGEpLnNlbmQoZnVuY3Rpb24gKHN0YXR1cywgcmVzcG9uc2UpIHtcbiAgICAgIHNjb3BlLl9zZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiByZXNwb25zZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgc2NvcGUucmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQsIHN0YXR1cywgcmVzcG9uc2UpOyAvLyBVcGRhdGUgdGhlIGV2ZW50IGNhY2hlIGFmdGVyIHRoZSByZW1vdmFsIG9mIHNlbnQgZXZlbnRzLlxuXG4gICAgICAgICAgaWYgKHNjb3BlLm9wdGlvbnMuc2F2ZUV2ZW50cykge1xuICAgICAgICAgICAgc2NvcGUuc2F2ZUV2ZW50cygpO1xuICAgICAgICAgIH0gLy8gU2VuZCBtb3JlIGV2ZW50cyBpZiBhbnkgcXVldWVkIGR1cmluZyBwcmV2aW91cyBzZW5kLlxuXG5cbiAgICAgICAgICBzY29wZS5fc2VuZEV2ZW50c0lmUmVhZHkoKTsgLy8gaGFuZGxlIHBheWxvYWQgdG9vIGxhcmdlXG5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQxMykge1xuICAgICAgICAgIC8vIHV0aWxzLmxvZygncmVxdWVzdCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAvLyBDYW4ndCBldmVuIGdldCB0aGlzIG9uZSBtYXNzaXZlIGV2ZW50IHRocm91Z2guIERyb3AgaXQsIGV2ZW4gaWYgaXQgaXMgYW4gaWRlbnRpZnkuXG4gICAgICAgICAgaWYgKHNjb3BlLm9wdGlvbnMudXBsb2FkQmF0Y2hTaXplID09PSAxKSB7XG4gICAgICAgICAgICBzY29wZS5yZW1vdmVFdmVudHMobWF4RXZlbnRJZCwgbWF4SWRlbnRpZnlJZCwgc3RhdHVzLCByZXNwb25zZSk7XG4gICAgICAgICAgfSAvLyBUaGUgc2VydmVyIGNvbXBsYWluZWQgYWJvdXQgdGhlIGxlbmd0aCBvZiB0aGUgcmVxdWVzdC4gQmFja29mZiBhbmQgdHJ5IGFnYWluLlxuXG5cbiAgICAgICAgICBzY29wZS5vcHRpb25zLnVwbG9hZEJhdGNoU2l6ZSA9IE1hdGguY2VpbChudW1FdmVudHMgLyAyKTtcbiAgICAgICAgICBzY29wZS5zZW5kRXZlbnRzKCk7XG4gICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgIC8vICBhbGwgdGhlIGV2ZW50cyBhcmUgc3RpbGwgcXVldWVkLCBhbmQgd2lsbCBiZSByZXRyaWVkIHdoZW4gdGhlIG5leHRcbiAgICAgICAgLy8gIGV2ZW50IGlzIHNlbnQgSW4gdGhlIGludGVyZXN0IG9mIGRlYnVnZ2luZywgaXQgd291bGQgYmUgbmljZSB0byBoYXZlXG4gICAgICAgIC8vICBzb21ldGhpbmcgbGlrZSBhbiBldmVudCBlbWl0dGVyIGZvciBhIGJldHRlciBkZWJ1Z2dpbmcgZXhwZXJpbmNlXG4gICAgICAgIC8vICBoZXJlLlxuICAgICAgICAvLyB9XG5cbiAgICAgIH0gY2F0Y2ggKGUpIHsvLyB1dGlscy5sb2coJ2ZhaWxlZCB1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIE1lcmdlIHVuc2VudCBldmVudHMgYW5kIGlkZW50aWZ5cyB0b2dldGhlciBpbiBzZXF1ZW50aWFsIG9yZGVyIGJhc2VkIG9uIHRoZWlyIHNlcXVlbmNlIG51bWJlciwgZm9yIHVwbG9hZGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9tZXJnZUV2ZW50c0FuZElkZW50aWZ5cyA9IGZ1bmN0aW9uIF9tZXJnZUV2ZW50c0FuZElkZW50aWZ5cyhudW1FdmVudHMpIHtcbiAgICAvLyBjb2FsZXNjZSBldmVudHMgZnJvbSBib3RoIHF1ZXVlc1xuICAgIHZhciBldmVudHNUb1NlbmQgPSBbXTtcbiAgICB2YXIgZXZlbnRJbmRleCA9IDA7XG4gICAgdmFyIG1heEV2ZW50SWQgPSAtMTtcbiAgICB2YXIgaWRlbnRpZnlJbmRleCA9IDA7XG4gICAgdmFyIG1heElkZW50aWZ5SWQgPSAtMTtcblxuICAgIHdoaWxlIChldmVudHNUb1NlbmQubGVuZ3RoIDwgbnVtRXZlbnRzKSB7XG4gICAgICB2YXIgdW5zZW50RXZlbnQgPSB2b2lkIDA7XG4gICAgICB2YXIgbm9JZGVudGlmeXMgPSBpZGVudGlmeUluZGV4ID49IHRoaXMuX3Vuc2VudElkZW50aWZ5cy5sZW5ndGg7XG4gICAgICB2YXIgbm9FdmVudHMgPSBldmVudEluZGV4ID49IHRoaXMuX3Vuc2VudEV2ZW50cy5sZW5ndGg7IC8vIGNhc2UgMDogbm8gZXZlbnRzIG9yIGlkZW50aWZ5cyBsZWZ0XG4gICAgICAvLyBub3RlIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIHRoaXMgbWVhbnMgd2UgaGF2ZSBsZXNzIGV2ZW50cyBhbmQgaWRlbnRpZnlzIHRoYW4gZXhwZWN0ZWRcblxuICAgICAgaWYgKG5vRXZlbnRzICYmIG5vSWRlbnRpZnlzKSB7XG4gICAgICAgIHV0aWxzLmxvZy5lcnJvcignTWVyZ2luZyBFdmVudHMgYW5kIElkZW50aWZ5cywgbGVzcyBldmVudHMgYW5kIGlkZW50aWZ5cyB0aGFuIGV4cGVjdGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBjYXNlIDE6IG5vIGlkZW50aWZ5cyAtIGdyYWIgZnJvbSBldmVudHNcbiAgICAgIGVsc2UgaWYgKG5vSWRlbnRpZnlzKSB7XG4gICAgICAgICAgdW5zZW50RXZlbnQgPSB0aGlzLl91bnNlbnRFdmVudHNbZXZlbnRJbmRleCsrXTtcbiAgICAgICAgICBtYXhFdmVudElkID0gdW5zZW50RXZlbnQuZXZlbnQuZXZlbnRfaWQ7IC8vIGNhc2UgMjogbm8gZXZlbnRzIC0gZ3JhYiBmcm9tIGlkZW50aWZ5c1xuICAgICAgICB9IGVsc2UgaWYgKG5vRXZlbnRzKSB7XG4gICAgICAgICAgdW5zZW50RXZlbnQgPSB0aGlzLl91bnNlbnRJZGVudGlmeXNbaWRlbnRpZnlJbmRleCsrXTtcbiAgICAgICAgICBtYXhJZGVudGlmeUlkID0gdW5zZW50RXZlbnQuZXZlbnQuZXZlbnRfaWQ7IC8vIGNhc2UgMzogbmVlZCB0byBjb21wYXJlIHNlcXVlbmNlIG51bWJlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBldmVudHMgbG9nZ2VkIGJlZm9yZSB2Mi41LjAgd29uJ3QgaGF2ZSBhIHNlcXVlbmNlIG51bWJlciwgcHV0IHRob3NlIGZpcnN0XG4gICAgICAgICAgaWYgKCEoJ3NlcXVlbmNlX251bWJlcicgaW4gdGhpcy5fdW5zZW50RXZlbnRzW2V2ZW50SW5kZXhdLmV2ZW50KSB8fCB0aGlzLl91bnNlbnRFdmVudHNbZXZlbnRJbmRleF0uZXZlbnQuc2VxdWVuY2VfbnVtYmVyIDwgdGhpcy5fdW5zZW50SWRlbnRpZnlzW2lkZW50aWZ5SW5kZXhdLmV2ZW50LnNlcXVlbmNlX251bWJlcikge1xuICAgICAgICAgICAgdW5zZW50RXZlbnQgPSB0aGlzLl91bnNlbnRFdmVudHNbZXZlbnRJbmRleCsrXTtcbiAgICAgICAgICAgIG1heEV2ZW50SWQgPSB1bnNlbnRFdmVudC5ldmVudC5ldmVudF9pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5zZW50RXZlbnQgPSB0aGlzLl91bnNlbnRJZGVudGlmeXNbaWRlbnRpZnlJbmRleCsrXTtcbiAgICAgICAgICAgIG1heElkZW50aWZ5SWQgPSB1bnNlbnRFdmVudC5ldmVudC5ldmVudF9pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgZXZlbnRzVG9TZW5kLnB1c2godW5zZW50RXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBldmVudHNUb1NlbmQ6IGV2ZW50c1RvU2VuZCxcbiAgICAgIG1heEV2ZW50SWQ6IG1heEV2ZW50SWQsXG4gICAgICBtYXhJZGVudGlmeUlkOiBtYXhJZGVudGlmeUlkXG4gICAgfTtcbiAgfTtcblxuICB7XG4gICAgLyoqXG4gICAgICogU2V0IGdsb2JhbCB1c2VyIHByb3BlcnRpZXMuIE5vdGUgdGhpcyBpcyBkZXByZWNhdGVkLCBhbmQgd2UgcmVjb21tZW5kIHVzaW5nIHNldFVzZXJQcm9wZXJ0aWVzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRHbG9iYWxVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldEdsb2JhbFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLnNldFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBBbXBsaXR1ZGUncyBKYXZhc2NyaXB0IFNESy5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2ZXJzaW9uIG51bWJlclxuICAgKiBAZXhhbXBsZSB2YXIgYW1wbGl0dWRlVmVyc2lvbiA9IGFtcGxpdHVkZS5fX1ZFUlNJT05fXztcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9fVkVSU0lPTl9fID0gdmVyc2lvbjtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gcHVzaCBjYWxsIHRvIHRoaXMuX3Egb3IgaW52b2tlIGl0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3Nob3VsZERlZmVyQ2FsbCA9IGZ1bmN0aW9uIF9zaG91bGREZWZlckNhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdSZWFkU3RvcmFnZSB8fCB0aGlzLl9pbml0aWFsaXphdGlvbkRlZmVycmVkO1xuICB9O1xuICAvKipcbiAgICogRGVmZXJzIEluaXRpYWxpemF0aW9uIGJ5IHB1dHRpbmcgYWxsIGZ1bmN0aW9ucyBpbnRvIHN0b3JhZ2UgdW50aWwgdXNlcnNcbiAgICogaGF2ZSBhY2NlcHRlZCB0ZXJtcyBmb3IgdHJhY2tpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9kZWZlckluaXRpYWxpemF0aW9uID0gZnVuY3Rpb24gX2RlZmVySW5pdGlhbGl6YXRpb24oKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6YXRpb25EZWZlcnJlZCA9IHRydWU7XG5cbiAgICB0aGlzLl9xLnB1c2goWydpbml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEVuYWJsZSB0cmFja2luZyB2aWEgbG9nZ2luZyBldmVudHMgYW5kIGRyb3BwaW5nIGEgY29va2llXG4gICAqIEludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCB0aGUgZGVmZXJJbml0aWFsaXphdGlvbiBjb25maWd1cmF0aW9uIGZsYWdcbiAgICogVGhpcyB3aWxsIGRyb3AgYSBjb29raWUgYW5kIHJlc2V0IGluaXRpYWxpemF0aW9uIGRlZmVycmVkXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmVuYWJsZVRyYWNraW5nID0gZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgLy8gVGhpcyB3aWxsIGNhbGwgaW5pdCAod2hpY2ggZHJvcHMgdGhlIGNvb2tpZSkgYW5kIHdpbGwgcnVuIGFueSBwZW5kaW5nIHRhc2tzXG4gICAgdGhpcy5faW5pdGlhbGl6YXRpb25EZWZlcnJlZCA9IGZhbHNlO1xuXG4gICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuXG4gICAgdGhpcy5ydW5RdWV1ZWRGdW5jdGlvbnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQW1wbGl0dWRlIFNESyBBUEkgLSBpbnN0YW5jZSBtYW5hZ2VyLlxuICAgKiBGdW5jdGlvbiBjYWxscyBkaXJlY3RseSBvbiBhbXBsaXR1ZGUgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSBjYWxsIG1ldGhvZHMgb24gdGhlIGRlZmF1bHQgc2hhcmVkIGluc3RhbmNlOiBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKSBpbnN0ZWFkLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCMzMDAtdXBkYXRlLWFuZC1sb2dnaW5nLWV2ZW50cy10by1tdWx0aXBsZS1hbXBsaXR1ZGUtYXBwc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBjaGFuZ2UuXG4gICAqIEBjb25zdHJ1Y3RvciBBbXBsaXR1ZGVcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSB2YXIgYW1wbGl0dWRlID0gbmV3IEFtcGxpdHVkZSgpO1xuICAgKi9cblxuICB2YXIgQW1wbGl0dWRlID0gZnVuY3Rpb24gQW1wbGl0dWRlKCkge1xuICAgIHRoaXMub3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfT1BUSU9OUyk7XG4gICAgdGhpcy5fcSA9IFtdO1xuICAgIHRoaXMuX2luc3RhbmNlcyA9IHt9OyAvLyBtYXBwaW5nIG9mIGluc3RhbmNlIG5hbWVzIHRvIGluc3RhbmNlc1xuICB9O1xuXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuSWRlbnRpZnkgPSBJZGVudGlmeTtcbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5SZXZlbnVlID0gUmV2ZW51ZTtcblxuICBBbXBsaXR1ZGUucHJvdG90eXBlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZSA9IHV0aWxzLmlzRW1wdHlTdHJpbmcoaW5zdGFuY2UpID8gQ29uc3RhbnRzLkRFRkFVTFRfSU5TVEFOQ0UgOiBpbnN0YW5jZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjbGllbnQgPSB0aGlzLl9pbnN0YW5jZXNbaW5zdGFuY2VdO1xuXG4gICAgaWYgKGNsaWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGllbnQgPSBuZXcgQW1wbGl0dWRlQ2xpZW50KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuX2luc3RhbmNlc1tpbnN0YW5jZV0gPSBjbGllbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfTtcblxuICB7XG4gICAgLyoqXG4gICAgICogUnVuIGZ1bmN0aW9ucyBxdWV1ZWQgdXAgYnkgcHJveHkgbG9hZGluZyBzbmlwcGV0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLnJ1blF1ZXVlZEZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHJ1biBxdWV1ZWQgdXAgb2xkIHZlcnNpb25zIG9mIGZ1bmN0aW9uc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9xLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXNbdGhpcy5fcVtpXVswXV07XG5cbiAgICAgICAgaWYgKHR5cGUoZm4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZm4uYXBwbHkodGhpcywgdGhpcy5fcVtpXS5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcSA9IFtdOyAvLyBjbGVhciBmdW5jdGlvbiBxdWV1ZSBhZnRlciBydW5uaW5nXG4gICAgICAvLyBydW4gcXVldWVkIHVwIGZ1bmN0aW9ucyBvbiBpbnN0YW5jZXNcblxuICAgICAgZm9yICh2YXIgaW5zdGFuY2UgaW4gdGhpcy5faW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgdGhpcy5faW5zdGFuY2VzW2luc3RhbmNlXS5ydW5RdWV1ZWRGdW5jdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFtcGxpdHVkZSBKYXZhc2NyaXB0IFNESyB3aXRoIHlvdXIgYXBpS2V5IGFuZCBhbnkgb3B0aW9uYWwgY29uZmlndXJhdGlvbnMuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWZvcmUgYW55IG90aGVyIG1ldGhvZHMgY2FuIGJlIGNhbGxlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleSAtIFRoZSBBUEkga2V5IGZvciB5b3VyIGFwcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0X3VzZXJJZCAtIChvcHRpb25hbCkgQW4gaWRlbnRpZmllciBmb3IgdGhpcyB1c2VyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRfY29uZmlnIC0gKG9wdGlvbmFsKSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogU2VlIFtSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjY29uZmlndXJhdGlvbi1vcHRpb25zfSBmb3IgbGlzdCBvZiBvcHRpb25zIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUuXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5pbml0KGFwaUtleSwgb3B0X3VzZXJJZCwgb3B0X2NvbmZpZywgb3B0X2NhbGxiYWNrKTtcbiAgICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGUuaW5pdCgnQVBJX0tFWScsICdVU0VSX0lEJywge2luY2x1ZGVSZWZlcnJlcjogdHJ1ZSwgaW5jbHVkZVV0bTogdHJ1ZX0sIGZ1bmN0aW9uKCkgeyBhbGVydCgnaW5pdCBjb21wbGV0ZScpOyB9KTtcbiAgICAgKi9cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KGFwaUtleSwgb3B0X3VzZXJJZCwgb3B0X2NvbmZpZywgb3B0X2NhbGxiYWNrKSB7XG4gICAgICB0aGlzLmdldEluc3RhbmNlKCkuaW5pdChhcGlLZXksIG9wdF91c2VySWQsIG9wdF9jb25maWcsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAvLyBtYWtlIG9wdGlvbnMgc3VjaCBhcyBkZXZpY2VJZCBhdmFpbGFibGUgZm9yIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBpbnN0YW5jZS5vcHRpb25zO1xuXG4gICAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRfY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgbmV3IHNlc3Npb24gd2FzIGNyZWF0ZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBuZXcgc2Vzc2lvbiB3YXMgY3JlYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5pc05ld1Nlc3Npb24oKTtcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5pc05ld1Nlc3Npb24gPSBmdW5jdGlvbiBpc05ld1Nlc3Npb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmlzTmV3U2Vzc2lvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBJZCBvZiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuZ2V0U2Vzc2lvbklkID0gZnVuY3Rpb24gZ2V0U2Vzc2lvbklkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5nZXRTZXNzaW9uSWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgdGhlIGV2ZW50SWQgYW5kIHJldHVybnMgaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5uZXh0RXZlbnRJZCA9IGZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5uZXh0RXZlbnRJZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyB0aGUgaWRlbnRpZnlJZCBhbmQgcmV0dXJucyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLm5leHRJZGVudGlmeUlkID0gZnVuY3Rpb24gbmV4dElkZW50aWZ5SWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLm5leHRJZGVudGlmeUlkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnRzIHRoZSBzZXF1ZW5jZU51bWJlciBhbmQgcmV0dXJucyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLm5leHRTZXF1ZW5jZU51bWJlciA9IGZ1bmN0aW9uIG5leHRTZXF1ZW5jZU51bWJlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkubmV4dFNlcXVlbmNlTnVtYmVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyB1bnNlbnQgZXZlbnRzIGFuZCBpZGVudGlmaWVzIHRvIGxvY2FsU3RvcmFnZS4gSlNPTiBzdHJpbmdpZmllcyBldmVudCBxdWV1ZXMgYmVmb3JlIHNhdmluZy5cbiAgICAgKiBOb3RlOiB0aGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGV2ZXJ5IHRpbWUgZXZlbnRzIGFyZSBsb2dnZWQsIHVubGVzcyB5b3UgZXhwbGljaXRseSBzZXQgb3B0aW9uIHNhdmVFdmVudHMgdG8gZmFsc2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5zYXZlRXZlbnRzID0gZnVuY3Rpb24gc2F2ZUV2ZW50cygpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zYXZlRXZlbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tZXIgZG9tYWluIGZvciB0aGUgYW1wbGl0dWRlIGNvb2tpZS4gVXNlZnVsIGlmIHlvdSB3YW50IHRvIHN1cHBvcnQgY3Jvc3Mtc3ViZG9tYWluIHRyYWNraW5nLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluIHRvIHNldC5cbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLnNldERvbWFpbihkb21haW4pO1xuICAgICAqIEBleGFtcGxlIGFtcGxpdHVkZS5zZXREb21haW4oJy5hbXBsaXR1ZGUuY29tJyk7XG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0RG9tYWluID0gZnVuY3Rpb24gc2V0RG9tYWluKGRvbWFpbikge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldERvbWFpbihkb21haW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBpZGVudGlmaWVyIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gaWRlbnRpZmllciB0byBzZXQuIENhbiBiZSBudWxsLlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuc2V0VXNlcklkKHVzZXJJZCk7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldFVzZXJJZCgnam9lQGdtYWlsLmNvbScpO1xuICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLnNldFVzZXJJZCA9IGZ1bmN0aW9uIHNldFVzZXJJZCh1c2VySWQpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRVc2VySWQodXNlcklkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB1c2VyIHRvIGEgZ3JvdXAgb3IgZ3JvdXBzLiBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgZ3JvdXBUeXBlIGFuZCBncm91cE5hbWUocykuXG4gICAgICogRm9yIGV4YW1wbGUgeW91IGNhbiBncm91cCBwZW9wbGUgYnkgdGhlaXIgb3JnYW5pemF0aW9uLlxuICAgICAqIEluIHRoYXQgY2FzZSBncm91cFR5cGUgaXMgXCJvcmdJZFwiIGFuZCBncm91cE5hbWUgd291bGQgYmUgdGhlIGFjdHVhbCBJRChzKS5cbiAgICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdG8gaW5kaWNhdGUgYSB1c2VyIGluIG11bHRpcGxlIGdydXVwcy5cbiAgICAgKiBZb3UgY2FuIGFsc28gY2FsbCBzZXRHcm91cCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBncm91cFR5cGVzIHRvIHRyYWNrIG11bHRpcGxlIHR5cGVzIG9mIGdyb3VwcyAodXAgdG8gNSBwZXIgYXBwKS5cbiAgICAgKiBOb3RlOiB0aGlzIHdpbGwgYWxzbyBzZXQgZ3JvdXBUeXBlOiBncm91cE5hbWUgYXMgYSB1c2VyIHByb3BlcnR5LlxuICAgICAqIFNlZSB0aGUgW1NESyBSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjc2V0dGluZy1ncm91cHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBUeXBlIC0gdGhlIGdyb3VwIHR5cGUgKGV4OiBvcmdJZClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xsaXN0fSBncm91cE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZ3JvdXAgKGV4OiAxNSksIG9yIGEgbGlzdCBvZiBuYW1lcyBvZiB0aGUgZ3JvdXBzXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5zZXRHcm91cChncm91cFR5cGUsIGdyb3VwTmFtZSk7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldEdyb3VwKCdvcmdJZCcsIDE1KTsgLy8gdGhpcyBhZGRzIHRoZSBjdXJyZW50IHVzZXIgdG8gb3JnSWQgMTUuXG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0R3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBUeXBlLCBncm91cE5hbWUpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRHcm91cChncm91cFR5cGUsIGdyb3VwTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gb3B0IGN1cnJlbnQgdXNlciBvdXQgb2YgdHJhY2tpbmcuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlIC0gaWYgdHJ1ZSB0aGVuIG5vIGV2ZW50cyB3aWxsIGJlIGxvZ2dlZCBvciBzZW50LlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuc2V0T3B0T3V0KGVuYWJsZSk7XG4gICAgICogQGV4YW1wbGU6IGFtcGxpdHVkZS5zZXRPcHRPdXQodHJ1ZSk7XG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0T3B0T3V0ID0gZnVuY3Rpb24gc2V0T3B0T3V0KGVuYWJsZSkge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldE9wdE91dChlbmFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAqIFJlZ2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBkZXZpY2VJZCBmb3IgY3VycmVudCB1c2VyLiBOb3RlOiB0aGlzIGlzIG5vdCByZWNvbW1lbmRlZCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3VcbiAgICAgICogYXJlIGRvaW5nLiBUaGlzIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHNldFVzZXJJZChudWxsKWAgdG8gYW5vbnltaXplIHVzZXJzIGFmdGVyIHRoZXkgbG9nIG91dC5cbiAgICAgICogV2l0aCBhIG51bGwgdXNlcklkIGFuZCBhIGNvbXBsZXRlbHkgbmV3IGRldmljZUlkLCB0aGUgY3VycmVudCB1c2VyIHdvdWxkIGFwcGVhciBhcyBhIGJyYW5kIG5ldyB1c2VyIGluIGRhc2hib2FyZC5cbiAgICAgICogVGhpcyB1c2VzIHNyYy91dWlkLmpzIHRvIHJlZ2VuZXJhdGUgdGhlIGRldmljZUlkLlxuICAgICAgKiBAcHVibGljXG4gICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkucmVnZW5lcmF0ZURldmljZUlkKCk7XG4gICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLnJlZ2VuZXJhdGVEZXZpY2VJZCA9IGZ1bmN0aW9uIHJlZ2VuZXJhdGVEZXZpY2VJZCgpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5yZWdlbmVyYXRlRGV2aWNlSWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgKiBTZXRzIGEgY3VzdG9tIGRldmljZUlkIGZvciBjdXJyZW50IHVzZXIuIE5vdGU6IHRoaXMgaXMgbm90IHJlY29tbWVuZGVkIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmdcbiAgICAgICogKGxpa2UgaWYgeW91IGhhdmUgeW91ciBvd24gc3lzdGVtIGZvciBtYW5hZ2luZyBkZXZpY2VJZHMpLiBNYWtlIHN1cmUgdGhlIGRldmljZUlkIHlvdSBzZXQgaXMgc3VmZmljaWVudGx5IHVuaXF1ZVxuICAgICAgKiAod2UgcmVjb21tZW5kIHNvbWV0aGluZyBsaWtlIGEgVVVJRCAtIHNlZSBzcmMvdXVpZC5qcyBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZ2VuZXJhdGUpIHRvIHByZXZlbnQgY29uZmxpY3RzIHdpdGggb3RoZXIgZGV2aWNlcyBpbiBvdXIgc3lzdGVtLlxuICAgICAgKiBAcHVibGljXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCAtIGN1c3RvbSBkZXZpY2VJZCBmb3IgY3VycmVudCB1c2VyLlxuICAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLnNldERldmljZUlkKGRldmljZUlkKTtcbiAgICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldERldmljZUlkKCc0NWYwOTU0Zi1lYjc5LTQ0NjMtYWM4YS0yMzNhNmY0NWE4ZjAnKTtcbiAgICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldERldmljZUlkKGRldmljZUlkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdXNlciBwcm9wZXJ0aWVzIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gLSBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgdXNlciBwcm9wZXJ0aWVzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IC0gREVQUkVDQVRFRCBvcHRfcmVwbGFjZTogaW4gZWFybGllciB2ZXJzaW9ucyBvZiB0aGUgSlMgU0RLIHRoZSB1c2VyIHByb3BlcnRpZXMgb2JqZWN0IHdhcyBrZXB0IGluXG4gICAgICogbWVtb3J5IGFuZCByZXBsYWNlID0gdHJ1ZSB3b3VsZCByZXBsYWNlIHRoZSBvYmplY3QgaW4gbWVtb3J5LiBOb3cgdGhlIHByb3BlcnRpZXMgYXJlIG5vIGxvbmdlciBzdG9yZWQgaW4gbWVtb3J5LCBzbyByZXBsYWNlIGlzIGRlcHJlY2F0ZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2Uuc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpO1xuICAgICAqIEBleGFtcGxlIGFtcGxpdHVkZS5zZXRVc2VyUHJvcGVydGllcyh7J2dlbmRlcic6ICdmZW1hbGUnLCAnc2lnbl91cF9jb21wbGV0ZSc6IHRydWV9KVxuICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLnNldFVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRVc2VyUHJvcGVydGllcyh1c2VyUHJvcGVydGllcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgb2YgdGhlIHVzZXIgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gTm90ZTogY2xlYXJpbmcgdXNlciBwcm9wZXJ0aWVzIGlzIGlycmV2ZXJzaWJsZSFcbiAgICAgKiBAcHVibGljXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5jbGVhclVzZXJQcm9wZXJ0aWVzKCk7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLmNsZWFyVXNlclByb3BlcnRpZXMoKTtcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5jbGVhclVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gY2xlYXJVc2VyUHJvcGVydGllcygpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5jbGVhclVzZXJQcm9wZXJ0aWVzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIGlkZW50aWZ5IGNhbGwgY29udGFpbmluZyB1c2VyIHByb3BlcnR5IG9wZXJhdGlvbnMgdG8gQW1wbGl0dWRlIHNlcnZlcnMuXG4gICAgICogU2VlIFtSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjdXNlci1wcm9wZXJ0aWVzLWFuZC11c2VyLXByb3BlcnR5LW9wZXJhdGlvbnN9XG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7SWRlbnRpZnl9IGlkZW50aWZ5X29iaiAtIHRoZSBJZGVudGlmeSBvYmplY3QgY29udGFpbmluZyB0aGUgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtBbXBsaXR1ZGV+ZXZlbnRDYWxsYmFja30gb3B0X2NhbGxiYWNrIC0gKG9wdGlvbmFsKSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgaWRlbnRpZnkgZXZlbnQgaGFzIGJlZW4gc2VudC5cbiAgICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgaWRlbnRpZnkgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuaWRlbnRpZnkoaWRlbnRpZnkpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGlkZW50aWZ5ID0gbmV3IGFtcGxpdHVkZS5JZGVudGlmeSgpLnNldCgnY29sb3JzJywgWydyb3NlJywgJ2dvbGQnXSkuYWRkKCdrYXJtYScsIDEpLnNldE9uY2UoJ3NpZ25fdXBfZGF0ZScsICcyMDE2LTAzLTMxJyk7XG4gICAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5pZGVudGlmeSA9IGZ1bmN0aW9uIChpZGVudGlmeV9vYmosIG9wdF9jYWxsYmFjaykge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLmlkZW50aWZ5KGlkZW50aWZ5X29iaiwgb3B0X2NhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHZlcnNpb25OYW1lIGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbk5hbWUgLSBUaGUgdmVyc2lvbiB0byBzZXQgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5zZXRWZXJzaW9uTmFtZSh2ZXJzaW9uTmFtZSk7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldFZlcnNpb25OYW1lKCcxLjEyLjMnKTtcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5zZXRWZXJzaW9uTmFtZSA9IGZ1bmN0aW9uIHNldFZlcnNpb25OYW1lKHZlcnNpb25OYW1lKSB7XG4gICAgICB0aGlzLmdldEluc3RhbmNlKCkuc2V0VmVyc2lvbk5hbWUodmVyc2lvbk5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIGxvZ0V2ZW50IGFuZCBpZGVudGlmeSBjYWxscy4gSXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGV2ZW50L2lkZW50aWZ5IGlzIHVwbG9hZGVkLFxuICAgICAqIGFuZCB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgdXBsb2FkIHJlcXVlc3QgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGNhbGxiYWNrIEFtcGxpdHVkZX5ldmVudENhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc3BvbnNlQ29kZSAtIFNlcnZlciByZXNwb25zZSBjb2RlIGZvciB0aGUgZXZlbnQgLyBpZGVudGlmeSB1cGxvYWQgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VCb2R5IC0gU2VydmVyIHJlc3BvbnNlIGJvZHkgZm9yIHRoZSBldmVudCAvIGlkZW50aWZ5IHVwbG9hZCByZXF1ZXN0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTG9nIGFuIGV2ZW50IHdpdGggZXZlbnRUeXBlIGFuZCBldmVudFByb3BlcnRpZXNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQcm9wZXJ0aWVzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBldmVudCBpcyBsb2dnZWQuXG4gICAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmxvZ0V2ZW50KGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBvcHRfY2FsbGJhY2spO1xuICAgICAqIEBleGFtcGxlIGFtcGxpdHVkZS5sb2dFdmVudCgnQ2xpY2tlZCBIb21lcGFnZSBCdXR0b24nLCB7J2ZpbmlzaGVkX2Zsb3cnOiBmYWxzZSwgJ2NsaWNrcyc6IDE1fSk7XG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiBsb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgb3B0X2NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmxvZ0V2ZW50KGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBvcHRfY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGV2ZW50IHdpdGggZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIGFuZCBncm91cHMuIFVzZSB0aGlzIHRvIHNldCBldmVudC1sZXZlbCBncm91cHMuXG4gICAgICogTm90ZTogdGhlIGdyb3VwKHMpIHNldCBvbmx5IGFwcGx5IGZvciB0aGUgc3BlY2lmaWMgZXZlbnQgdHlwZSBiZWluZyBsb2dnZWQgYW5kIGRvZXMgbm90IHBlcnNpc3Qgb24gdGhlIHVzZXJcbiAgICAgKiAodW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBpdCB3aXRoIHNldEdyb3VwKS5cbiAgICAgKiBTZWUgdGhlIFtTREsgUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0I3NldHRpbmctZ3JvdXBzfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAqIGFib3V0IGdyb3VwcyBhbmQgQ291bnQgYnkgRGlzdGluY3Qgb24gdGhlIEFtcGxpdHVkZSBwbGF0Zm9ybS5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQcm9wZXJ0aWVzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgZ3JvdXBUeXBlOiBncm91cE5hbWUgdmFsdWVzIGZvciB0aGUgZXZlbnQgYmVpbmcgbG9nZ2VkLlxuICAgICAqIGdyb3VwTmFtZSBjYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBldmVudCBpcyBsb2dnZWQuXG4gICAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBEZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkubG9nRXZlbnRXaXRoR3JvdXBzKGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBncm91cHMsIG9wdF9jYWxsYmFjayk7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLmxvZ0V2ZW50V2l0aEdyb3VwcygnQ2xpY2tlZCBCdXR0b24nLCBudWxsLCB7J29yZ0lkJzogMjR9KTtcbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5sb2dFdmVudFdpdGhHcm91cHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIGdyb3Vwcywgb3B0X2NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmxvZ0V2ZW50V2l0aEdyb3VwcyhldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgZ3JvdXBzLCBvcHRfY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIHJldmVudWUgd2l0aCBSZXZlbnVlIGludGVyZmFjZS4gVGhlIG5ldyByZXZlbnVlIGludGVyZmFjZSBhbGxvd3MgZm9yIG1vcmUgcmV2ZW51ZSBmaWVsZHMgbGlrZVxuICAgICAqIHJldmVudWVUeXBlIGFuZCBldmVudCBwcm9wZXJ0aWVzLlxuICAgICAqIFNlZSBbUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0I3RyYWNraW5nLXJldmVudWV9XG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIFJldmVudWUgaW50ZXJmYWNlIGFuZCBsb2dnaW5nIHJldmVudWUuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7UmV2ZW51ZX0gcmV2ZW51ZV9vYmogLSB0aGUgcmV2ZW51ZSBvYmplY3QgY29udGFpbmluZyB0aGUgcmV2ZW51ZSBkYXRhIGJlaW5nIGxvZ2dlZC5cbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmxvZ1JldmVudWVWMihyZXZlbnVlX29iaik7XG4gICAgICogQGV4YW1wbGUgdmFyIHJldmVudWUgPSBuZXcgYW1wbGl0dWRlLlJldmVudWUoKS5zZXRQcm9kdWN0SWQoJ3Byb2R1Y3RJZGVudGlmaWVyJykuc2V0UHJpY2UoMTAuOTkpO1xuICAgICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUubG9nUmV2ZW51ZVYyID0gZnVuY3Rpb24gbG9nUmV2ZW51ZVYyKHJldmVudWVfb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmxvZ1JldmVudWVWMihyZXZlbnVlX29iaik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgcmV2ZW51ZSBldmVudCB3aXRoIGEgcHJpY2UsIHF1YW50aXR5LCBhbmQgcHJvZHVjdCBpZGVudGlmaWVyLiBERVBSRUNBVEVEIC0gdXNlIGxvZ1JldmVudWVWMlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJpY2UgLSBwcmljZSBvZiByZXZlbnVlIGV2ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YW50aXR5IC0gKG9wdGlvbmFsKSBxdWFudGl0eSBvZiBwcm9kdWN0cyBpbiByZXZlbnVlIGV2ZW50LiBJZiBubyBxdWFudGl0eSBzcGVjaWZpZWQgZGVmYXVsdCB0byAxLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9kdWN0IC0gKG9wdGlvbmFsKSBwcm9kdWN0IGlkZW50aWZpZXJcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmxvZ1JldmVudWVWMihyZXZlbnVlX29iaik7XG4gICAgICogQGV4YW1wbGUgYW1wbGl0dWRlLmxvZ1JldmVudWUoMy45OSwgMSwgJ3Byb2R1Y3RfMTIzNCcpO1xuICAgICAqL1xuXG5cbiAgICBBbXBsaXR1ZGUucHJvdG90eXBlLmxvZ1JldmVudWUgPSBmdW5jdGlvbiBsb2dSZXZlbnVlKHByaWNlLCBxdWFudGl0eSwgcHJvZHVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5sb2dSZXZlbnVlKHByaWNlLCBxdWFudGl0eSwgcHJvZHVjdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnRzIGluIHN0b3JhZ2Ugd2l0aCBldmVudCBpZHMgdXAgdG8gYW5kIGluY2x1ZGluZyBtYXhFdmVudElkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQpIHtcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5yZW1vdmVFdmVudHMobWF4RXZlbnRJZCwgbWF4SWRlbnRpZnlJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIHVuc2VudCBldmVudHMuIE5vdGU6IHRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZXZlbnRzIGFyZSBsb2dnZWQgaWYgb3B0aW9uIGJhdGNoRXZlbnRzIGlzIGZhbHNlLlxuICAgICAqIElmIGJhdGNoRXZlbnRzIGlzIHRydWUsIHRoZW4gZXZlbnRzIGFyZSBvbmx5IHNlbnQgd2hlbiBiYXRjaCBjcml0ZXJpYXMgYXJlIG1ldC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IGNhbGxiYWNrIC0gKG9wdGlvbmFsKSBjYWxsYmFjayB0byBydW4gYWZ0ZXIgZXZlbnRzIGFyZSBzZW50LlxuICAgICAqIE5vdGUgdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGFzIGlucHV0IGFyZ3VtZW50cy5cbiAgICAgKi9cblxuXG4gICAgQW1wbGl0dWRlLnByb3RvdHlwZS5zZW5kRXZlbnRzID0gZnVuY3Rpb24gc2VuZEV2ZW50cyhjYWxsYmFjaykge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNlbmRFdmVudHMoY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGdsb2JhbCB1c2VyIHByb3BlcnRpZXMuIE5vdGUgdGhpcyBpcyBkZXByZWNhdGVkLCBhbmQgd2UgcmVjb21tZW5kIHVzaW5nIHNldFVzZXJQcm9wZXJ0aWVzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG5cblxuICAgIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0R2xvYmFsVXNlclByb3BlcnRpZXMgPSBmdW5jdGlvbiBzZXRHbG9iYWxVc2VyUHJvcGVydGllcyh1c2VyUHJvcGVydGllcykge1xuICAgICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBBbXBsaXR1ZGUncyBKYXZhc2NyaXB0IFNESy5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2ZXJzaW9uIG51bWJlclxuICAgKiBAZXhhbXBsZSB2YXIgYW1wbGl0dWRlVmVyc2lvbiA9IGFtcGxpdHVkZS5fX1ZFUlNJT05fXztcbiAgICovXG5cblxuICBBbXBsaXR1ZGUucHJvdG90eXBlLl9fVkVSU0lPTl9fID0gdmVyc2lvbjtcblxuICAvKiBqc2hpbnQgZXhwcjp0cnVlICovXG4gIHZhciBvbGQgPSB3aW5kb3cuYW1wbGl0dWRlIHx8IHt9O1xuICB2YXIgbmV3SW5zdGFuY2UgPSBuZXcgQW1wbGl0dWRlKCk7XG4gIG5ld0luc3RhbmNlLl9xID0gb2xkLl9xIHx8IFtdO1xuXG4gIGZvciAodmFyIGluc3RhbmNlIGluIG9sZC5faXEpIHtcbiAgICAvLyBtaWdyYXRlIGVhY2ggaW5zdGFuY2UncyBxdWV1ZVxuICAgIGlmIChvbGQuX2lxLmhhc093blByb3BlcnR5KGluc3RhbmNlKSkge1xuICAgICAgbmV3SW5zdGFuY2UuZ2V0SW5zdGFuY2UoaW5zdGFuY2UpLl9xID0gb2xkLl9pcVtpbnN0YW5jZV0uX3EgfHwgW107XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG5ld0luc3RhbmNlLnJ1blF1ZXVlZEZ1bmN0aW9ucygpO1xuICB9IC8vIGV4cG9ydCB0aGUgaW5zdGFuY2VcblxuICByZXR1cm4gbmV3SW5zdGFuY2U7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amplitude-js/amplitude.umd.js\n");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2I2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./src/containers/_app/navbar.tsx":
/*!****************************************!*\
  !*** ./src/containers/_app/navbar.tsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _app_containers_common_file_upload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @app/containers/_common/file-upload */ \"./src/containers/_common/file-upload.tsx\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-bootstrap */ \"./node_modules/react-bootstrap/esm/index.js\");\n/* harmony import */ var _app_utils_amplitude__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @app/utils/amplitude */ \"./src/utils/amplitude/index.ts\");\nvar _this = undefined,\n    _jsxFileName = \"/Users/even.chang/workspace/side-projects/terraform-visual/src/containers/_app/navbar.tsx\";\n\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\n  return __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Navbar\"], {\n    bg: \"light\",\n    variant: \"light\",\n    expand: \"lg\",\n    fixed: \"top\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 5\n    }\n  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n    href: \"/\",\n    as: \"/terraform-visual\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 7\n    }\n  }, __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Navbar\"].Brand, {\n    href: \"#\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 9\n    }\n  }, \"Terraform Visual\")), __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Navbar\"].Toggle, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 7\n    }\n  }), __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Navbar\"].Collapse, {\n    className: \"justify-content-end\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 7\n    }\n  }, __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Nav\"], {\n    className: \"mr-auto\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 9\n    }\n  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n    href: \"/\",\n    as: \"/terraform-visual\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 11\n    }\n  }, __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"Nav\"].Link, {\n    href: \"/\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 18,\n      columnNumber: 13\n    }\n  }, \"Home\")), __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"NavDropdown\"], {\n    title: \"Examples\",\n    id: \"basic-nav-dropdown\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 11\n    }\n  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n    href: \"/examples/aws-s3\",\n    as: \"/terraform-visual/examples/aws-s3\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22,\n      columnNumber: 13\n    }\n  }, __jsx(react_bootstrap__WEBPACK_IMPORTED_MODULE_3__[\"NavDropdown\"].Item, {\n    href: \"/examples/aws-s3\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 15\n    }\n  }, \"AWS S3\")))), __jsx(_app_containers_common_file_upload__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 9\n    }\n  })));\n});\n\nvar afterFileUploaded = function afterFileUploaded() {\n  _app_utils_amplitude__WEBPACK_IMPORTED_MODULE_4__[\"Amplitude\"].logEvent('upload file', {\n    component: 'navbar'\n  });\n};\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports_1 = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports_1;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29udGFpbmVycy9fYXBwL25hdmJhci50c3g/MTFiYiJdLCJuYW1lcyI6WyJhZnRlckZpbGVVcGxvYWRlZCIsIkFtcGxpdHVkZSIsImxvZ0V2ZW50IiwiY29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFZSwyRUFBTTtBQUNuQixTQUNFLE1BQUMsc0RBQUQ7QUFBUSxNQUFFLEVBQUMsT0FBWDtBQUFtQixXQUFPLEVBQUMsT0FBM0I7QUFBbUMsVUFBTSxFQUFDLElBQTFDO0FBQStDLFNBQUssRUFBQyxLQUFyRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0UsTUFBQyxnREFBRDtBQUFNLFFBQUksRUFBQyxHQUFYO0FBQWUsTUFBRSxFQUFDLG1CQUFsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0UsTUFBQyxzREFBRCxDQUFRLEtBQVI7QUFBYyxRQUFJLEVBQUMsR0FBbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3QkFERixDQURGLEVBS0UsTUFBQyxzREFBRCxDQUFRLE1BQVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUxGLEVBT0UsTUFBQyxzREFBRCxDQUFRLFFBQVI7QUFBaUIsYUFBUyxFQUFDLHFCQUEzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0UsTUFBQyxtREFBRDtBQUFLLGFBQVMsRUFBQyxTQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLGdEQUFEO0FBQU0sUUFBSSxFQUFDLEdBQVg7QUFBZSxNQUFFLEVBQUMsbUJBQWxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLG1EQUFELENBQUssSUFBTDtBQUFVLFFBQUksRUFBQyxHQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFERixDQURGLEVBS0UsTUFBQywyREFBRDtBQUFhLFNBQUssRUFBQyxVQUFuQjtBQUE4QixNQUFFLEVBQUMsb0JBQWpDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLGdEQUFEO0FBQ0UsUUFBSSxFQUFDLGtCQURQO0FBRUUsTUFBRSxFQUFDLG1DQUZMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FJRSxNQUFDLDJEQUFELENBQWEsSUFBYjtBQUFrQixRQUFJLEVBQUMsa0JBQXZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FKRixDQURGLENBTEYsQ0FERixFQWtCRSxNQUFDLDBFQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFsQkYsQ0FQRixDQURGO0FBOEJELENBL0JEOztBQWlDQSxJQUFNQSxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLEdBQU07QUFDOUJDLGdFQUFTLENBQUNDLFFBQVYsQ0FBbUIsYUFBbkIsRUFBa0M7QUFBRUMsYUFBUyxFQUFFO0FBQWIsR0FBbEM7QUFDRCxDQUZEIiwiZmlsZSI6Ii4vc3JjL2NvbnRhaW5lcnMvX2FwcC9uYXZiYXIudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZpbGVVcGxvYWQgZnJvbSAnQGFwcC9jb250YWluZXJzL19jb21tb24vZmlsZS11cGxvYWQnXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXG5pbXBvcnQgeyBOYXYsIE5hdmJhciwgTmF2RHJvcGRvd24gfSBmcm9tICdyZWFjdC1ib290c3RyYXAnXG5pbXBvcnQgeyBBbXBsaXR1ZGUgfSBmcm9tICdAYXBwL3V0aWxzL2FtcGxpdHVkZSdcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxOYXZiYXIgYmc9XCJsaWdodFwiIHZhcmlhbnQ9XCJsaWdodFwiIGV4cGFuZD1cImxnXCIgZml4ZWQ9XCJ0b3BcIj5cbiAgICAgIDxMaW5rIGhyZWY9XCIvXCIgYXM9XCIvdGVycmFmb3JtLXZpc3VhbFwiPlxuICAgICAgICA8TmF2YmFyLkJyYW5kIGhyZWY9XCIjXCI+VGVycmFmb3JtIFZpc3VhbDwvTmF2YmFyLkJyYW5kPlxuICAgICAgPC9MaW5rPlxuXG4gICAgICA8TmF2YmFyLlRvZ2dsZSAvPlxuXG4gICAgICA8TmF2YmFyLkNvbGxhcHNlIGNsYXNzTmFtZT1cImp1c3RpZnktY29udGVudC1lbmRcIj5cbiAgICAgICAgPE5hdiBjbGFzc05hbWU9XCJtci1hdXRvXCI+XG4gICAgICAgICAgPExpbmsgaHJlZj1cIi9cIiBhcz1cIi90ZXJyYWZvcm0tdmlzdWFsXCI+XG4gICAgICAgICAgICA8TmF2LkxpbmsgaHJlZj1cIi9cIj5Ib21lPC9OYXYuTGluaz5cbiAgICAgICAgICA8L0xpbms+XG5cbiAgICAgICAgICA8TmF2RHJvcGRvd24gdGl0bGU9XCJFeGFtcGxlc1wiIGlkPVwiYmFzaWMtbmF2LWRyb3Bkb3duXCI+XG4gICAgICAgICAgICA8TGlua1xuICAgICAgICAgICAgICBocmVmPVwiL2V4YW1wbGVzL2F3cy1zM1wiXG4gICAgICAgICAgICAgIGFzPVwiL3RlcnJhZm9ybS12aXN1YWwvZXhhbXBsZXMvYXdzLXMzXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPE5hdkRyb3Bkb3duLkl0ZW0gaHJlZj1cIi9leGFtcGxlcy9hd3MtczNcIj5cbiAgICAgICAgICAgICAgICBBV1MgUzNcbiAgICAgICAgICAgICAgPC9OYXZEcm9wZG93bi5JdGVtPlxuICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgIDwvTmF2RHJvcGRvd24+XG4gICAgICAgIDwvTmF2PlxuXG4gICAgICAgIDxGaWxlVXBsb2FkIC8+XG4gICAgICA8L05hdmJhci5Db2xsYXBzZT5cbiAgICA8L05hdmJhcj5cbiAgKVxufVxuXG5jb25zdCBhZnRlckZpbGVVcGxvYWRlZCA9ICgpID0+IHtcbiAgQW1wbGl0dWRlLmxvZ0V2ZW50KCd1cGxvYWQgZmlsZScsIHsgY29tcG9uZW50OiAnbmF2YmFyJyB9KVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/containers/_app/navbar.tsx\n");

/***/ }),

/***/ "./src/utils/amplitude/index.ts":
/*!**************************************!*\
  !*** ./src/utils/amplitude/index.ts ***!
  \**************************************/
/*! exports provided: Amplitude */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Amplitude\", function() { return Amplitude; });\nvar Amplitude = true ? __webpack_require__(/*! amplitude-js */ \"./node_modules/amplitude-js/amplitude.umd.js\") : undefined;\n\nif (Amplitude && \"ce76f465dd2831596dcf54245bcf4bb1\") {\n  Amplitude.init(\"ce76f465dd2831596dcf54245bcf4bb1\");\n}\n\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports_1 = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports_1;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvYW1wbGl0dWRlL2luZGV4LnRzP2U0ZDkiXSwibmFtZXMiOlsiQW1wbGl0dWRlIiwicmVxdWlyZSIsInByb2Nlc3MiLCJpbml0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUEsSUFBTUEsU0FBb0MsR0FBRyxPQUN6Q0MsbUJBQU8sQ0FBQyxrRUFBRCxDQURrQyxHQUV6QyxTQUZKOztBQUlBLElBQUlELFNBQVMsSUFBSUUsa0NBQWpCLEVBQTREO0FBQzFERixXQUFTLENBQUNHLElBQVYsQ0FBZUQsa0NBQWY7QUFDRDs7QUFFRCIsImZpbGUiOiIuL3NyYy91dGlscy9hbXBsaXR1ZGUvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBbXBsaXR1ZGU6IGFtcGxpdHVkZS5BbXBsaXR1ZGVDbGllbnQgPSBwcm9jZXNzLmJyb3dzZXJcbiAgPyByZXF1aXJlKCdhbXBsaXR1ZGUtanMnKVxuICA6IG51bGxcblxuaWYgKEFtcGxpdHVkZSAmJiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BTVBMSVRVREVfQVBJX0tFWSkge1xuICBBbXBsaXR1ZGUuaW5pdChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BTVBMSVRVREVfQVBJX0tFWSlcbn1cblxuZXhwb3J0IHsgQW1wbGl0dWRlIH1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/amplitude/index.ts\n");

/***/ })

})